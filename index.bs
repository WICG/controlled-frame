<pre class="metadata">
Title: Controlled Frame API
Abstract: This document defines an API for embedding arbitrary web content only
    within the context of an Isolated Web Application (IWA). The embedded
    content is a new top-level browsing context within and controlled by the
    embedder.
Repository: WICG/controlled-frame
URL: https://wicg.github.io/controlled-frame/
Status: w3c/CG-DRAFT
Shortname: controlled-frame
Level: 1
Editor: Chase Phillips 115880, Google LLC https://google.com, cmp@chromium.org
Editor: Robbie McElrath 139758, Google LLC https://google.com, rmcelrath@chromium.org
Editor: Zelin Liu 164998, Google LLC https://google.com, zelin@chromium.org

Group: WICG
Markup Shorthands: markdown yes
</pre>

<style>
.domintro::before {
    content: 'For web developers (non-normative)';
    text-transform: initial;
}
.domintro dt {
    font-family: Menlo, Consolas, "DejaVu Sans Mono", Monaco, monospace;

    padding-top: 0.5em;
    padding-bottom: 1em;
}
.domintro dt a {
    color: inherit; border-bottom-style: none;
}
.domintro dt code {
    font-size: inherit;
}

/* Put nice boxes around each algorithm. */
[data-algorithm]:not(.heading) {
  padding: .5em;
  border: thin solid #ddd; border-radius: .5em;
  margin: .5em calc(-0.5em - 1px);
}
[data-algorithm]:not(.heading) > :first-child {
  margin-top: 0;
}
[data-algorithm]:not(.heading) > :last-child {
  margin-bottom: 0;
}
[data-algorithm] [data-algorithm] {
  margin: 1em 0;
}

table {
  border-collapse: collapse;
  width: 100%;
}

th, td {
  border: 1px solid black;
  padding: 2px 8px;
  text-align: center;
  vertical-align: middle;
}

/* .XXX from https://resources.whatwg.org/standard.css */
.XXX {
  color: #D50606;
  background: white;
  border: solid #D50606;
}
</style>

<pre class="biblio">
{
  "isolated-web-apps": {
    "authors": [
      "Reilly Grant"
    ],
    "href": "https://github.com/WICG/isolated-web-apps/blob/main/README.md",
    "title": "Isolated Web Apps Explainer"
  },
  "high-watermark-permissions": {
    "authors": [
        "Robbie McElrath"
    ],
    "href": "https://github.com/WICG/isolated-web-apps/blob/main/Permissions.md",
    "title": "Isolated Web Apps High Watermark Permissions Explainer"
  }
}
</pre>

<pre class="anchors">
spec: console; urlPrefix: https://console.spec.whatwg.org/
    type: dfn
        urlPrefix: /
            text: printer; for: /; url: printer

spec: html; urlPrefix: https://html.spec.whatwg.org/multipage/
    type: dfn
        urlPrefix: /
            text: simple-dialogs; for: /; url: simple-dialogs
        urlPrefix: browsing-the-web.html
            text: apply the traverse history step; url: apply-the-traverse-history-step
            text: document state; url: she-document-state
            text: get all used history steps; url: getting-all-used-history-steps
            text: reload; url: reload
            for: session history entry
                text: step; url: she-step
                text: URL; url: she-url
        urlPrefix: document-lifecycle.html
            text: completely loaded; url: completely-loaded
            text: stop loading; url: nav-stop
        urlPrefix: document-sequences.html
            text: browsing context group; url: browsing-context-group
            text: create a new browsing context and document; url: creating-a-new-browsing-context
            text: current session history entry; url: nav-current-history-entry
            text: navigable; for: /; url: navigable
            text: initialize the navigable; url: initialize-the-navigable
            for: navigable
                text: active session history entry; url: nav-active-history-entry
            for: traversable navigable
                text: session history entries; url: tn-session-history-entries
        urlPrefix: dom.html
            text: contexts in which this element can be used; url: concept-element-contexts
            text: content model; url: concept-element-content-model
            text: event; url: events
            text: nothing; url: concept-content-nothing
            text: content attributes; url: concept-element-attributes
            text: global attributes; url: global-attributes
            text: dom interface; url: concept-element-dom
            text: represents; url: represents
            text: accessibility considerations; url: concept-element-accessibility-considerations
        urlPrefix: embedded-content.html
            text: src; url: attr-source-src
        urlPrefix: embedded-content-other.html
            text: width; url: attr-dim-width
            text: height; url: attr-dim-height
        urlPrefix: links.html
            text: href; url: attr-hyperlink-href
        urlPrefix: nav-history-apis.html
            text: navigable; for: window; url: window-navigable
        urlPrefix: webappapis.html
            text: create a classic script; url: creating-a-classic-script
            text: default script fetch options; url: default-script-fetch-options
            text: environment; url: environment

spec: fetch; urlPrefix: https://fetch.spec.whatwg.org/
    type: dfn
        urlPrefix: /
            text: HTTP-network fetch; url: concept-http-network-fetch
            text: HTTP-network-or-cache fetch; url: concept-http-network-or-cache-fetch
            text: fetch response handover; url: fetch-finale
            text: main fetch; url: main-fetch
            text: request; for: fetch params; url: fetch-params-request

spec: infra; urlPrefix: https://infra.spec.whatwg.org
    type: dfn
        text: empty; for: map; url: map-is-empty

spec: storage; urlPrefix: https://storage.spec.whatwg.org
    type: dfn
        text: storage shelf; url: storage-shelf

spec: webidl; urlPrefix: https://webidl.spec.whatwg.org
    type: dfn
        text: Web IDL Standard; url: introduction
        text: async iterator; url: idl-async-iterable
        text: promise; url: idl-promise
        text: promise rejected; url: a-promise-rejected-with
        text: promise resolved; url: a-promise-resolved-with

spec: uievents; urlPrefix https://www.w3.org/TR/uievents/
    type: dfn
        text: contextmenu; url: event-type-contextmenu
        text: click; url: event-type-click

text: match pattern; type: dfn; url: https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Match_patterns;
</pre>

<pre class=link-defaults>
spec:fetch; type:dfn; for:/; text:header list
spec:fetch; type:dfn; for:/; text:request
spec:fetch; type:dfn; for:/; text:response
spec:html; type:dfn; for:/; text:browsing context
spec:html; type:dfn; for:/; text:global object
spec:html; type:dfn; for:/; text:top-level traversable
spec:html; type:dfn; for:/; text:traversable navigable
spec:infra; type:dfn; for:/; text:set
spec:infra; type:dfn; text:list
spec:infra; type:dfn; text:byte sequence
spec:webidl; type:dfn; text:attribute
spec:webidl; type:interface; text:long
</pre>

<!-- ====================================================================== -->
# Introduction # {#introduction}
<!-- ====================================================================== -->

This specification describes a content embedding API that satisfies some
critical use cases for IWAs that <{iframe}> does not support. This embedding
environment should allow embedding all content without express permission from
the embedded site, including content which <{iframe}> cannot embed, and provide
embedding sites more control over that embedded content.

Since this is a particularly powerful API, its use and availability makes an app
a target of various types of hacking. As a result, this API is limited to use in
[[Isolated-Web-Apps|Isolated Web Applications]] (IWAs) which have addtional
safeguards in place to protect users and developers.  IWAs are not a normal web
application and can exist only at a special 'isolated-app:' scheme. This means
by design that this API will not be available to normal web pages.

Note: This API is not intended to be a replacement or substitute for <{iframe}>.
All <{iframe}> use cases are still valid and should continue to use <{iframe}>,
including IWAs where possible.

<!-- ====================================================================== -->
<h2 id=based-on-fencedframe-spec>The Fenced Frame specification</h2>
<!-- ====================================================================== -->

For convenience, the Controlled Frame specification assumes that the Fenced
Frame specification is in place. There are concepts introduced in the Fenced
Frame specification, such as nested top-level traversables, that are broadly
useful to refer to in the context of Controlled Frame.

The Fenced Frame specification achieves defining these concepts via monkey
patching some specifications, such as HTML. We will also require monkey
patching specifications for some parts of this Controlled Frame specification.

<!-- ====================================================================== -->
<h2 id=the-controlledframe-element>The <dfn element export>controlledframe</dfn> element</h2>
<!-- ====================================================================== -->

<dl class="element">
 <dt>[=Categories=]:</dt>
 <dd>[=Flow content=].</dd>
 <dd>[=Phrasing content=].</dd>
 <dd>[=Embedded content=].</dd>
 <dd>[=Interactive content=].</dd>
 <dd>[=Palpable content=].</dd>
 <dt>[=Contexts in which this element can be used=]:</dt>
 <dd>Where [=embedded content=] is expected.</dd>
 <dt>[=Content model=]:</dt>
 <dd>[=Nothing=].</dd>
 <dt>[=Content attributes=]:</dt>
 <dd>[=Global attributes=]</dd>
 <dd><code>{{src}}</code> — Content source URL to embed</dd>
 <dd><code>{{partition}}</code> — Partition name to hold data related to this content</dd>
 <dt>[=Accessibility considerations=]:</dt>
 <dd><p class=XXX>Screen readers should be able to traverse into
 the embedded content similar to how a reader can traverse into iframes and
 other related embedded content.</p></dd>
 <dt>[=DOM interface=]:</dt>
 <dd>
<xmp class=idl>
[Exposed=Window, IsolatedContext]
interface HTMLControlledFrameElement : HTMLElement {
    [HTMLConstructor] constructor();

    [CEReactions] attribute USVString src;
    attribute DOMString partition;

    readonly attribute WindowProxy? contentWindow;
    readonly attribute ContextMenus contextMenus;
    readonly attribute WebRequest request;

    // Navigation methods.
    Promise<undefined> back();
    boolean canGoBack();
    boolean canGoForward();
    Promise<undefined> forward();
    Promise<undefined> go(long relativeIndex);
    undefined reload();
    undefined stop();

    // Scripting methods.
    Promise<undefined> addContentScripts(sequence<ContentScriptDetails> contentScriptList);
    Promise<any> executeScript(optional InjectDetails details = {});
    Promise<undefined> insertCSS(optional InjectDetails details = {});
    Promise<undefined> removeContentScripts(sequence<DOMString>? scriptNameList);

    // Configuration methods.
    Promise<undefined> clearData(
      optional ClearDataOptions options = {},
      optional ClearDataTypeSet types = {});
    Promise<boolean> getAudioState();
    Promise<long> getZoom();
    Promise<boolean> isAudioMuted();
    undefined setAudioMuted(boolean mute);
    Promise<undefined> setZoom(long zoomFactor);

    // Capture methods.
    Promise<undefined> captureVisibleRegion(optional ImageDetails options = {});
    undefined print();

    // Events:
    attribute EventHandler onconsolemessage;
    attribute EventHandler oncontentload;
    attribute EventHandler ondialog;
    attribute EventHandler onloadabort;
    attribute EventHandler onloadcommit;
    attribute EventHandler onloadstart;
    attribute EventHandler onloadstop;
    attribute EventHandler onnewwindow;
    attribute EventHandler onpermissionrequest;
    attribute EventHandler onsizechanged;
    attribute EventHandler onzoomchange;
};
</xmp>
</dd>
</dl>

The <{controlledframe}> element [=represents=] its [=embedded navigable=].

Descendents of <{controlledframe}> elements represent nothing.

The Controlled Frame element is exposed to any {{Document}} with the
"`controlled-frame`" [=policy-controlled feature=] whose
[=environment settings object=] is an [=isolated context=].

The IDL attributes {{HTMLControlledFrameElement/src}} and
{{HTMLControlledFrameElement/partition}} must [=reflect=] the respective content
attributes of the same name.

Each <{controlledframe}> has an <dfn for=controlledframe>embedded navigable</dfn>,
which is either a [=traversable navigable=] with a non-null [=embedderParent=],
or null. It is initially null.

Note: The [=embedded navigable=] appears as a top-level traversable with a
null [=navigable/parent=]. Content within the [=embedded navigable=] cannot
detect that it is embedded.

Each <{controlledframe}> has a <dfn for=controlledframe>content script map</dfn>,
which is a [=map=] whose [=map/keys=] are [=strings=] and whose [=map/values=]
are [=content script config=]s.

<div algorithm=insertion>
  When a <{controlledframe}> element |element| is [=inserted into a document=]
  whose [=browsing context=] is non-null, run the following steps:

  1. If |element|'s {{HTMLControlledFrameElement/src}} is not empty, then:

      1. [=Initialize a controlledframe=] given |element|.

</div>

<div algorithm=destroy>
  When a <{controlledframe}> element |element| is [=removed from a document=],
  run the following steps:

  1. TODO: destroy |element|'s [=embedded navigable=].

</div>

<div algorithm>
  To <dfn>initialize a <{controlledframe}></dfn> element |element|, run the
  following steps:

  1. [=Assert=] that |element|'s [=embedded navigable=] is null.

  1. Let |group| be a new [=browsing context group=].

  1. Let |document| be the second return value of [=creating a new browsing
      context and document=] given |element|'s [=node document=], |element|,
      and |group|.

  1. Let |documentState| be a new [=document state=], whose [=/document=]
      is |document|.

  1. Let |traversable| be a new [=traversable navigable=].

  1. [=Initialize the navigable=] |traversable| given |documentState|.

  1. Set |traversable|'s [=embedderParent=] to |element|.

  1. Set |element|'s [=embedded navigable=] to |traversable|.

  1. Let |initialHistoryEntry| be |traversable|'s [=navigable/active
      session history entry=].

  1. Set |initialHistoryEntry|'s [=session history entry/step=] to 0.

  1. [=list/Append=] |initialHistoryEntry| to |traversable|'s [=traversable
      navigable/session history entries=].

      Issue: These steps are needed to initialize {{History}}.{{History/length}}
          in the new navigable. This is an existing
          <a href="https://github.com/whatwg/html/issues/9030">issue</a>
          in the HTML Standard.

  1. Set |element|'s {{HTMLControlledFrameElement/contentWindow}} to
      |document|'s {{WindowProxy}}.

  1. [=Navigate a controlledframe=] given |element| and |element|'s
      {{HTMLControlledFrameElement/src}}.

</div>

<div algorithm>
  To <dfn>navigate a <{controlledframe}></dfn> element |element| given a
  {{USVString}} |urlString|, run the following steps:

  1. If |urlString| is not an [=absolute-URL string=], return.

  1. Let |url| be the result of running the [=URL parser=] given |urlString|.

  1. Let |historyHandling| be "{{NavigationHistoryBehavior/auto}}".

  1. If |element|'s [=embedded navigable=]'s [=active document=] is not
      [=completely loaded=], then set |historyHandling| to
      "{{NavigationHistoryBehavior/replace}}".

  1. [=Navigate=] |element|'s [=embedded navigable=] to |url| using |element|'s
      [=node document=], with a {{NavigationHistoryBehavior}} of |historyHandling|.

</div>

<div algorithm>
  The <dfn constructor for=HTMLControlledFrameElement>HTMLControlledFrameElement()</dfn>
  constructor steps are:

  1. Let |webRequest| be [=this=]'s {{HTMLControlledFrameElement/request}}.

  1. Set the [=WebRequestEvent/eventName=] and [=WebRequestEvent/webRequest=]
      fields of |webRequest|[{{WebRequest/onBeforeRequest}}] to
      `"beforeRequest"` and |webRequest| respectively.

  1. Set the [=WebRequestEvent/eventName=] and [=WebRequestEvent/webRequest=]
      fields of |webRequest|[{{WebRequest/onBeforeSendHeaders}}] to
      `"beforeSendHeaders"` and |webRequest| respectively.

  1. Set the [=WebRequestEvent/eventName=] and [=WebRequestEvent/webRequest=]
      fields of |webRequest|[{{WebRequest/onSendHeaders}}] to
      `"sendHeaders"` and |webRequest| respectively.

  1. Set the [=WebRequestEvent/eventName=] and [=WebRequestEvent/webRequest=]
      fields of |webRequest|[{{WebRequest/onHeadersReceived}}] to
      `"headersReceived"` and |webRequest| respectively.

  1. Set the [=WebRequestEvent/eventName=] and [=WebRequestEvent/webRequest=]
      fields of |webRequest|[{{WebRequest/onAuthRequired}}] to
      `"authRequired"` and |webRequest| respectively.

  1. Set the [=WebRequestEvent/eventName=] and [=WebRequestEvent/webRequest=]
      fields of |webRequest|[{{WebRequest/onBeforeRedirect}}] to
      `"beforeRedirect"` and |webRequest| respectively.

  1. Set the [=WebRequestEvent/eventName=] and [=WebRequestEvent/webRequest=]
      fields of |webRequest|[{{WebRequest/onResponseStarted}}] to
      `"responseStarted"` and |webRequest| respectively.

  1. Set the [=WebRequestEvent/eventName=] and [=WebRequestEvent/webRequest=]
      fields of |webRequest|[{{WebRequest/onCompleted}}] to
      `"completed"` and |webRequest| respectively.

  1. Set the [=WebRequestEvent/eventName=] and [=WebRequestEvent/webRequest=]
      fields of |webRequest|[{{WebRequest/onErrorOccurred}}] to
      `"errorOccurred"` and |webRequest| respectively.

</div>

<!-- ====================================================================== -->
## Attributes ## {#attributes}
<!-- ====================================================================== -->

The {{HTMLControlledFrameElement/partition}} attribute takes an identifier
specifying where data related to the Controlled Frame's instance should be
stored. The identifier is composed of a string of alphanumeric characters.
All data for the [=embedded navigable=] will be stored in a [=storage shelf=]
keyed by this partition string along with the origin that created the data.

By default, all data stored will be held in an in-memory storage partition so
that when the last Controlled Frame element with a given
{{HTMLControlledFrameElement/partition}} value is destroyed, the data is also
destroyed. While the data is held in this partition, no data from the
Controlled Frame's [=embedded navigable=] will persist.

If the partition attribute identifier contains the prefix "persist:", the user
agent will use a disk-based storage environment rather than an in-memory
storage partition. Embedded content should not be able to detect whether its
storage is in-memory or persistent.

If multiple Controlled Frames share the same partition identifier, all of their
[=embedded navigable=] instances will share the same storage partition.

Note: The [[STORAGE]] specification is monkey patched below to partition
storage based on the value of the {{HTMLControlledFrameElement/partition}}
attribute.

<div algorithm=partition-setter>
  The {{HTMLControlledFrameElement/partition}} IDL attribute setter steps are:

  1. If [=this=]'s [=embedded navigable=] is not null, then:

      1. [=Throw=] a "{{NotSupportedError}}" {{DOMException}}.

      1. Do not change the value of {{HTMLControlledFrameElement/partition}}.

</div>

The {{HTMLControlledFrameElement/src}} attribute reflects the Controlled
Frame's [=embedded navigable=]'s [=current session history entry=]'s
[=session history entry/URL=].

<div algorithm=src-setter>
  The {{HTMLControlledFrameElement/src}} IDL attribute setter steps are:

  1. If [=this=] is not [=in a document tree=], then return.

  1. If [=this=]'s [=embedded navigable=] is null, then:

      1. [=Initialize a controlledframe=] given [=this=].

  1. Otherwise:

      1. [=Navigate a controlledframe=] given [=this=] and [=this=]'s
          {{HTMLControlledFrameElement/src}}.

</div>

<!-- ====================================================================== -->
## Navigation methods ## {#api-nav}
<!-- ====================================================================== -->

<div class="domintro note">

  : {{HTMLControlledFrameElement/back()|back}}()

  :: Goes back one step in the overall
    <a href="https://html.spec.whatwg.org/multipage/document-sequences.html#tn-session-history-entries">
    session history entries </a> list for the
    <a href="https://html.spec.whatwg.org/multipage/document-sequences.html#traversable-navigable">
    traversable navigable</a> in the Controlled Frame.

    If there is no previous page, does nothing.

  : {{HTMLControlledFrameElement/canGoBack()|canGoBack}}()

  :: Returns true if the current
     <a href="https://html.spec.whatwg.org/multipage/document-sequences.html#nav-current-history-entry">
     current session history entry</a> is not the first one in the navigation
     history entry list. This means that there is a previous
     <a href="https://html.spec.whatwg.org/multipage/browsing-the-web.html#session-history-entry">
     session history entry</a> for this
     <a href="https://html.spec.whatwg.org/multipage/document-sequences.html#navigable">
     navigable</a>.

  : {{HTMLControlledFrameElement/forward()|forward}}()

  :: Goes forward one step in the overall
    <a href="https://html.spec.whatwg.org/multipage/document-sequences.html#tn-session-history-entries">
    session history entries </a> list for the
    <a href="https://html.spec.whatwg.org/multipage/document-sequences.html#traversable-navigable">
    traversable navigable</a> in the Controlled Frame.

    If there is no next page, does nothing.

  : {{HTMLControlledFrameElement/go()|go}}()

  :: Reloads the current page.

  : {{HTMLControlledFrameElement/go()|go}}(<var>relativeIndex</var>)

  :: Goes back or forward <var>relativeIndex</var> number of steps in the overall
    <a href="https://html.spec.whatwg.org/multipage/document-sequences.html#tn-session-history-entries">
    session history entries </a> list for the current
    <a href="https://html.spec.whatwg.org/multipage/document-sequences.html#traversable-navigable">
    traversable navigable</a>.

    A zero relative index will reload the current page.

    If the relative index is out of range, does nothing.

  : {{HTMLControlledFrameElement/reload()|reload}}()

  :: Reloads the current page.

  : {{HTMLControlledFrameElement/stop()|stop}}()

  :: Cancels the document load.

</div>

<div algorithm>
  To <dfn>traverse an embedded navigable's history</dfn>, given a
  <{controlledframe}> |controlledframe| and an integer |stepDelta|, run the
  following steps:

  1. Let |resultPromise| be a new [=promise=].

  1. Return |resultPromise| and run the remaining steps [=in parallel=].

  1. If |controlledframe|'s [=embedded navigable=] is null, then [=resolve=]
      |resultPromise| with false.

  1. Let |currentStep| be |controlledframe|'s [=embedded navigable=]'s
      [=current session history step=].

  1. Let |step| be the sum of |currentStep| and |stepDelta|.

  1. If |step| is negative, then [=resolve=] |resultPromise| with false.

  1. If |step| is greater than or equal to the [=list/size=] of the
      |controlledframe|'s [=embedded navigable=]'s [=session history entries=],
      then [=resolve=] |resultPromise| with false.

  1. Let |result| be the result of [=applying the traverse history step=]
      given |step|, |controlledframe|'s [=embedded navigable=], and a
      [=user navigation involvement=] of "[=browser UI=]".

  1. If |result| is not equal to "`applied`", [=resolve=] |resultPromise|
      with false.

  1. Otherwise, [=resolve=] |resultPromise| with true.

</div>

<div algorithm>
  The <dfn method for=HTMLControlledFrameElement>canGoBack()</dfn>
  method steps are:

  ISSUE: We can't actually synchronously access the embedded navigable's
  history state. In the future we should update this method to return a
  Promise.

  1. If [=this=]'s [=embedded navigable=] is null, then return false.

  1. If [=this=]'s [=embedded navigable=]'s [=current session history step=]
      is greater than 0, return true.

  1. Return false.

</div>

<div algorithm>
  The <dfn method for=HTMLControlledFrameElement>canGoForward()</dfn>
  method steps are:

  1. If [=this=]'s [=embedded navigable=] is null, then return false.

  1. Let |step| be [=this=]'s [=embedded navigable=]'s [=current session
      history step=].

  1. Let |steps| be the result of [=getting all used history steps=]
      given [=this=]'s [=embedded navigable=].

  1. If |step|+1 is less than the [=list/size=] of |steps|, then return true.

  1. Return false.

</div>

<div algorithm>
  The <dfn method for=HTMLControlledFrameElement>back()</dfn> method steps are:

  1. Return the result of [=traversing an embedded navigable's history=] given
      [=this=] and -1.

</div>

<div algorithm>
  The <dfn method for=HTMLControlledFrameElement>forward()</dfn> method steps
  are:

  1. Return the result of [=traversing an embedded navigable's history=] given
      [=this=] and 1.

</div>

<div algorithm>
  The <dfn method for=HTMLControlledFrameElement>go(|relativeIndex|)</dfn>
  method steps  are:

  1. Return the result of [=traversing an embedded navigable's history=] given
      [=this=] and |relativeIndex|.

</div>

<div algorithm>
  The <dfn method for=HTMLControlledFrameElement>reload()</dfn> steps are:

  1. If [=this=]'s [=embedded navigable=] is null, return.

  1. [=Reload=] [=this=]'s [=embedded navigable=] given a [=user navigation
      involvement=] of "[=browser UI=]".

</div>

<div algorithm>
  The <dfn method for=HTMLControlledFrameElement>stop()</dfn> steps are:

  1. If [=this=]'s [=embedded navigable=] is null, return.

  1. [=Stop loading=] [=this=]'s [=embedded navigable=].

</div>

<!-- ====================================================================== -->
## Scripting methods ## {#api-scripting}
<!-- ====================================================================== -->

<xmp class="idl">
// One of |code| or |file| must be specified but not both.
dictionary InjectDetails {
  DOMString code;
  DOMString file;
};

dictionary InjectionItems {
  DOMString code;
  sequence<DOMString> files;
};

enum RunAt {
  "document-start",
  "document-end",
  "document-idle",
};

dictionary ContentScriptDetails {
  required DOMString name;
  InjectionItems js;
  InjectionItems css;
  required sequence<DOMString> matches;
  sequence<DOMString> excludeMatches;
  boolean allFrames;
  boolean matchAboutBlank;
  RunAt runAt;
};
</xmp>

A <dfn>content script config</dfn> is a [=struct=] with the following
[=struct/items=]:

<dl export dfn-for="content script config">
  : <dfn>pendingFetchCount</dfn>
  :: a {{long}} representing the number of pending script/style fetches.

  : <dfn>js</dfn>
  :: a [=list=] of [=string=]s containing JavaScript that will be injected into
      a document.

  : <dfn>css</dfn>
  :: a [=list=] of [=string=]s containing CSS that will be injected into a
      document.

  : <dfn>matches</dfn>
  :: a [=list=] of [=string=]s containing patterns. Content will be injected
      into pages whose [=Document/URL=] matches one of these patterns.

  : <dfn>excludeMatches</dfn>
  :: a [=list=] of [=string=]s containing patterns. Content will *not* be
      injected into pages whose [=Document/URL=] matches one of these patterns.

  : <dfn>allFrames</dfn>
  :: a [=boolean=] indicating whether content should be injected into all
      frames in a page, or just the top-level frame.

  : <dfn>matchAboutBlank</dfn>
  :: a [=boolean=] indicating whether content should be injected into
      about:blank pages.

  : <dfn>runAt</dfn>
  :: a {{RunAt}} indicating when JavaScript content should be executed in a
      document's lifecycle.

</dl>

<div algorithm>
  To <dfn>fetch an injection item</dfn> given a <{controlledframe}>
  |controlledframe|, a {{DOMString}} |urlString|, a [=boolean=] |isCss|, a
  {{long}} |index|, and an algorithm |completionSteps|, run the following steps:

  1. If |urlString| is not an [=valid URL string=], then:

      1. Run |completionSteps| given 0 and false.

      1. Return.

  1. Let |request| be a new [=request=] with the following fields:
      : [=request/URL=]
      :: The result of running the [=URL parser=] given |urlString| and
          |controlledframe|'s [=node document=]'s [=document base URL=]
      : [=request/method=]
      :: "`GET`"
      : [=request/destination=]
      :: "`style`" if |isCss| is true, "`script`" otherwise
      : [=request/client=]
      :: |controlledframe|'s [=node document=]'s [=relevant settings object=]
      : [=request/mode=]
      :: "`cors`"

  1. [=Fetch=] |request|, with [=processResponseConsumeBody=] set to the
      following steps given a [=response=] |response| and a null, failure, or
      [=byte sequence=] |contents|:

      1. If |response|'s [=response/status=] is not 200, or |contents| is null
          or failure, then run |completionSteps| given 0 and false.

      1. Otherwise, run |completionSteps| given |index| and |contents|.

</div>

<div algorithm>
  To <dfn>validate and resolve {{ContentScriptDetails}}</dfn> given a
  <{controlledframe}> |controlledframe| and a {{ContentScriptDetails}}
  |details|, run the following steps:

  1. Let |result| be a new [=promise=].

  1. If |details|["{{ContentScriptDetails/js}}"] and
      |details|["{{ContentScriptDetails/css}}"] are both defined, or both
      undefined, then [=reject=] |result| with a {{TypeError}} and abort
      these steps.

  1. If |details|["{{ContentScriptDetails/matches}}"] is [=list/empty=], then
      [=reject=] |result| with a {{TypeError}} and abort these steps.

  1. Return |result| and run the remaining steps [=in parallel=].

  1. Let |config| be a new [=content script config=] with the following values:

      : [=content script config/pendingFetchCount=]
      :: 0
      : [=content script config/matches=]
      :: |details|["{{ContentScriptDetails/matches}}"]
      : [=content script config/excludeMatches=]
      :: |details|["{{ContentScriptDetails/excludeMatches}}"] if defined,
          otherwise an empty [=list=]
      : [=content script config/allFrames=]
      :: |details|["{{ContentScriptDetails/allFrames}}"] if defined, otherwise
          false
      : [=content script config/matchAboutBlank=]
      :: |details|["{{ContentScriptDetails/matchAboutBlank}}"] if defined,
          otherwise false
      : [=content script config/runAt=]
      :: |details|["{{ContentScriptDetails/runAt}}"] if defined, otherwise
          {{RunAt/document-idle}}

  1. Let |isCss| be a [=boolean=] equal to true if
      |details|["{{ContentScriptDetails/css}}"] is defined, false otherwise.

  1. Let |completionSteps| be the following algorithm, which takes a {{long}}
      |index| and a [=string=] or [=boolean=] |source|:

      1. If |source| is not a [=string=], then [=reject=] |result| with a
          {{TypeError}} and abort these steps.

      1. If |isCss|, then:

          1. Set |config|'s [=content script config/css=][|index|] to |source|.

      1. Otherwise:

          1. Set |config|'s [=content script config/js=][|index|] to |source|.

      1. Decrement |config|'s [=content script config/pendingFetchCount=].

      1. If |config|'s [=content script config/pendingFetchCount=] is greater
          than 0, then return.

      1. Set |controlledframe|'s [=controlledframe/content script map
          =][|details|[{{ContentScriptDetails/name}}]] to |config|.

      1. [=Resolve=] |result|.

  1. Let |injectionItems| be |details|["{{ContentScriptDetails/css}}"] if
      |isCss| is true, |details|["{{ContentScriptDetails/js}}"] otherwise.

  1. If |injectionItems|["{{InjectionItems/code}}"] and
      |injectionItems|["{{InjectionItems/files}}"] are both defined, or both
      undefined, [=reject=] |result| with a {{TypeError}} and abort these steps.

  1. If |injectionItems|["{{InjectionItems/code}}"] is defined, then:

      1. Run |completionSteps| given 0 and |injectionItems|
          ["{{InjectionItems/code}}"].

  1. Otherwise:

      1. If |injectionItems|["{{InjectionItems/files}}"] is [=list/empty=], then
          [=reject=] |result| with a {{TypeError}} and abort these steps.

      1. [=list/For each=] |urlString| of |injectionItems|
          ["{{InjectionItems/files}}"]:

          1. Run [=fetch an injection item=] given |controlledframe|,
              |urlString|, |isCss|, |config|'s
              [=content script config/pendingFetchCount=], and
              |completionSteps|.

          1. Increment |config|'s [=content script config/pendingFetchCount=].

</div>

<div algorithm>
  To determine if a <dfn>[=content script config=] applies to a document</dfn>
  given a [=content script config=] |config|, a [=/URL=] |url|, and a
  [=boolean=] |isTopLevel|, run the following steps:

  1. If |isTopLevel| is false, and |config|'s
      [=content script config/allFrames=] is false, then return false.

  1. If the result of <a lt="urlencoded serializer">serializing</a> |url| with
      [=URL serializer/exclude fragment=] equal to true is equal to
      "about:blank", and |config|'s [=content script config/matchAboutBlank=]
      is false, then return false.

  1. Let |urlString| be the result of <a lt="urlencoded serializer">
      serializing</a> |url|.

  1. Let |match| be false.

  1. [=list/For each=] |pattern| of |config|'s
      [=content script config/matches=]:

      1. If |urlString| [=matches a URL pattern=] |pattern|, then set
          |match| to true.

  1. [=list/For each=] |pattern| of |config|'s
      [=content script config/excludeMatches=]:

      1. If |urlString| [=matches a URL pattern=] |pattern|, then set
          |match| to false.

  1. Return |match|.

</div>

<div algorithm>
  To <dfn>inject content scripts into a document</dfn> given a {{Document}}
  |document|, and a {{RunAt}} |currentPhase|, run the following steps:

  1. Let |embeddedNavigable| be |document|'s [=node navigable=]'s
      [=traversable navigable=].

  1. If |embeddedNavigable| is null or its [=embedderParent=] is null, then
      return.

  1. Let |controlledframe| be |embeddedNavigable|'s [=embedderParent=].

  1. Let |url| be |document|'s [=Document/URL=].

  1. Let |isTopLevel| be true if |document|'s [=node navigable=]'s
      [=navigable/parent=] is null, false otherwise.

  1. [=list/For each=] |config| of |controlledframe|'s [=content script map=]:

      1. If the result of determining whether a [=content script config applies
          to a document=] given |config|, |url|, and |isTopLevel| equals false,
          then [=continue=].

      1. If |currentPhase| is equal to {{RunAt/document-start}} and |config|'s
          [=content script config/css=] is not [=list/empty=], then:

          1. [=list/For each=] |styleSource| of |config|'s
              [=content script config/css=]:

              1. Run [=inject a stylesheet into a document=] given |document|
                  and |styleSource|.

      1. Otherwise, if |currentPhase| equals |config|'s
          [=content script config/runAt=], then:

          1. [=list/For each=] |scriptSource| of |config|'s
              [=content script config/js=]:

              1. Run [=inject a script into a document=] given |document|
                  and |scriptSource|.

</div>

<div algorithm>
  To <dfn>inject a stylesheet into a document</dfn> given a {{Document}}
  |document| and a [=string=] |styleSource|, run the following steps:

  1. Let |styleSheet| be a new [=CSS style sheet=] object.

  1. [=Synchronously replace the rules of a CSSStyleSheet=] given |styleSheet|
      and |styleSource|.

  1. [=Add a CSS style sheet=] given |document| and |styleSheet|.

</div>

Advisement: The following algorithm executes script in a Document's
[=environment=], but that isn't the desired behavior. The goal, which cannot be
specced with the current HTML specification infrastructure, is for this
algorithm to execute script in an environment that is isolated from the
Document's environment with a different global object, but with shared access
to the DOM. This execution environment is called an
<a href="https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts#isolated_world">
Isolated World</a> in Blink, which uses it to execute
<a href="https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Content_scripts">
content scripts</a> in extensions. See this
<a href="https://drive.google.com/file/d/0B1obCOyvTnPKQmJEWkVtOEN2TmM/view?resourcekey=0-m_AA1o8fpD-1GKVgkKQQ4g">
diagram</a> for additional details about their execution model. Gecko uses
a similar approach called
<a href="https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Sharing_objects_with_page_scripts#xray_vision_in_firefox">
Xray vision</a>. This algorithm should eventually describe a speccable
implementation of this isolation that can be implemented by all browsers.

<div algorithm>
  To <dfn>inject a script into a document</dfn> given a {{Document}} |document|
  and a [=string=] |scriptSource|, run the following steps:

  1. Let |script| be the result of [=creating a classic script=] given
      |scriptSource|, |document|'s [=relevant settings object=], |document|'s
      [=Document/URL=], and the [=default script fetch options=].

  1. Return the result of [=running a classic script=] given |script|.

</div>

<div algorithm>
  The <dfn method for=HTMLControlledFrameElement>addContentScripts(|contentScriptList|)</dfn>
  method steps are:

  1. If |contentScriptList| is [=list/empty=], return a [=promise=] that is
      [=rejected=] with a {{TypeError}}.

  1. Let |promises| be an empty [=list=].

  1. [=list/For each=] |contentScript| in |contentScriptList|:

      1. Let |promise| be the result of calling [=validate and resolve
          ContentScriptDetails=] given |contentScript|.

      1. [=list/Append=] |promise| to |promises|.

  1. Return the result of calling {{Promise}}.{{Promise/all}} given |promises|.

</div>

<div algorithm>
  The <dfn method for=HTMLControlledFrameElement>removeContentScripts(|scriptNameList|)</dfn>
  method steps are:

  1. Let |result| be a new [=promise=].

  1. Return |result| and run the remaining steps [=in parallel=].

  1. If |scriptNameList| is undefined, then:

      1. [=map/Clear=] [=this=]'s [=content script map=].

  1. Otherwise, [=list/for each=] |name| of |scriptNameList|:

      1. [=map/Remove=] [=this=]'s [=content script map=][|name|].

  1. [=Resolve=] |result|.

</div>

<div algorithm>
  The <dfn method for=HTMLControlledFrameElement>executeScript(optional |details|)</dfn>
  method steps are:

  1. Let |result| be a new [=promise=].

  1. Return |result| and run the remaining steps [=in parallel=].

  1. If [=this=]'s [=embedded navigable=] is null, [=reject=] |result| with a
      {{TypeError}} and abort these steps.

  1. If |details|["{{InjectDetails/code}}"] and
      |details|"[{{InjectDetails/file}}"] are either both defined or both
      undefined, [=reject=] |result| with a {{TypeError}} and abort these steps.

  1. Let |executionSteps| be the following algorithm that takes a {{long}} and
      a [=string=] or [=boolean=] |scriptString|:

      1. If |scriptString| is not a [=string=], then [=reject=] |result| with a
          {{TypeError}} and abort these steps.

      1. Let |document| be [=this=]'s [=embedded navigable=]'s
          [=active document=].

      1. Let |status| be the result of [=injecting a script into a document=]
          given |document| and |scriptString|.

      1. If |status| is a [=normal completion=], then:

          1. [=Resolve=] |result| with |status|.`[[Value]]`.

      1. Otherwise:

          1. [=Reject=] |result| with |status|.`[[Value]]`.

  1. If |details|["{{InjectDetails/code}}"] is defined, then run
      |executionSteps| given 0 and |details|["{{InjectDetails/code}}"].

  1. Otherwise, [=fetch an injection item=] given [=this=],
      |details|["{{InjectDetails/file}}"], false, 0, and |executionSteps|.

</div>

<div algorithm>
  The <dfn method for=HTMLControlledFrameElement>insertCSS(optional |details|)</dfn>
  method steps are:

  1. Let |result| be a new [=promise=].

  1. Return |promise| and run the remaining steps [=in parallel=].

  1. If [=this=]'s [=embedded navigable=] is null, [=reject=] |promise| with a
      {{TypeError}} and abort these steps.

  1. If |details|["{{InjectDetails/code}}"] and
      |details|["{{InjectDetails/file}}"] are either both defined or both
      undefined, [=reject=] |result| with a {{TypeError}} and abort these steps.

  1. Let |executionSteps| be the following algorithm that takes a {{long}} and
      a [=string=] or [=boolean=] |styleString|:

      1. If |styleString| is not a [=string=], then [=reject=] |result| with a
          {{TypeError}} and abort these steps.

      1. Let |document| be [=this=]'s [=embedded navigable=]'s
          [=active document=].

      1. [=Inject a stylesheet into a document=] given |document| and
          |styleString|.

      1. [=Resolve=] |promise|.

  1. If |details|["{{InjectDetails/code}}"] is defined, then run |executionSteps|
      given 0 and |details|["{{InjectDetails/code}}"].

  1. Otherwise, [=fetch an injection item=] given [=this=],
      |details|["{{InjectDetails/file}}"], false, 0, and |executionSteps|.

</div>

<!-- ====================================================================== -->
## Configuration methods ## {#api-config}
<!-- ====================================================================== -->

<xmp class="idl">
dictionary ClearDataOptions {
  long since;
};

dictionary ClearDataTypeSet {
  boolean appcache;
  boolean cache;
  boolean cookies;
  boolean fileSystems;
  boolean indexedDB;
  boolean localStorage;
  boolean persistentCookies;
  boolean sessionCookies;
  boolean webSQL;
};
</xmp>

<div algorithm>
  The <dfn method for=HTMLControlledFrameElement>clearData(optional |options|, optional |types|)</dfn>
  method steps are:

  1. Let |resultPromise| be a new [=promise=].
  1. Return |resultPromise| and run the remaining steps [=in parallel=].
  1. Let |clearSince| be 0. This will represent to clear all items.
  1. If |options|["since"] is set:
      1. Let |clearSince| be |options|["since"].
  1. If |types|["appcache"] is set:
      1. Clear the partition's appcache items with a matching |clearSince|.
  1. If |types|["cache"] is set:
      1. Clear the partition's cache items with a matching |clearSince|.
  1. If |types|["cookies"] is set:
      1. Clear the partition's cookie items with a matching |clearSince|.
  1. If |types|["fileSystems"] is set:
      1. Clear the partition's fileSystem items with a matching |clearSince|.
  1. If |types|["indexedDB"] is set:
      1. Clear the partition's indexedDB items with a matching |clearSince|.
  1. If |types|["localStorage"] is set:
      1. Clear the partition's localStorage items with a matching |clearSince|.
  1. If |types|["persistentCookies"] is set:
      1. Clear the partition's persistentCookies items with a matching |clearSince|.
  1. If |types|["sessionCookies"] is set:
      1. Clear the partition's sessionCookies items with a matching |clearSince|.
  1. If |types|["webSQL"] is set:
      1. Clear the partition's webSQL items with a matching |clearSince|.
  1. Then, [=resolve=] |resultPromise|.

</div>

<div algorithm>
  The <dfn method for=HTMLControlledFrameElement>getAudioState()</dfn>
  method steps are:

  1. Let |resultPromise| be a new [=promise=].
  1. Return |resultPromise| and run the remaining steps [=in parallel=].
  1. If [=this=]'s [=embedded navigable=] is null, then [=reject=]
      |resultPromise| with a {{TypeError}} and abort these steps.
  1. Let |muteState| be the current audio mute state of embedded content.
  1. Then, [=resolve=] |resultPromise| with |muteState|.

</div>

<div algorithm>
  The <dfn method for=HTMLControlledFrameElement>getZoom()</dfn>
  method steps are:

  1. Let |resultPromise| be a new [=promise=].
  1. Return |resultPromise| and run the remaining steps [=in parallel=].
  1. If [=this=]'s [=embedded navigable=] is null, then [=reject=]
      |resultPromise| with a {{TypeError}} and abort these steps.
  1. Let |zoomFactor| be the current zoom setting for the embedded content.
  1. Then, [=resolve=] |resultPromise| with |zoomFactor|.

</div>

<div algorithm>
  The <dfn method for=HTMLControlledFrameElement>isAudioMuted()</dfn>
  method steps are:

  1. Let |resultPromise| be a new [=promise=].
  1. Return |resultPromise| and run the remaining steps [=in parallel=].
  1. If [=this=]'s [=embedded navigable=] is null, then [=reject=]
      |resultPromise| with a {{TypeError}} and abort these steps.
  1. Let |muteState| be the current audio mute state for embedded content.
  1. Then, [=resolve=] |resultPromise| with |muteState|.

</div>

<div algorithm>
  The <dfn method for=HTMLControlledFrameElement>setAudioMuted(|mute|)</dfn>
  method steps are:

  1. If [=this=]'s [=embedded navigable=] is null, then [=throw=] a
      {{TypeError}}.
  1. Change the audio mute state for embedded content to match |mute| state.

</div>

<div algorithm>
  The <dfn method for=HTMLControlledFrameElement>setZoom(|zoomFactor|)</dfn>
  method steps are:

  1. Let |resultPromise| be a new [=promise=].
  1. Return |resultPromise| and run the remaining steps [=in parallel=].
  1. If [=this=]'s [=embedded navigable=] is null, then [=reject=]
      |resultPromise| with a {{TypeError}} and abort these steps.
  1. Change  the zoom for the embedded content to be |zoomFactor|.
  1. Then, [=resolve=] |resultPromise|.

</div>

<!-- ====================================================================== -->
## Capture methods ## {#api-capture}
<!-- ====================================================================== -->

<xmp class="idl">
// One of |code| or |file| must be specified but not both.
dictionary ImageDetails {
  DOMString format;
  DOMString quality;
};
</xmp>

<div algorithm>
  The <dfn method for=HTMLControlledFrameElement>captureVisibleRegion(optional |options|)</dfn>
  method steps are:

  1. Let |resultPromise| be a new [=promise=].
  1. Return |resultPromise| and run the remaining steps [=in parallel=].
  1. If [=this=]'s [=embedded navigable=] is null, then [=reject=]
      |resultPromise| with a {{TypeError}} and abort these steps.
  1. Let |optionsFormat| be "JPEG" by default.
  1. Let |optionsQuality| be 100 by default.
  1. If |options| has field "format":
      1. Let |optionsFormat| be |options|["format"].
  1. If |optionsFormat| is an unrecognized format,
     [=reject=] |resultPromise| with
      a {{TypeError}} and abort these steps.
  1. If |options| has field "quality":
      1. Let |optionsQuality| be |options|["quality"].
  1. If |optionsQuality| is not an integer and is not between 0 and 100
     inclusive,
     [=reject=] |resultPromise| with
      a {{TypeError}} and abort these steps.
  1. Create an image in format `optionsFormat` at quality `optionsQuality`
     showing the visible region of
     embedded content.
  1. Then, [=resolve=] |resultPromise| containing the image data.

</div>

<div algorithm>
  The <dfn method for=HTMLControlledFrameElement>print()</dfn>
  method steps are:

  1. If [=this=]'s [=embedded navigable=] is null, then [=throw=] a
      {{TypeError}}.
  1. Initiate the browser print page feature for embedded content.

</div>

<!-- ====================================================================== -->
## Events ## {#events}
<!-- ====================================================================== -->

{{HTMLControlledFrameElement}} implements {{EventTarget}} and supports the following [=event handlers=] (and their corresponding [=event handler event types=]).

<table>
  <tr>
    <th>[=Event handlers=]</th>
    <th>[=Event handler event types=]</th>
  </tr>
  <tr>
    <td>{{onconsolemessage}}</td>
    <td>consolemessage</td>
  </tr>
  <tr>
    <td>{{oncontentload}}</td>
    <td>contentload</td>
  </tr>
  <tr>
    <td>{{ondialog}}</td>
    <td>dialog</td>
  </tr>
  <tr>
    <td>{{onloadabort}}</td>
    <td>loadabort</td>
  </tr>
  <tr>
    <td>{{onloadcommit}}</td>
    <td>loadcommit</td>
  </tr>
  <tr>
    <td>{{onloadstart}}</td>
    <td>loadstart</td>
  </tr>
  <tr>
    <td>{{onloadstop}}</td>
    <td>loadstop</td>
  </tr>
  <tr>
    <td>{{onnewwindow}}</td>
    <td>newwindow</td>
  </tr>
  <tr>
    <td>{{onpermissionrequest}}</td>
    <td>permissionrequest</td>
  </tr>
  <tr>
    <td>{{onsizechanged}}</td>
    <td>sizechanged</td>
  </tr>
  <tr>
    <td>{{onzoomchange}}</td>
    <td>zoomchange</td>
  </tr>
</table>

The interactive events:

- {{onconsolemessage}}

- {{ondialog}}

- {{onnewwindow}}

- {{onpermissionrequest}}

The UI-change events:

- {{onsizechanged}}

- {{onzoomchange}}

The navigation events:

- {{oncontentload}}

- {{onloadabort}}

- {{onloadcommit}}

- {{onloadstart}}

- {{onloadstop}}

<!-- ====================================================================== -->
### consolemessage ### {#event-consolemessage}
<!-- ====================================================================== -->

<xmp class="idl">

[Exposed=Window, IsolatedContext]
interface ConsoleMessage {
  readonly attribute long level;
  readonly attribute DOMString message;
};

[Exposed=Window, IsolatedContext]
interface ConsoleMessageEvent : Event {
  constructor(DOMString type, optional ConsoleMessageEventInit eventInitDict = {});
  readonly attribute ConsoleMessage consoleMessage;
};

dictionary ConsoleMessageEventInit: EventInit {
  ConsoleMessage? consoleMessage;
};

</xmp>

<div algorithm=dispatch-consolemessage>

To fire a {{ConsoleMessageEvent}} |e| given <{controlledframe}> element |target| and the [=Printer=](|logLevel|, |args|[, options]) method arguments.

1. Let |consoleMessage| be a new ConsoleMessage object.

1. Set the following fields of |consoleMessage|:

      : {{ConsoleMessage/level}}
      :: |logLevel|.

      : {{ConsoleMessage/message}}
      :: The result of [=implementation-defined=] formatting to |args|.

1. Set |e|'s {{ConsoleMessageEvent/consoleMessage}} to |consoleMessage|.

1. Dispatch |e| at |target|.

<span class=XXX>TODO: monkey patch console [=Printer=].</span>

</div>

<!-- ====================================================================== -->
### dialog ### {#event-dialog}
<!-- ====================================================================== -->

<xmp class="idl">

[Exposed=Window, IsolatedContext]
interface DialogController {
  undefined okay(optional DOMString response);
  undefined cancel();
};

[Exposed=Window, IsolatedContext]
interface DialogMessage {
  readonly attribute DOMString messageType;
  readonly attribute DOMString messageText;
  readonly attribute DialogController dialogController;
};

[Exposed=Window, IsolatedContext]
interface DialogEvent : Event {
  constructor(DOMString type, optional DialogEventInit eventInitDict = {});
  readonly attribute DialogMessage dialogMessage;
};

dictionary DialogEventInit: EventInit {
  DialogMessage? dialogMessage;
};

</xmp>

<div algorithm=dispatch-dialog>

To fire a {{DialogEvent}} |e| given <{controlledframe}> element |target|, [=simple-dialogs=] type |dialogType|, and message |message|.

1. Let |dialogMessage| be a new DialogMessage object.

1. Set the following fields of |dialogMessage|:

      : {{DialogMessage/messageType}}
      :: |dialogType|, one of "alert", "confirm", or "prompt".

      : {{DialogMessage/messageText}}
      :: |message|.

1. Set |e|'s {{DialogEvent/dialogMessage}} to |dialogMessage|.

1. Dispatch |e| at |target|.

<span class=XXX>TODO: monkey patch [=simple-dialogs=].</span>

</div>

<!-- ====================================================================== -->
### newwindow ### {#event-newwindow}
<!-- ====================================================================== -->

<xmp class="idl">

[Exposed=Window, IsolatedContext]
interface NewWindowController {
  undefined attach(HTMLControlledFrameElement controlledFrame);
  undefined discard();
};

[Exposed=Window, IsolatedContext]
interface NewWindow {
  readonly attribute NewWindowController window;
  readonly attribute USVString targetUrl;
  readonly attribute DOMString initialWidth;
  readonly attribute DOMString initialHeight;
  readonly attribute DOMString name;
  readonly attribute DOMString windowOpenDisposition;
};

[Exposed=Window, IsolatedContext]
interface NewWindowEvent : Event {
  constructor(DOMString type, optional NewWindowEventInit eventInitDict = {});
  readonly attribute NewWindow newWindow;
};

dictionary NewWindowEventInit: EventInit {
  NewWindow? newWindow;
};

</xmp>

<div algorithm=dispatch-newwindow>

<span class=XXX>TODO:.</span>

</div>

<!-- ====================================================================== -->
### permissionrequest ### {#event-permissionrequest}
<!-- ====================================================================== -->

<xmp class="idl">

[Exposed=Window, IsolatedContext]
interface PermissionRequestControllerBase {
  undefined allow();
  undefined cancel();
};

[Exposed=Window, IsolatedContext]
interface PermissionRequest {
  readonly attribute DOMString permission;
  readonly attribute PermissionRequestControllerBase request;
};

[Exposed=Window, IsolatedContext]
interface PermissionRequestEvent : Event {
  constructor(DOMString type, optional PermissionRequestEventInit eventInitDict = {});
  readonly attribute PermissionRequest permissionRequest;
};

dictionary PermissionRequestEventInit: EventInit {
  PermissionRequest? permissionRequest;
};

</xmp>

<div algorithm=dispatch-permissionrequest>

<span class=XXX>TODO: Different child interfaces of PermissionRequestControllerBase for different permissions</span>

</div>

<!-- ====================================================================== -->
### sizechanged ### {#event-sizechanged}
<!-- ====================================================================== -->

<xmp class="idl">

[Exposed=Window, IsolatedContext]
interface SizeChange {
  readonly attribute long oldWidth;
  readonly attribute long oldHeight;
  readonly attribute long newWidth;
  readonly attribute long newHeight;
};

[Exposed=Window, IsolatedContext]
interface SizeChangedEvent : Event {
  constructor(DOMString type, optional SizeChangedEventInit eventInitDict = {});
  readonly attribute SizeChange sizeChange;
};

dictionary SizeChangedEventInit: EventInit {
  SizeChange? sizeChange;
};

</xmp>

<div algorithm=dispatch-sizechanged>

<span class=XXX>TODO:</span>

</div>

<!-- ====================================================================== -->
### zoomchange ### {#event-zoomchange}
<!-- ====================================================================== -->

<xmp class="idl">

[Exposed=Window, IsolatedContext]
interface ZoomChange {
  readonly attribute float oldZoomFactor;
  readonly attribute float newZoomFactor;
};

[Exposed=Window, IsolatedContext]
interface ZoomChangeEvent : Event {
  constructor(DOMString type, optional ZoomChangeEventInit eventInitDict = {});
  readonly attribute ZoomChange zoomChange;
};

dictionary ZoomChangeEventInit: EventInit {
  ZoomChange? zoomChange;
};

</xmp>

<div algorithm=dispatch-zoomchange>

<span class=XXX>TODO:</span>

</div>

<!-- ====================================================================== -->
### contentload ### {#event-contentload}
<!-- ====================================================================== -->

<xmp class="idl">

[Exposed=Window, IsolatedContext]
interface ContentLoadEvent : Event {
  constructor(DOMString type, optional ContentLoadEventInit eventInitDict = {});
};

dictionary ContentLoadEventInit: EventInit {
};

</xmp>

<div algorithm=dispatch-contentload>

<span class=XXX>TODO:</span>

</div>

<!-- ====================================================================== -->
### loadabort ### {#event-loadabort}
<!-- ====================================================================== -->

<xmp class="idl">

[Exposed=Window, IsolatedContext]
interface LoadInfo {
  readonly attribute USVString url;
  readonly attribute boolean isTopLevel;
};

[Exposed=Window, IsolatedContext]
interface LoadAbortInfo : LoadInfo{
  readonly attribute long code;
  readonly attribute DOMString reason;
};

[Exposed=Window, IsolatedContext]
interface LoadAbortEvent : Event {
  constructor(DOMString type, optional LoadAbortEventInit eventInitDict = {});
  readonly attribute LoadAbortInfo loadAbortInfo;
};

dictionary LoadAbortEventInit: EventInit {
  LoadAbortInfo? loadAbortInfo;
};

</xmp>

<div algorithm=dispatch-loadabort>

<span class=XXX>TODO:</span>

</div>

<!-- ====================================================================== -->
### loadcommit ### {#event-loadcommit}
<!-- ====================================================================== -->

<xmp class="idl">

[Exposed=Window, IsolatedContext]
interface LoadCommitEvent : Event {
  constructor(DOMString type, optional LoadCommitEventInit eventInitDict = {});
  readonly attribute LoadInfo loadInfo;
};

dictionary LoadCommitEventInit: EventInit {
  LoadInfo? loadInfo;
};

</xmp>

<div algorithm=dispatch-loadcommit>

<span class=XXX>TODO:</span>

</div>

<!-- ====================================================================== -->
### loadstart ### {#event-loadstart}
<!-- ====================================================================== -->

<xmp class="idl">

[Exposed=Window, IsolatedContext]
interface LoadStartEvent : Event {
  constructor(DOMString type, optional LoadStartEventInit eventInitDict = {});
  readonly attribute LoadInfo loadInfo;
};

dictionary LoadStartEventInit: EventInit {
  LoadInfo? loadInfo;
};

</xmp>

<div algorithm=dispatch-loadstart>

<span class=XXX>TODO:</span>

</div>

<!-- ====================================================================== -->
### loadstop ### {#event-loadstop}
<!-- ====================================================================== -->

<xmp class="idl">

[Exposed=Window, IsolatedContext]
interface LoadStopEvent : Event {
  constructor(DOMString type, optional LoadStopEventInit eventInitDict = {});
};

dictionary LoadStopEventInit: EventInit {
};

</xmp>

<div algorithm=dispatch-loadstop>

<span class=XXX>TODO:</span>

</div>


<!-- ====================================================================== -->
## Integration with other specifications ## {#api-integration-with-other-specifications}
<!-- ====================================================================== -->

This specification will make some modifications to specifications to accommodate
the needs of Controlled Frame.

<!-- ====================================================================== -->
### Monkey Patches ### {#api-monkey-patches}
<!-- ====================================================================== -->

#### [[HTML]] #### {#api-monkey-patches-html}

Each [=/navigable=] has:
 * A <dfn for=navigable>frameId</dfn> integer, initially 0.
 * A <dfn for=navigable>next frameId</dfn> integer, initially 1.
 * An <dfn for=navigable>embedderParent</dfn>, an {{HTMLControlledFrameElement}}
    or null.

The [=initialize the navigable=] algorithm given a [=/navigable=] |navigable|
and an optional [=/navigable=]-or-null |parent| (default null) is
monkey patched as follows:

 5. Set |navigable|'s [=navigable/parent=] to |parent|.

 6. <ins>If |parent| is not null (|navigable| is not a
    [=top-level traversable=]), then:</ins>

    1. <ins>Let |topLevelTraversable| be the [=top-level traversable=] that
        |navigable| is a descendant of.</ins>

    1. <ins>Set |navigable|'s [=navigable/frameId=] to |topLevelTraversable|'s
        [=navigable/next frameId=].</ins>

    1. <ins>Increment |topLevelTraversable|'s [=navigable/next frameId=].</ins>

<span class=XXX>TODO: Monkeypatch in calls to the [=inject content scripts into
a document=] algorithm.</span>

#### [[FETCH]] #### {#api-monkey-patches-fetch}

The [=determine the network partition key=] algorithm is monkey extended to
require double-keying on network requests originating from a Controlled Frame's
[=embedded navigable=].

<div algorithm="determine the network partition key controlled frame">
To determine the network partition key, given an [=environment=] |environment|:

  4. Let |topLevelSite| be the result of [=obtaining a site=], given
      topLevelOrigin.

  5. Let |secondKey| be null or an [=implementation-defined=] value.

  6. <ins>Let |embedderParent| be the result of [=getting an environment's
      embedderParent=] given |environment|.</ins>

  7. <ins>If |embedderParent| is not null, then set |secondKey| to
      |embedderParent|'s {{HTMLControlledFrameElement/partition}}.</ins>

  8. Return (|topLevelSite|, |secondKey|).

</div>

#### [[STORAGE]] #### {#api-monkey-patches-storage}

The [=obtain a storage key for non-storage purposes=] algorithm is extended to
require double-keying on all storage belonging to a <{controlledframe}>'s
[=embedded navigable=].

<div algorithm="obtain a storage key for non-storage purposes controlled frame">
To obtain a storage key for non-storage purposes, given an [=environment=]
|environment|, run these steps:

  1. Let |origin| be |environment|'s [=environment settings object/origin=] if
      |environment| is an [=environment settings object=]; otherwise
      |environment|'s [=creation URL=]'s [=/origin=].

  1. <ins>Let |embedderParent| be the result of [=getting an environment's
      embedderParent=] given |environment|.</ins>

  1. <ins>If |embedderParent| is not null, then return a [=tuple=] consisting
      of |embedderParent|'s {{HTMLControlledFrameElement/partition}} and
      |origin|.</ins>

  1. Return a [=tuple=] consisting of |origin|.

</div>

<div algorithm>
To <dfn>get an [=environment=]'s [=embedderParent=]</dfn> given an
[=environment=] |environment|, run the following steps:

  1. If |environment| is an [=environment settings object=] whose
      [=global object=] is a {{Window}} object, then:

      Issue: This algorithm doesn't work for Shared or Service Workers because
      [=embedderParent=] is only defined on a [=/navigable=], and it's not
      always possible to go from a non-{{Window}} [=environment=] to a
      [=/navigable=].

      1. Let |navigable| be |environment|'s [=global object=]'s
          [=Window/navigable=].

      1. Let |top| be the [=top-level traversable=] of |navigable|.

      1. If |top|'s [=embedderParent=] is not null, then return |top|'s
          [=embedderParent=].

  1. Return null.

</div>


<!-- ====================================================================== -->
# Web Request API # {#api-web-request}
<!-- ====================================================================== -->

Advisement: This API is based on the
<a href="https://developer.chrome.com/docs/extensions/reference/api/webRequest">
WebRequest API</a>, which is available through the &lt;webview&gt; element in
<a href="https://developer.chrome.com/docs/apps/overview">Chrome Apps</a>. It
is exposed to Controlled Frame with minimum modification to make efficient use
of prior art. As a result, this API does not fully adhere to Web Platform best
practices, particularly around naming conventions and event handling. If there
is future cross-browser interest in Controlled Frame, this API should be
revisited to align better with other Web APIs.


<xmp class="idl">
enum ResourceType {
  "main_frame",
  "sub_frame",
  "stylesheet",
  "script",
  "image",
  "font",
  "object",
  "xmlhttprequest",
  "ping",
  "csp_report",
  "media",
  "websocket",
  "webbundle",
  "other",
};

callback interface WebRequestEventListener {
  BlockingResponse? handleEvent(WebRequestEventDetails details);
};

dictionary RequestFilter {
  sequence<ResourceType> types;
  sequence<USVString> urls;
};

enum ExtraInfoSpec {
  "asyncBlocking",
  "blocking",
  "extraHeaders",
  "requestHeaders",
  "responseHeaders",
};

[Exposed=Window, IsolatedContext]
interface WebRequestEvent {
  undefined addListener(WebRequestEventListener listener,
                        optional RequestFilter filter = {},
                        optional sequence<ExtraInfoSpec> extraInfoSpec);
  boolean hasListener(WebRequestEventListener listener);
  boolean hasListeners();
  undefined removeListener(WebRequestEventListener listener);
};

dictionary WebRequestAuthCredentials {
  required DOMString username;
  required DOMString password;
};

dictionary BlockingResponse {
  WebRequestAuthCredentials authCredentials;
  boolean cancel;
  USVString redirectUrl;
  sequence<HttpHeader> requestHeaders;
  sequence<HttpHeader> responseHeaders;
};

enum DocumentLifecycle {
  "prerender",
  "active",
  "cached",
  "pending_deletion",
};

enum FrameType {
  "outermost_frame",
  "fenced_frame",
  "sub_frame",
};

dictionary WebRequestEventDetails {
  DOMString documentId;
  DocumentLifecycle documentLifecycle;
  required long frameId;
  FrameType frameType;
  USVString initiator;
  required DOMString method;
  DOMString parentDocumentId;
  required long parentFrameId;
  required DOMString requestId;
  required long timeStamp;
  required ResourceType type;
  required USVString url;
};

dictionary UploadData {
  ArrayBuffer bytes;
  DOMString file;
};
dictionary RequestBody {
  DOMString error;
  any formData;
  sequence<UploadData> raw;
};

dictionary WebRequestBeforeRequestDetails : WebRequestEventDetails {
  RequestBody requestBody;
};

dictionary HttpHeader {
  required DOMString name;
  DOMString value;
  sequence<byte> binaryValue;
};

dictionary WebRequestBeforeSendHeadersDetails : WebRequestEventDetails {
  sequence<HttpHeader> requestHeaders;
};

dictionary WebRequestSendHeadersDetails : WebRequestEventDetails {
  sequence<HttpHeader> requestHeaders;
};

dictionary WebRequestResponseEventDetails : WebRequestEventDetails {
  required long statusCode;
  required DOMString statusLine;
  sequence<HttpHeader> responseHeaders;
};

dictionary WebRequestHeadersReceivedDetails : WebRequestResponseEventDetails {};

dictionary AuthChallenger {
  DOMString host;
  long port;
};
dictionary WebRequestAuthRequiredDetails : WebRequestResponseEventDetails {
  required AuthChallenger challenger;
  required boolean isProxy;
  required DOMString scheme;
  DOMString realm;
};

dictionary WebRequestResponseWithIpEventDetails : WebRequestResponseEventDetails {
  required boolean fromCache;
  DOMString ip;
};

dictionary WebRequestBeforeRedirectDetails : WebRequestResponseWithIpEventDetails {
  required USVString redirectUrl;
};

dictionary WebRequestResponseStartedDetails : WebRequestResponseWithIpEventDetails {};

dictionary WebRequestCompletedDetails : WebRequestResponseWithIpEventDetails {};

dictionary WebRequestErrorOccurredDetails : WebRequestEventDetails {
  required DOMString error;
  required boolean fromCache;
  DOMString ip;
};

callback HandlerBehaviorChangedCallback = undefined ();

[Exposed=Window, IsolatedContext]
interface WebRequest {
  readonly attribute WebRequestEvent onBeforeRequest;
  readonly attribute WebRequestEvent onBeforeSendHeaders;
  readonly attribute WebRequestEvent onSendHeaders;
  readonly attribute WebRequestEvent onHeadersReceived;
  readonly attribute WebRequestEvent onAuthRequired;
  readonly attribute WebRequestEvent onBeforeRedirect;
  readonly attribute WebRequestEvent onResponseStarted;
  readonly attribute WebRequestEvent onCompleted;
  readonly attribute WebRequestEvent onErrorOccurred;

  undefined handlerBehaviorChanged(optional HandlerBehaviorChangedCallback callback);
};
</xmp>

Each {{WebRequest}} has a <dfn for=WebRequest>handler map</dfn>, which is a
[=map=] whose [=map/keys=] are [=strings=] and whose [=map/values=] are
[=lists=] of [=WebRequest handler configs=].

Each {{WebRequestEvent}} has:

 * An <dfn for=WebRequestEvent>eventName</dfn>, a [=string=].
 * A <dfn for=WebRequestEvent>webRequest</dfn>, a {{WebRequest}} instance that
    it is a member of.

<div algorithm>
  The <dfn method for=WebRequestEvent>addListener(|listener|, |filter|,
  |extraInfoSpec|)</dfn> method steps are:

  1. Call {{WebRequestEvent/removeListener}} with |listener|.

  1. Let |eventName| be [=this=]'s [=WebRequestEvent/eventName=].

  1. Let |handlerConfig| be a new [=WebRequest handler config=] with the
      following [=struct/items=]:

      : [=WebRequest handler config/handler=]
      :: |listener|

      : [=WebRequest handler config/filter=]
      :: |filter|

  1. Let |specSet| be a [=set=] containing the items in |extraInfoSpec|.

  1. If |eventName| equals "beforeRequest", then:

      1. If |specSet| is not a [=set/subset=] of the [=set=] « "blocking",
          "requestBody", "extraHeaders" », then [=throw=] a {{TypeError}}.

      1. If |specSet| [=set/contains=] "blocking", then set |handlerConfig|'s
          [=WebRequest handler config/blocking=] to true.

      1. If |specSet| [=set/contains=] "requestBody", then set |handlerConfig|'s
          [=WebRequest handler config/requestsBody=] to true.

      1. If |specSet| [=set/contains=] "extraHeaders", then set |handlerConfig|'s
          [=WebRequest handler config/requestsAllHeaders=] to true.

  1. Otherwise, if |eventName| equals "beforeSendHeaders", then:

      1. If |specSet| is not a [=set/subset=] of the [=set=] « "blocking",
          "requestHeaders", "extraHeaders" », then [=throw=] a {{TypeError}}.

      1. If |specSet| [=set/contains=] "blocking", then set |handlerConfig|'s
          [=WebRequest handler config/blocking=] to true.

      1. If |specSet| [=set/contains=] "requestHeaders", then set |handlerConfig|'s
          [=WebRequest handler config/requestsHeaders=] to true.

      1. If |specSet| [=set/contains=] "extraHeaders", then set |handlerConfig|'s
          [=WebRequest handler config/requestsAllHeaders=] to true.

  1. Otherwise, if |eventName| equals "sendHeaders", then:

      1. If |specSet| is not a [=set/subset=] of the [=set=] « "requestHeaders",
          "extraHeaders" », then [=throw=] a {{TypeError}}.

      1. If |specSet| [=set/contains=] "requestHeaders", then set |handlerConfig|'s
          [=WebRequest handler config/requestsHeaders=] to true.

      1. If |specSet| [=set/contains=] "extraHeaders", then set |handlerConfig|'s
          [=WebRequest handler config/requestsAllHeaders=] to true.

  1. Otherwise, if |eventName| equals "headersReceived", then:

      1. If |specSet| is not a [=set/subset=] of the [=set=] « "blocking",
          "responseHeaders", "extraHeaders" », then [=throw=] a {{TypeError}}.

      1. If |specSet| [=set/contains=] "blocking", then set |handlerConfig|'s
          [=WebRequest handler config/blocking=] to true.

      1. If |specSet| [=set/contains=] "responseHeaders", then set |handlerConfig|'s
          [=WebRequest handler config/requestsHeaders=] to true.

      1. If |specSet| [=set/contains=] "extraHeaders", then set |handlerConfig|'s
          [=WebRequest handler config/requestsAllHeaders=] to true.

  1. Otherwise, if |eventName| equals "authRequired", then:

      1. If |specSet| is not a [=set/subset=] of the [=set=] « "asyncBlocking",
          "blocking", "responseHeaders", "extraHeaders" », then [=throw=]
          a {{TypeError}}.

      1. If |specSet| [=set/contains=] "asyncBlocking", then set |handlerConfig|
          [=WebRequest handler config/asyncBlocking=] to true.

      1. If |specSet| [=set/contains=] "blocking", then set |handlerConfig|'s
          [=WebRequest handler config/blocking=] to true.

      1. If |specSet| [=set/contains=] "responseHeaders", then set |handlerConfig|'s
          [=WebRequest handler config/requestsHeaders=] to true.

      1. If |specSet| [=set/contains=] "extraHeaders", then set |handlerConfig|'s
          [=WebRequest handler config/requestsAllHeaders=] to true.

  1. Otherwise, if |eventName| equals "beforeRedirect", then:

      1. If |specSet| is not a [=set/subset=] of the [=set=] «
          "responseHeaders", "extraHeaders" », then [=throw=] a {{TypeError}}.

      1. If |specSet| [=set/contains=] "responseHeaders", then set |handlerConfig|'s
          [=WebRequest handler config/requestsHeaders=] to true.

      1. If |specSet| [=set/contains=] "extraHeaders", then set |handlerConfig|'s
          [=WebRequest handler config/requestsAllHeaders=] to true.

  1. Otherwise, if |eventName| equals "responseStarted", then:

      1. If |specSet| is not a [=set/subset=] of the [=set=] «
          "responseHeaders", "extraHeaders" », then [=throw=] a {{TypeError}}.

      1. If |specSet| [=set/contains=] "responseHeaders", then set |handlerConfig|'s
          [=WebRequest handler config/requestsHeaders=] to true.

      1. If |specSet| [=set/contains=] "extraHeaders", then set |handlerConfig|'s
          [=WebRequest handler config/requestsAllHeaders=] to true.

  1. Otherwise, if |eventName| equals "completed", then:

      1. If |specSet| is not a [=set/subset=] of the [=set=] «
          "responseHeaders", "extraHeaders" », then [=throw=] a {{TypeError}}.

      1. If |specSet| [=set/contains=] "responseHeaders", then set |handlerConfig|'s
          [=WebRequest handler config/requestsHeaders=] to true.

      1. If |specSet| [=set/contains=] "extraHeaders", then set |handlerConfig|'s
          [=WebRequest handler config/requestsAllHeaders=] to true.

  1. Otherwise, if |eventName| equals "errorOccurred", then:

      1. If |specSet| is not a [=set/subset=] of the [=set=] « "extraHeaders" »,
          then [=throw=] a {{TypeError}}.

      1. If |specSet| [=set/contains=] "extraHeaders", then set |handlerConfig|'s
          [=WebRequest handler config/requestsAllHeaders=] to true.

  1. Otherwise, [=throw=] a {{TypeError}}.

  1. Let |handlerMap| be the [=WebRequest/handler map=] of [=this=]'s
      [=WebRequestEvent/webRequest=].

  1. [=list/Append=] |handlerConfig| to |handlerMap|[|eventName|].

</div>

<div algorithm>
  The <dfn method for=WebRequestEvent>hasListener(|listener|)</dfn>
  method steps are:

  1. Let |handlerMap| be the [=WebRequest/handler map=] of [=this=]'s
      [=WebRequestEvent/webRequest=].

  1. Let |event name| be [=this=]'s [=WebRequestEvent/eventName=].

  1. For each |handlerConfig| in |handlerMap|[|event name|]:

      1. If |handlerConfig|'s [=WebRequest handler config/handler=] equals
          |listener|, return true.

  1. Return false.

</div>

<div algorithm>
  The <dfn method for=WebRequestEvent>hasListeners()</dfn> method steps are:

  1. Let |handlerMap| be the [=WebRequest/handler map=] of [=this=]'s
      [=WebRequestEvent/webRequest=].

  1. Let |event name| be [=this=]'s [=WebRequestEvent/eventName=].

  1. If |handlerMap|[|event name|] is
      [=list/empty=], return false, otherwise return true.

</div>

<div algorithm>
  The <dfn method for=WebRequestEvent>removeListener(|listener|)</dfn>
  method steps are:

  1. Let |handlerMap| be the [=WebRequest/handler map=] of [=this=]'s
      [=WebRequestEvent/webRequest=].

  1. Let |event name| be [=this=]'s [=WebRequestEvent/eventName=].

  1. Let |handlerConfigs| be |handlerMap|[|event name|].

  1. [=list/Remove=] all items from |handlerConfigs| whose
      [=WebRequest handler config/handler=] equals |listener|.

</div>

<div algorithm>
  The <dfn method for=WebRequest>handlerBehaviorChanged(|callback|)</dfn>
  method steps are:

  1. [=In parallel=], clear the HTTP cache associated with the partition
      used by [=environments=] embedded within [=this=]
      HTMLControlledFrameElement.

      Note: The behavior of event handlers registered through the WebRequest
      API will be reflected in the HTTP cache, which will no longer be valid if
      the behavior of the event handlers changed. The purpose of this method is
      to invalidate any cache entries that were affected by WebRequest event
      handlers.

  1. Invoke |callback| when the HTTP cache has been cleared.

</div>

<div algorithm>
  To <dfn>process beforeRequest events</dfn> given a [=request=] |request|,
  run the following steps:

  1. Let |handlers| be the result of calling [=lookup registered WebRequest
      handler configs=] given "beforeRequest", and |request|.

  1. For each |handler| in |handlers|:

      1. Let |details| be the result of calling [=create a
          WebRequestEventDetails object=] given |request|.

      1. If |request|'s [=request/body=] is not null, then:

          1. Let |requestBody| be a new {{RequestBody}}.

          1. Let |body| be |request|'s [=request/body=].

              <span class=XXX>TODO: serialize [=body/stream=] if present.</span>

          1. Switch on |body|'s [=body/source=]:

              : [=byte sequence=]
              :: [=list/Append=] a new {{UploadData}} with {{UploadData/bytes}}
                  equal to the serialized |body|'s [=body/source=] to
                  |requestBody|'s {{RequestBody/raw}}.

              : {{Blob}}
              :: [=list/Append=] a new {{UploadData}} with {{UploadData/bytes}}
                  equal to the serialized |body|'s [=body/source=] to
                  |requestBody|'s {{RequestBody/raw}}.

              : {{FormData}}
              ::  1. Let |formData| be a new {{/object}}.

                  1. [=list/For each=] |entry| in |body|'s [=body/source=]'s
                      [=FormData/entry list=]:

                      1. Switch on |entry|[1]:

                      : {{File}}
                      :: [=list/Append=] a new {{UploadData}} with
                          {{UploadData/file}} equal to |entry|[1]'s
                          {{File/name}} to |requestBody|'s
                          {{RequestBody/raw}}.

                      : {{USVString}}
                      ::  1. If |formData|[|entry|[0]] does not exist, then
                              set |formData|[|entry|[0]] equal to an empty
                              [=list=].

                          1. [=list/Append=] |entry|[1] to
                              |formData|[|entry|[0]].


                  1. Set |details|'s {{RequestBody/formData}} to |formData|.

          1. Set |details|'s {{WebRequestBeforeRequestDetails/requestBody}}
              to |requestBody|.

      1. If |handler|'s [=WebRequest handler config/blocking=] flag is true,
          then:

          1. Let |result| be the result of calling |handler|[[=WebRequest
              handler config/handler=]] given |details|.

          1. If any [=map/key=] in |result| is not [=list/contained=] in the set
              « "cancel", "redirect" », then [=throw=] a {{TypeError}}.

          1. Return |result|.

      1. Call |handler|[[=WebRequest handler config/handler=]] given |details|
          [=in parallel=].

      1. Return null.

</div>

<div algorithm>
  To <dfn>process beforeSendHeaders events</dfn> given a [=request=] |request|,
  run the following steps:

  1. Let |handlers| be the result of calling [=lookup registered WebRequest
      handler configs=] given "beforeSendHeaders", and |request|.

  1. For each |handler| in |handlers|:

      1. Let |details| be the result of calling [=create a
          WebRequestEventDetails object=] given |request|.

      1. If |handler|'s [=WebRequest handler config/requestsHeaders=] is true,
          then set |details|'s {{WebRequestBeforeSendHeadersDetails/requestHeaders}}
          to the result of calling [=convert a header list to an HttpHeader
          sequence=] given |request|'s [=request/header list=], |handler|'s
          [=WebRequest handler config/requestsAllHeaders=], and isRequest
          equal to true.

      1. If |handler|'s [=WebRequest handler config/blocking=] flag is true,
          then:

          1. Let |result| be the result of calling |handler|[[=WebRequest
              handler config/handler=]] given |details|.

          1. If any [=map/key=] in |result| is not [=list/contained=] in the set
              « "cancel", "requestHeaders" », then [=throw=] a {{TypeError}}.

          1. Return |result|.

      1. Call |handler|[[=WebRequest handler config/handler=]] given |details|
          [=in parallel=].

      1. Return null.

</div>

<div algorithm>
  To <dfn>process sendHeaders events</dfn> given a [=request=] |request|,
  run the following steps:

  1. Let |handlers| be the result of calling [=lookup registered WebRequest
      handler configs=] given "sendHeaders", and |request|.

  1. For each |handler| in |handlers|:

      1. Let |details| be the result of calling [=create a
          WebRequestEventDetails object=] given |request|.

      1. If |handler|'s [=WebRequest handler config/requestsHeaders=] is true,
          then set |details|'s {{WebRequestSendHeadersDetails/requestHeaders}}
          to the result of calling [=convert a header list to an HttpHeader
          sequence=] given |request|'s [=request/header list=], |handler|'s
          [=WebRequest handler config/requestsAllHeaders=], and isRequest
          equal to true.

      1. Call |handler|[[=WebRequest handler config/handler=]] given |details|
          [=in parallel=].

</div>

<div algorithm>
  To <dfn>process headersReceived events</dfn> given a [=request=] |request|
  and a [=response=] |response|, run the following steps:

  1. Let |handlers| be the result of calling [=lookup registered WebRequest
      handler configs=] given "headersReceived", and |request|.

  1. For each |handler| in |handlers|:

      1. Let |details| be the result of calling [=create a
          WebRequestResponseEventDetails object=] given |request| and
          |response|.

      1. If |handler|'s [=WebRequest handler config/requestsHeaders=] is true,
          then set |details|'s {{WebRequestResponseEventDetails/responseHeaders}}
          to the result of calling [=convert a header list to an HttpHeader
          sequence=] given |response|'s [=response/header list=], |handler|'s
          [=WebRequest handler config/requestsAllHeaders=], and isRequest
          equal to false.

      1. If |handler|'s [=WebRequest handler config/blocking=] flag is true,
          then:

          1. Let |result| be the result of calling |handler|[[=WebRequest
              handler config/handler=]] given |details|.

          1. If any [=map/key=] in |result| is not [=list/contained=] in the set
              « "cancel", "redirectUrl", "responseHeaders" », then [=throw=]
              a {{TypeError}}.

          1. Return |result|.

      1. Call |handler|[[=WebRequest handler config/handler=]] given |details|
          [=in parallel=].

      1. Return null.

</div>

<div algorithm>
  To <dfn>process authRequired events</dfn> given a [=request=] |request|
  and a [=response=] |response|, run the following steps:

  1. Let |handlers| be the result of calling [=lookup registered WebRequest
      handler configs=] given "authRequired", and |request|.

  1. Let |challenger| be an {{AuthChallenger}} with {{AuthChallenger/host}} and
      {{AuthChallenger/port}} equal to the [=url/host=] and [=url/port=] of
      |response|'s [=response/URL=].

  1. If |response|'s [=response/status=] is 401, then:

      1. Let |isProxy| be false.

      1. Let |scheme| be the scheme from |response|'s `WWW-Authenticate` header,
          parsed as defined by the [[HTML]] specification, or null if the header
          is missing or invalid.

      1. Let |realm| be the realm from |response|'s `WWW-Authenticate` header,
          parsed as defined by the [[HTML]] specification.

  1. Otherwise:

      1. Let |isProxy| be true.

      1. Let |scheme| be the scheme from |response|'s `Proxy-Authenticate`
          header, parsed as defined by the [[HTML]] specification, or null if
          the header is missing or invalid.

      1. Let |realm| be the realm from |response|'s `Proxy-Authenticate` header,
          parsed as defined by the [[HTML]] specification.

  1. If |scheme| is null, then return.

  1. For each |handler| in |handlers|:

      1. Let |details| be the result of calling [=create a
          WebRequestResponseEventDetails object=] given |request| and
          |response|.

      1. If |handler|'s [=WebRequest handler config/requestsHeaders=] is true,
          then set |details|'s {{WebRequestResponseEventDetails/responseHeaders}}
          to the result of calling [=convert a header list to an HttpHeader
          sequence=] given |response|'s [=response/header list=], |handler|'s
          [=WebRequest handler config/requestsAllHeaders=], and isRequest
          equal to false.

          1. Set |details| {{WebRequestAuthRequiredDetails/challenger}},
              {{WebRequestAuthRequiredDetails/isProxy}},
              {{WebRequestAuthRequiredDetails/scheme}}, and
              {{WebRequestAuthRequiredDetails/realm}} fields equal to
              |challenger|, |isProxy|, |scheme|, and |realm| respectively.

      1. If |handler|'s [=WebRequest handler config/blocking=] flag is true,
          then:

          1. Let |result| be the result of calling |handler|[[=WebRequest
              handler config/handler=]] given |details|.

          1. Return the result of calling [=process an authRequired response=]
              given |result|.

      1. Otherwise, if |handler|'s [=WebRequest handler config/asyncBlocking=]
          flat is true, then:

          1. Let |result| be null.

          1. Let |callback| be a [=function=] that takes a
              {{BlockingResponse}} |blockingResponse| argument and when
              executed calls [=process an authRequired response=] with
              |blockingResponse| and sets |result| equal to its return value.

          1. Let |result| be the result of calling |handler|[[=WebRequest
              handler config/handler=]] given |details| and |callback|.

          1. Pause these steps until |callback| has been invoked.

          1. Return |result|.

      1. Call |handler|[[=WebRequest handler config/handler=]] given |details|
          [=in parallel=].

      1. Return null.

</div>

<div algorithm>
  To <dfn>process an authRequired response</dfn> given a {{BlockingResponse}}
  |blockingResponse|, run the following steps:

  1. If any [=map/key=] in |blockingResponse| is not [=list/contained=] in the
      set « "cancel", "authCredentials" », or if |blockingResponse|
      ["{{BlockingResponse/authCredentials}}"] does not contain two [=map/keys=]
      equal to `"username"` and `"password"`, then [=throw=] a {{TypeError}}.

  1. Return |blockingResponse|.

</div>

<div algorithm>
  To <dfn>process beforeRedirect events</dfn> given a [=request=] |request|
  and a [=response=] |response|, run the following steps:

  1. Let |handlers| be the result of calling [=lookup registered WebRequest
      handler configs=] given "beforeRedirect", and |request|.

  1. For each |handler| in |handlers|:

      1. Let |details| be the result of calling [=create a
          WebRequestResponseWithIpEventDetails object=] given |request| and
          |response|.

      1. If |handler|'s [=WebRequest handler config/requestsHeaders=] is true,
          then set |details|'s {{WebRequestResponseEventDetails/responseHeaders}}
          to the result of calling [=convert a header list to an HttpHeader
          sequence=] given |response|'s [=response/header list=], |handler|'s
          [=WebRequest handler config/requestsAllHeaders=], and isRequest
          equal to false.

      1. Let |internalResponse| be |response|, if |response| is not a
          [=filtered response=]; otherwise |response|’s [=internal response=].

      1. Set |details|'s {{WebRequestBeforeRedirectDetails/redirectUrl}} to
          |internalResponse|'s [=location URL=] given |request|'s
          [=request/current URL=]'s [=url/fragment=].

      1. Call |handler|[[=WebRequest handler config/handler=]] given |details|
          [=in parallel=].

</div>

<div algorithm>
  To <dfn>process responseStarted events</dfn> given a [=request=] |request|
  and a [=response=] |response|, run the following steps:

  1. Let |handlers| be the result of calling [=lookup registered WebRequest
      handler configs=] given "responseStarted", and |request|.

  1. For each |handler| in |handlers|:

      1. Let |details| be the result of calling [=create a
          WebRequestResponseWithIpEventDetails object=] given |request| and
          |response|.

      1. If |handler|'s [=WebRequest handler config/requestsHeaders=] is true,
          then set |details|'s {{WebRequestResponseEventDetails/responseHeaders}}
          to the result of calling [=convert a header list to an HttpHeader
          sequence=] given |response|'s [=response/header list=], |handler|'s
          [=WebRequest handler config/requestsAllHeaders=], and isRequest
          equal to false.

      1. Call |handler|[[=WebRequest handler config/handler=]] given |details|
          [=in parallel=].

</div>

<div algorithm>
  To <dfn>process completed events</dfn> given a [=request=] |request|
  and a [=response=] |response|, run the following steps:

  1. Let |handlers| be the result of calling [=lookup registered WebRequest
      handler configs=] given "completed", and |request|.

  1. For each |handler| in |handlers|:

      1. Let |details| be the result of calling [=create a
          WebRequestResponseWithIpEventDetails object=] given |request| and
          |response|.

      1. If |handler|'s [=WebRequest handler config/requestsHeaders=] is true,
          then set |details|'s {{WebRequestResponseEventDetails/responseHeaders}}
          to the result of calling [=convert a header list to an HttpHeader
          sequence=] given |response|'s [=response/header list=], |handler|'s
          [=WebRequest handler config/requestsAllHeaders=], and isRequest
          equal to false.

      1. Call |handler|[[=WebRequest handler config/handler=]] given |details|
          [=in parallel=].

</div>

<div algorithm>
  To <dfn>process errorOccurred events</dfn> given a [=request=] |request|
  and a [=response=] |response|, run the following steps:

  1. Let |handlers| be the result of calling [=lookup registered WebRequest
      handler configs=] given "errorOccurred", and |request|.

  1. For each |handler| in |handlers|:

      1. Let |details| be the result of calling [=create a
          WebRequestResponseWithIpEventDetails object=] given |request| and
          |response|.

      1. If |handler|'s [=WebRequest handler config/requestsHeaders=] is true,
          then set |details|'s {{WebRequestResponseEventDetails/responseHeaders}}
          to the result of calling [=convert a header list to an HttpHeader
          sequence=] given |response|'s [=response/header list=], |handler|'s
          [=WebRequest handler config/requestsAllHeaders=], and isRequest
          equal to false.

      1. Set |handler|'s {{WebRequestErrorOccurredDetails/error}} field to an
          implementation-defined error message describing the error in
          |response|.

      1. Call |handler|[[=WebRequest handler config/handler=]] given |details|
          [=in parallel=].

</div>

<div algorithm>
  To <dfn>create a {{WebRequestEventDetails}} object</dfn> given a [=request=]
  |request|, run the following steps:

  1. Let |environmentSettingsObject| be |request|'s [=request/client=].

  1. Let |crossOriginIsolatedCapability| be |environmentSettingsObject|'s
      [=environment settings object/cross-origin isolated capability=], or
      false if |environmentSettingsObject| is null.

  1. Let |details| be a new {{WebRequestEventDetails}} with the following
      fields:
      : {{WebRequestEventDetails/timeStamp}}
      :: The [=coarsened shared current time=] given
          |crossOriginIsolatedCapability|.

      : {{WebRequestEventDetails/url}}
      :: The last element of |request|'s [=request/URL list=].

      : {{WebRequestEventDetails/method}}
      :: |request|'s [=request/method=].

      : {{WebRequestEventDetails/initiator}}
      :: The [=serialization of an origin=] given |request|'s [=request/origin=].

         Note: An opaque origin will result in {{WebRequestEventDetails/initiator}}
         being set to the [=string=] "null".

      : {{WebRequestEventDetails/type}}
      :: The result of calling [=get a request's ResourceType=] given |request|.

      : {{WebRequestEventDetails/requestId}}
      :: |request|'s [=request/requestId=].

      : {{WebRequestEventDetails/frameId}}
      :: -1

      : {{WebRequestEventDetails/parentFrameId}}
      :: -1

  1. If |environmentSettingsObject|'s [=environment settings object/global object=]
      is a {{Window}} object, then:

      1. Let |window| be |environmentSettingsObject|'s
          [=environment settings object/global object=].

      1. Update the following fields of |details|:

          : {{WebRequestEventDetails/documentId}}
          :: |environmentSettingsObject|'s [=environment/id=].

          : {{WebRequestEventDetails/documentLifecycle}}
          :: <span class=XXX>It's unclear if {{DocumentLifecycle}} values map
              to existing concepts.</span>

          : {{WebRequestEventDetails/frameId}}
          :: The [=navigable/frameId=] of |window|'s [=Window/navigable=].

          : {{WebRequestEventDetails/frameType}}
          :: {{FrameType/"fenced_frame"}} if |window|'s {{Window/fence}} is
              non-null, {{FrameType/"outermost_frame"}} if |window|'s
              {{Window/top}} equals |window|, {{FrameType/"sub_frame"}}
              otherwise.

          1. If |window|'s {{Window/parent}} is not equal to |window|, then
              update the following values of |details|:

              : {{WebRequestEventDetails/parentDocumentId}}
              :: The [=environment/id=] of |window|'s {{Window/parent}}'s
                  [=active document=]'s [=relevant global object=].

              : {{WebRequestEventDetails/parentFrameId}}
              :: The [=navigable/frameId=] of |window|'s {{Window/parent}}'s
                  [=Window/navigable=].

  1. Return |details|.

</div>

<div algorithm>
  To <dfn>create a {{WebRequestResponseEventDetails}} object</dfn> given a
  [=request=] |request|, a [=response=] |response|, a [=boolean=]
  |requestsHeaders|, and a [=boolean=] |requestsAllHeaders|,
  run the following steps:

  1. Let |details| be the result of [=creating a WebRequestEventDetails object=]
      given |request|.

  1. Update the following fields in |details|:

      : {{WebRequestResponseEventDetails/statusCode}}
      :: |response|'s [=response/status=].

      : {{WebRequestResponseEventDetails/statusLine}}
      :: |response|'s [=response/status message=].

  1. If |requestsHeaders| is true, then set |details|'s
      {{WebRequestResponseEventDetails/responseHeaders}} to the result of
      calling [=convert a header list to an HttpHeader sequence=] given
      |response|'s [=response/header list=], |requestsAllHeaders|, and isRequest
      equal to false.

  1. Return |details|.

</div>

<div algorithm>
  To <dfn>create a {{WebRequestResponseWithIpEventDetails}} object</dfn> given a
  [=request=] |request|, a [=response=] |response|,
  a [=boolean=] |requestsHeaders|, and a [=boolean=] |requestsAllHeaders|,
  run the following steps:

  1. Let |details| be the result of [=creating a
      WebRequestResponseEventDetails object=] given |request|, |response|,
      |requestsHeaders|, and |requestsAllHeaders|.

  1. If |response|'s [=response/cache state=] is "local", then set |details|'s
      {{WebRequestResponseWithIpEventDetails/fromCache}} to true.

  1. Set |details|'s {{WebRequestResponseWithIpEventDetails/ip}} to the
      [=ip address=] from which |response| was received if the request
      involved a network request.

      <span class=XXX>The [[FETCH]] spec currently doesn't specify storing
      the remote IP address used when sending |request|.</span>

  1. Return |details|.

</div>

<div algorithm>
  To <dfn>convert a [=header list=] to an {{HttpHeader}} sequence</dfn> given
  a [=header list=] |fetchHeaders|, a [=boolean=] |requestsAllHeaders|, and
  a [=boolean=] |isRequest|, run the following steps:

  1. Let |headers| be a an empty list of {{HttpHeader}} objects.

  1. For each |fetchHeader| in |fetchHeaders|:

      1. If each of the following conditions are true, then [=continue=]:

          * |isRequest| is true
          * |requestsAllHeaders| is false
          * |fetchHeader|[0] is not a [=CORS-safelisted request-header=]

      1. If each of the following conditions are true, then [=continue=]:

          * |isRequest| is false
          * |requestsAllHeaders| is false
          * |fetchHeader|[0] is not a [=CORS-safelisted response-header name=]

      1. Let |header| be a new {{HttpHeader}}.

      1. Set |header|["{{HttpHeader/name}}"] to the [=isomorphic decoding=] of
          |fetchHeader|[0].

      1. Let |value| be the [=isomorphic decoding=] of |fetchHeader|[1] .

      1. If |value| is a [=scalar value string=], then set |header|
          ["{{HttpHeader/value}}"] to |value|.

      1. Otherwise, set |header|["{{HttpHeader/binaryValue}}"] to
          |fetchHeader|[1].

      1. [=list/Append=] |header| to |headers|.

  1. Return |headers|.

</div>

<div algorithm>
  To <dfn>convert an {{HttpHeader}} sequence to a [=header list=]</dfn> given
  a {{HttpHeader}} |headers|, run the following steps:

  1. Let |headerList| be a an empty [=header list=].

  1. For each |header| in |headers|:

      1. If any of the following conditions are true, [=throw=] a {{TypeError}}:

          * |header|["name"] is not a [=string=].

          * |header|["value"] is not a [=string=] or |header|["binaryValue"] is
              not an [=list=] of {{Number}}s.

      1. Let |value| be |header|["value"] if it exists, or the [=isomorphic
          decoding=] of |header|["binaryValue"] otherwise.

      1. [=list/Append=] a new [=tuple=] with values « |header|["name"],
          |value| » to |headerList|.

  1. Return |headerList|.

</div>

<div algorithm>
  To <dfn>get a request's {{ResourceType}}</dfn> given a [=request=]
  |request|, run the following steps:

  1. Return |request|'s [=request/initiator type=].

      <p class=XXX>TODO: [=request/initiator type=] doesn't exactly map to
      {{ResourceType}}. Define this mapping.</p>

</div>

<div algorithm>
  To <dfn>create a redirect response</dfn> given a [=string=] |redirectUrl|,
  return a [=response=] with the following fields:

  : [=response/status=]
  :: 301

  : [=response/header list=]
  :: « ("Location", |redirectUrl|) »

</div>

## WebRequest handler config ## {#webrequest-handler-config-struct}

  A <dfn export>WebRequest handler config</dfn> is a [=struct=] with the
  following [=struct/items=]:

  <dl export dfn-for="WebRequest handler config">
    : <dfn>handler</dfn>
    :: a {{WebRequestEventListener}}

    : <dfn>filter</dfn>
    :: a {{RequestFilter}}

    : <dfn>requestsBody</dfn>
    :: a [=boolean=]

    : <dfn>requestsHeaders</dfn>
    :: a [=boolean=]

    : <dfn>requestsAllHeaders</dfn>
    :: a [=boolean=]

    : <dfn>blocking</dfn>
    :: a [=boolean=]

    : <dfn>asyncBlocking</dfn>
    :: a [=boolean=]
  </dl>

  <div algorithm>
    A [=string=] |url| <dfn>matches a URL pattern</dfn> [=string=] |url pattern|
    if the following steps return true:

    1. |url| |url pattern| <span class=XXX>TODO: Spec this, ideally referring to
        a not-yet-defined <a href="https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Match_patterns">
        Match pattern</a> spec.</span>
  </div>

  <div algorithm>
    To <dfn>lookup registered WebRequest handler configs</dfn> given a
    [=string=] |event name|, and a [=request=] |request|, run the
    following steps:

    1. Let |client| be |request|'s [=request/client=].

    1. If |client| is null, return an empty [=list=].

    1. If |client|'s corresponding [=global object=] is not a {{Window}},
        return an empty [=list=].

    1. Let |navigable| be the [=/navigable=] that |client|'s [=global object=]
        is within.

    1. If |navigable|'s [=embedderParent=] is null, return an empty [=list=].

    1. Let |controlledFrame| be the {{HTMLControlledFrameElement}}
        corresponding to |navigable|'s [=embedderParent=].

    1. Let |valid handlers| be an empty [=list=].

    1. Let |handlerMap| be |controlledFrame|'s
        {{HTMLControlledFrameElement/request}}'s [=WebRequest/handler map=].

    1. For each |handlerConfig| in |handlerMap|[|event name|]:

        1. Let |filter| be |handlerConfig|'s [=WebRequest handler config/filter=]

        1. Let |types| be |filter|[{{RequestFilter/types}}].

        1. If |types| is not [=list/empty=] and |types| does not
            [=list/contain=] the result of calling [=get a request's ResourceType=]
            given |request|, then [=iteration/continue=].

        1. Let |urls| be |filter|[{{RequestFilter/urls}}].

        1. Let |is valid url| be true if |urls| is [=list/empty=],
            false otherwise.

        1. For each |url pattern| in |urls|:

            1. If |request|'s [=request/URL=] [=matches a URL pattern=] given
                |url pattern|, set |is valid url| to true.

        1. [=list/Append=] |handlerConfig| to |valid handlers|.

    1. Return |valid handlers|.

  </div>

## Monkey Patches ## {#api-web-request-monkey}

### Fetch ### {#api-web-request-monkey-fetch}

A [=request=] has an associated <dfn for=request>requestId</dfn>, which is an
opaque string, randomly assigned at the request's creation.

The [=main fetch=] algorithm is monkey patched as follows:

  1. Let |request| be |fetchParams|'s request.

  2. Let |response| be null.

  3. <ins>Let |webRequestResult| be the result of calling [=process
      beforeRequest events=] given |request|.</ins>

  4. <ins>If |webRequestResult| is not null, then:</ins>

      1. <ins>If |webRequestResult|["{{BlockingResponse/cancel}}"] is true,
          then set |response| to a [=network error=].</ins>

      1. <ins>Otherwise, if |webRequestResult|
          ["{{BlockingResponse/redirectUrl}}"] is not an empty [=string=], then
          set |response| to the result of [=creating a redirect response=]
          given |webRequestResult|["{{BlockingResponse/redirectUrl}}"].</ins>


The [=fetch response handover=] algorithm is monkey patched as follows:

  1. <ins>If |response| is not a [=network error=], then call [=process
      responseStarted events=] given |fetchParams|'s [=fetch params/request=]
      and |response|.</ins>

  1. Let timingInfo be |fetchParams|’s timing info.

&vellip;

  9. If |fetchParams|’s process response consume body is non-null, then:

      &hellip;

  10. <ins>If |response| is not a [=network error=], then call [=process
      completed events=] given |fetchParams|'s [=fetch params/request=]
      and |response|.</ins>

  11. <ins>Otherwise, call [=process errorOccurred events=] given
      |fetchParams|'s [=fetch params/request=] and |response|.</ins>


The [=HTTP-network-or-cache fetch=] algorithm is monkey patched as follows:

  7. Let the revalidatingFlag be unset.

  8. <ins>Set |webRequestResult| to the result of calling [=process
      beforeSendHeaders events=] given |request|.</ins>

  9. <ins>If |webRequestResult| is not null, then:</ins>

      1. <ins>If |webRequestResult|["{{BlockingResponse/cancel}}"] is true,
          then set |response| to a [=network error=].</ins>

      1. <ins>Otherwise, if |webRequestResult|
          ["{{BlockingResponse/requestHeaders}}"] is a non-empty [=list=], then
          set |request|'s [=request/header list=] to the result of [=converting
          an HttpHeader sequence to a header list=] given |webRequestResult|
          ["{{BlockingResponse/requestHeaders}}"].</ins>

  10. <ins>If |response| is not null, </ins> run these steps, but abort when
      |fetchParams| is canceled:

      &vellip;

  11. If aborted, then return the appropriate network error for |fetchParams|.

  12. If |response| is null, then:

      1. If httpRequest's cache mode is "`only-if-cached`", then return a
          network error.

      2. <ins>Call [=process sendHeaders events=] given |request|.</ins>

      3. Let |forwardResponse| be the result of running [=HTTP-network fetch=]
          given httpFetchParams, includeCredentials, and isNewConnectionFetch.

      4. <ins>Let |webRequestResult| be the result of calling [=process
          headersReceived events=] given |request| and |forwardResponse| if
          |forwardResponse| is not a [=network error=], null otherwise.</ins>

      5. <ins>If |webRequestResult| is not null, then:</ins>

          1. <ins>If |webRequestResult|["{{BlockingResponse/cancel}}"] is true,
              then set |response| to a [=network error=].</ins>

          1. <ins>Otherwise, if |webRequestResult|
              ["{{BlockingResponse/redirectUrl}}"] is not an empty [=string=], then
              set |forwardResponse| to the result of [=creating a redirect response=]
              given |webRequestResult|["{{BlockingResponse/redirectUrl}}"].</ins>

          1. <ins>Otherwise, if |webRequestResult|
              ["{{BlockingResponse/responseHeaders}}"] is a non-empty [=list=], then
              set |forwardResponse|'s [=response/header list=] to the result of
              [=converting an HttpHeader sequence to a header list=] given
              |webRequestResult| ["{{BlockingResponse/responseHeaders}}"].</ins>

&vellip;

  16. If response’s status is 401, httpRequest’s response tainting is not
      "cors", includeCredentials is true, and request’s window is an
      environment settings object, then:

      &vellip;

      3. If request’s use-URL-credentials flag is unset or
          isAuthenticationFetch is true, then:

          1. If |fetchParams| is canceled, then return the appropriate network
              error for |fetchParams|.

          1. Let |username| and |password| be null.

          1. <ins>Let |webRequestResult| be the result of calling [=process
              authRequired events=] given |request| and |response|.</ins>

          1. <ins>If |webRequestResult| is not null, then:</ins>

              1. <ins>If |webRequestResult|["{{BlockingResponse/cancel}}"] is
                  true, then set |response| to a [=network error=].</ins>

              1. <ins>Otherwise, if |webRequestResult|["{{BlockingResponse/
                  authCredentials}}"] is an {{/object}}, then:

                  1. Set |username| to |webRequestResult|["{{BlockingResponse/
                      authCredentials}}"]["{{WebRequestAuthCredentials/
                      username}}"].

                  1. Set |password| to |webRequestResult|["{{BlockingResponse/
                      authCredentials}}"]["{{WebRequestAuthCredentials/
                      password}}"].

          1. <ins>If |username| and |password| are null, then set them to</ins>
              the result of prompting the end user for a username and password,
              respectively, in |request|'s [=request/window=].

  17. If response’s status is 407, then:

      4. <ins>Let |webRequestResult| be the result of calling [=process
          authRequired events=] given |request| and |response|.</ins>

      5. <ins>If |webRequestResult| is not null, then:</ins>

          1. <ins>If |webRequestResult|["{{BlockingResponse/cancel}}"] is
              true, then set |response| to a [=network error=].</ins>

          1. <ins>Otherwise, if |webRequestResult|["{{BlockingResponse/
              authCredentials}}"] is an {{/object}}, then:

              1. Store |webRequestResult|["{{BlockingResponse/
                  authCredentials}}"] as a [=proxy-authentication entry=].

      6. <ins>Otherwise,</ins> prompt the end user as appropriate ...


The [=HTTP-redirect fetch=] algorithm is monkey patched as follows:

  1. <ins>Call [=process beforeRedirect events=] given |request| and
      |response|.</ins>

  1. Let request be |fetchParams|’s request.

<!-- ====================================================================== -->
# Context Menus API # {#api-context-menus}
<!-- ====================================================================== -->

Advisement: This API is based on the
<a href="https://developer.chrome.com/docs/extensions/reference/api/contextMenus">
ContextMenus API</a>, which is available through the &lt;webview&gt; element in
<a href="https://developer.chrome.com/docs/apps/overview">Chrome Apps</a>. It
is exposed to Controlled Frame with minimum modification to make efficient use
of prior art. As a result, this API does not fully adhere to Web Platform best
practices, particularly around naming conventions and event handling. If there
is future cross-browser interest in Controlled Frame, this API should be
revisited to align better with other Web APIs.

<xmp class="idl">
enum ContextType {
    "all",
    "page",
    "frame",
    "selection",
    "link",
    "editable",
    "image",
    "video",
    "audio",
};

enum ItemType {
    "normal",
    "checkbox",
    "radio",
    "separator",
};

dictionary OnClickData {
    boolean checked;
    required boolean editable;
    long frameId;
    USVString frameUrl;
    USVString linkUrl;
    DOMString mediaType;
    required (DOMString or long) menuItemId;
    USVString pageUrl;
    (DOMString or long) parentMenuId;
    DOMString selectionText;
    USVString srcUrl;
    boolean wasChecked;
};

callback ContextMenusCallback = undefined (optional OnClickData info);

[Exposed=Window, IsolatedContext]
interface ContextMenusEvent {
    undefined addListener(ContextMenusCallback callback);
    undefined removeListener(ContextMenusCallback callback);
    boolean hasListener(ContextMenusCallback callback);
    boolean hasListeners();
    undefined dispatch(any data);
};

[Exposed=Window, IsolatedContext]
interface OnClickedEvent : ContextMenusEvent {};

[Exposed=Window, IsolatedContext]
interface OnShowEvent : ContextMenusEvent {};

dictionary ContextMenusProperties {
    boolean checked;
    sequence<ContextType> context;
    sequence<USVString> documentUrlPatterns;
    boolean enabled;
    (DOMString or long) parentId;
    sequence<USVString> targetUrlPatterns;
    DOMString title;
    ItemType type;
    ContextMenusCallback onclick;
};

dictionary ContextMenusCreateProperties : ContextMenusProperties {
    required DOMString id;
};

[Exposed=Window, IsolatedContext]
interface ContextMenus {
    attribute OnClickedEvent onClicked;
    attribute OnShowEvent onShow;

    Promise<undefined> create(ContextMenusCreateProperties properties);
    Promise<undefined> remove(DOMString id);
    Promise<undefined> removeAll();
    Promise<undefined> update(DOMString id, optional ContextMenusProperties properties = {});
};
</xmp>

Each <{controlledframe}> has a {{HTMLControlledFrameElement/contextMenus}} member, which is a {{ContextMenus}} that manages a <dfn for=ContextMenus> context menu [=map=] </dfn> whose [=map/keys=] are [=strings=] and whose [=map/values=] are {{ContextMenusProperties}}.

Note: Each [=map/entry=] of the [=context menu map=] represents a <dfn for=ContextMenus>context menu item</dfn>. These items can show up when the user opens the <dfn for=ContextMenus>context menu</dfn> on the embedded document.

<div algorithm>

  The <dfn method for=ContextMenus>create(|properties|)</dfn> method steps are:

  1. Let |p| be a new [=promise=].

  1. Run the following steps [=in parallel=]:

      1. Let |contextMenusMap| be [=this=]'s [=ContextMenus/context menu map=].

      1. Let |id| be the |properties|["{{OnClickData/menuItemId}}"].

      1. If |contextMenusMap|[|id|] [=map/exists=], [=reject=] |p| with a {{TypeError}} and abort these steps.

      1. [=map/Set=] |contextMenusMap|[|id|] to |properties|.

      1. [=Resolve=] |p| with undefined.

</div>

<div algorithm>

  The <dfn method for=ContextMenus>remove(|id|)</dfn> method steps are:

  1. Let |p| be a new [=promise=].

  1. Run the following steps [=in parallel=]:

      1. Let |contextMenusMap| be [=this=]'s [=ContextMenus/context menu map=].

      1. [=map/Remove=] |contextMenusMap|[|id|].

      1. [=Resolve=] |p| with undefined.

</div>

<div algorithm>

  The <dfn method for=ContextMenus>removeAll()</dfn> method steps are:

  1. Let |p| be a new [=promise=].

  1. Run the following steps [=in parallel=]:

    1. Let |contextMenusMap| be [=this=]'s [=ContextMenus/context menu map=].

    1. [=map/Clear=] |contextMenusMap|.

    1. [=Resolve=] |p| with undefined.

</div>

<div algorithm>

  The <dfn method for=ContextMenus>update(|id|, |properties|)</dfn> method steps are:

  1. Let |p| be a new [=promise=].

  1. Run the following steps [=in parallel=]:

      1. Let |contextMenusMap| be [=this=]'s [=ContextMenus/context menu map=].

      1. If |contextMenusMap|[|id|] does not [=map/exist=], [=reject=] |p| with a {{TypeError}} and abort these steps.

      1. [=map/Set=] |contextMenusMap|[|id|] to |properties|.

      1. [=Resolve=] |p| with undefined.

</div>

The [=map/values=] of the [=context menu map=], which are {{ContextMenusProperties}} objects, control the conditions under which the [=context menu items=] are displayed, as well as the features and behaviors of the items.

<div class='note'>

<em>This section is non-normative.</em>

    {{ContextMenusProperties}} has the following fields:

    : {{ContextMenusProperties/context}}
    :: A [=list=] of different {{ContextType}}, used to control the conditions under which the [=context menu item=] is displayed.

    : {{ContextMenusProperties/documentUrlPatterns}}
    :: A [=list=] of strings that are [=match patterns=], used to control the conditions under which the [=context menu item=] is displayed.

    : {{ContextMenusProperties/targetUrlPatterns}}
    :: A [=list=] of strings that are [=match patterns=], used to control the conditions under which the [=context menu item=] is displayed.

    : {{ContextMenusProperties/parentId}}
    :: The ID of the parent [=ContextMenus/context menu item=]. The [=ContextMenus/context menu item=] may appear under a sub-menu of the parent.

    : {{ContextMenusProperties/title}}
    :: The title of the menu item.

    : {{ContextMenusProperties/type}}
    :: The type of the menu item.

    : {{ContextMenusProperties/onclick}}
    :: A {{ContextMenusCallback}} that is invoked when the [=ContextMenus/context menu item=] is clicked.

    : {{ContextMenusProperties/checked}}
    :: Whether the [=ContextMenus/context menu item=] is initially checked, if the {{ContextMenusProperties/type}} is {{ItemType/checkbox}}.

    : {{ContextMenusProperties/enabled}}
    :: Whether the [=ContextMenus/context menu item=] is enabled.

</div>

<div algorithm='show-menu-item'>

  When a [=ContextMenus/context menu=] is opened at {{HTMLElement}} |element| inside the embedded document, to return a boolean value for whether the [=ContextMenus/context menu item=] associated with a {{ContextMenusProperties}} |properties| will be shown:

  1. Let |documentUrl| be the [=Document/URL=] of the [=/document=] that |element| belongs to.

  1. Let |targetUrl| be an empty string.

      1. If |element| is an instance of {{HTMLImageElement}}, then set |targetUrl| to the {{HTMLImageElement/src}} attribute of |element|.

      1. If |element| is an instance of {{HTMLVideoElement}}, then set |targetUrl| to the {{HTMLMediaElement/src}} attribute of |element|.

      1. If |element| is an instance of {{HTMLAudioElement}}, then set |targetUrl| to the {{HTMLMediaElement/src}} attribute of |element|.

      1. If |element| is an instance of {{HTMLAnchorElement}}, then set |targetUrl| to the [=href=] attribute of |element|.

  1. If |properties|["{{ContextMenusProperties/context}}"] is not [=list/empty=]:

      1. Let |result| be a boolean value that is initially false.

      1. For each |context| in |properties|["{{ContextMenusProperties/context}}"]:

          1. If |element| matches |context|, set |result| to true and break;

          <span class=XXX>There is no standardized specifications for matching a {{HTMLElement}} against a {{ContextType}}.</span>

      1. If |result| is false, return false.

  1. If |properties|["{{ContextMenusProperties/documentUrlPatterns}}"] is not [=list/empty=]:

      1. Let |result| be a boolean value that is initially false.

      1. For each |urlPattern| in |properties|["{{ContextMenusProperties/documentUrlPatterns}}"]:

          1. If |documentUrl| [=matches a URL pattern=], given |urlPattern|, set |result| to true and break;

      1. If |result| is false, return false.

  1. If |properties|["{{ContextMenusProperties/targetUrlPatterns}}"] is not [=list/empty=]:

      1. Let |result| be a boolean value that is initially false.

      1. For each |urlPattern| in |properties|["{{ContextMenusProperties/targetUrlPatterns}}"]:

          1. If |targetUrl| [=matches a URL pattern=], given |urlPattern|, set |result| to true and break;

      1. If |result| is false, return false.

  Note: Different user agents may implement additional conditions.

  1. Return true.

</div>

{{ContextMenusEvent}} represents a target to which an [= event =] can be [= dispatched =] when a context menu interaction has occured.

Each {{ContextMenusEvent}} has an <dfn for=ContextMenusEvent>event listener list</dfn> which is a [=list=] of <a data-link-type="callback" data-lt="ContextMenusCallback">ContextMenusCallbacks</a>. It is initially an empty list.

<div algorithm>

  The <dfn method for=ContextMenusEvent>addListener(|callback|)</dfn> method steps are:

  1. Let |callbackList| be the [=ContextMenusEvent/event listener list=] of the {{ContextMenusEvent}}.

  1. If |callbackList|[|callback|] [=list/exists=], return.

  1. [=list/Append=] |callback| to |callbackList|.

</div>

<div algorithm>

  The <dfn method for=ContextMenusEvent>removeListener(|callback|)</dfn> method steps are:

  1. Let |callbackList| be the [=ContextMenusEvent/event listener list=] of the {{ContextMenusEvent}}.

  1. If |callbackList|[|callback|] [=list/exists=], [=list/remove=] |callback| from |callbackList|.

</div>

<div algorithm>

  The <dfn method for=ContextMenusEvent>hasListener(|callback|)</dfn> method steps are:

  1. Let |callbackList| be the [=ContextMenusEvent/event listener list=] of the {{ContextMenusEvent}}.

  1. If |callbackList|[|callback|] [=list/exists=], return true.

  1. Otherwise, return false.

</div>

<div algorithm>

  The <dfn method for=ContextMenusEvent>hasListeners()</dfn> method steps are:

  1. Let |callbackList| be the [=ContextMenusEvent/event listener list=] of the {{ContextMenusEvent}}.

  1. If |callbackList| [=list/is empty=], return false.

  1. Otherwise, return true.

</div>

<div algorithm>

  The <dfn method for=ContextMenusEvent>dispatch(|data|)</dfn> method steps are:

  1. Let |callbackList| be the [=ContextMenusEvent/event listener list=] of the {{ContextMenusEvent}}.

  1. [=list/For each=] |callback| in |callbackList|:

      1. Invoke |callback| with |data|.

</div>

{{ContextMenus}} has the attribute {{ContextMenus/onShow}}, which is a {{ContextMenusEvent}} that is associated with [= contextmenu =] [= events =].

<div algorithm='onshow-event'>

To [= dispatched =] an {{ContextMenus/onShow}} [= event =]:

1. Invoke {{ContextMenus/onShow}}'s {{ContextMenusEvent/dispatch(data)}} with no argument.

</div>

{{ContextMenus}} has the attribute {{ContextMenus/onClicked}}, which is a {{ContextMenusEvent}} that is associated with [= click =] [= events =] on a [=context menu item=].

<div algorithm='onclicked-event'>

To [=dispatch=] an {{ContextMenus/onClicked}} [=event=], given |element| as the {{HTMLElement}} inside the embedded document where the [=ContextMenus/context menu=] is opened at, |id| as the [=map/key=] of the [=ContextMenus/context menu map=]'s [=map/entry=] that is associated with the [=context menu item=].

1. Let |info| be a new {{OnClickData}}.

    1. Update the following fields of |info|:

        : {{OnClickData/editable}}
        :: Whether |element| is editable. <span class=XXX>what is "editable"?</span>

        : {{OnClickData/frameId}}
        :: The [=navigable/frameId=] of the [= navigable container =] from which the [= contextmenu =] [= event =] is dispatched.

        : {{OnClickData/frameUrl}}
        :: The [=Document/URL=] of the [= navigable container =] from which the [= contextmenu =] [= event =] is dispatched.

        : {{OnClickData/menuItemId}}
        :: |id|.

        : {{OnClickData/pageUrl}}
        :: The [=Document/URL=] of the [=embedded navigable=].

    1. Update the following optional fields of |info|:

        Note: Different user agents may set these fields differently.

        : {{OnClickData/checked}}
        :: Whether the [=context menu item=] is checked.

        : {{OnClickData/linkUrl}}
        :: If |element| is an instance of {{HTMLAnchorElement}}, |element|'s [=href=] [=attribute=].

        : {{OnClickData/mediaType}}
        :: One of "image", "video", or "audio", if any, based on |element|.

        : {{OnClickData/parentMenuId}}
        :: The ID of the parent, if a parent exists.

        : {{OnClickData/selectionText}}
        :: The text for the context selection, if any.

        : {{OnClickData/srcUrl}}
        :: The "src" attribute of |element|, if it exists.

        : {{OnClickData/wasChecked}}
        :: The state of a checkbox or radio item before it was clicked.

1. Invoke {{ContextMenus/onShow}}'s {{ContextMenusEvent/dispatch(data)}} with |info|.

1. Let |properties| be the result of [=map/getting=] the [=map/value=] of the [=map/entry=] in [=ContextMenus/context menu map=] given the [=map/key=] |id|.

1. If the {{ContextMenusProperties/onclick}} field of |properties| is not null, invoke {{ContextMenusProperties/onclick}} with |info|.

</div>

<!-- ====================================================================== -->
# Usage Overview # {#usage-overview}
<!-- ====================================================================== -->

Lorem ipsum. Insert basic info and example here.

<!-- ====================================================================== -->
# Motivating Applications # {#motivating-applications}
<!-- ====================================================================== -->

*This section is non-normative.*

<!-- ====================================================================== -->
## Latency-sensitive applications in virtualized sessions ## {#browser-content-redirection}
<!-- ====================================================================== -->

In virtualized environments, users typically have a local thin client that
renders a full virtual desktop. The actual desktop execution environment will be
running on a remote virtualization server. If the user's browser navigates to a
latency-sensitive application (such as a video app), the rendered content will
have additional latency ("lag") that makes the experience difficult or
impossible for the user. This also applies for applications that record the
user, such as video conferencing applications. In these latency-sensitive
applications, the virtual desktop application can render the latency-sensitive
content locally and overlay it on top of the rendered remote content to reduce
this latency. This use case is also known as "browser content redirection."

<!-- ====================================================================== -->
## Embedding third party web content without restriction ## {#no-embedding-prohibitions}
<!-- ====================================================================== -->

In a kiosk environment, applications must load content from third parties and
display that content on screens within their applications. A teacher may trigger
the navigation event, or it may be configured by an administrator such as a
shopping mall manager. The content may prohibit embedding by <{iframe}> through
the use of X-Frame-Options and CSP. An controlled frame, however, should be able
to load all content, even content that prohibits embedding by <{iframe}>.

<!-- ====================================================================== -->
## Remote display and manipulation of web content ## {#remote-content-control}
<!-- ====================================================================== -->

In a kiosk environment, applications must ensure that content continues to
display on screens and may need to interrupt content with their own supplied
behaviors. This behavior should work without local attendance by an
administrator, and ideally can be managed remotely over the network. If content
were to crash, for example, these applications should observe and respond to the
crash by reloading the content in a fresh embedded view.

<!-- ====================================================================== -->
## Clearing user content after each session ## {#clearing-session-data}
<!-- ====================================================================== -->

In some environments, someone only uses a single device for a brief time to
complete their task, like ordering in a restaurant. When their task is complete,
the embedder application should be able to clear all of the local user data
associated with the task and then restart the embedded instance.

<!-- ====================================================================== -->
## Monitor for idle sessions ## {#monitor-idle-sessions}
<!-- ====================================================================== -->

While users interact with embedded content, the user may not explicitly end
their session. This content may assume the user is present when they have
actually finished or departed without completing the task. Embedder applications
want to detect when users idle over their case's threshold and begin a fresh
session.

<!-- ====================================================================== -->
## Arbitrarily blocking navigations ## {#blocking-navigations}
<!-- ====================================================================== -->

While displaying embedded web content that's not authored by the embedder, pages
may link to third party web content that's disallowed. Allowing the embedder to
edit elements in embedded content through arbitrary script injection into the
web content can ensure navigation cannot occur to blocked pages. The embedder
can also use the Controlled Frame API to capture navigation events and ensure
that only pages to approved sites can be loaded within that controlled frame.

<!-- ====================================================================== -->
# Security, Privacy, and Accessibility Considerations # {#considerations}
<!-- ====================================================================== -->

*This section is non-normative.*

<!-- ====================================================================== -->
## Security ## {#security}
<!-- ====================================================================== -->

<b>Controlled Frame is based upon [[Isolated-Web-Apps]] (IWA)
and integrates with core security specs</b>

Since Controlled Frame is a particularly powerful API, using it or even having
it available makes an app a target of various types of hacking. As a result,
this API is limited to use in [[Isolated-Web-Apps|IWA]] which have additional
safeguards in place to protect application developers and users. The Isolated
Web App explainer has this to say:

> <i>"A user agent may also force an application to adopt this threat model if
the developer needs access to APIs which would make the application an appealing
target for XSS or server-side attacks."</i>

Controlled Frame makes just such an appealing target, and to expose this with
caution we're opting into [[Isolated-Web-Apps|IWA]] to guard against certain
attacks. Generally, [[Isolated-Web-Apps|IWAs]] provide strong security
assurances that each of the resources in an application are secure both at rest
and in-transit. You can read more about [[Isolated-Web-Apps|IWAs]] security and
permissions in the [[Isolated-Web-Apps|IWA]] explainer and the
[[Isolated-Web-Apps|IWAs]] [[High-Watermark-Permissions]] explainer.

Controlled Frame integrates with [[!Permissions-Policy]] and [[!Permissions]].
You can read more about [[Permissions-Policy#privacy]] and
[[Permissions#security-considerations]] (note the entry is currently sparse).

<b>Attacking web sites could display content that doesn't otherwise allow itself
to be embedded and trick users on non-[[Isolated-Web-Apps|IWAs]].</b>

Planned mitigation:

-  Controlled Frame will only be available within [[Isolated-Web-Apps|IWAs]]

<b>An [[Isolated-Web-Apps|IWA]] may embed another [[Isolated-Web-Apps|IWA]] (or
itself) via Controlled Frame to manipulate our [[Isolated-Web-Apps|IWA]]
policies somehow (e.g. an Controlled Frame embedded [[Isolated-Web-Apps|IWA]]
may detect it's being embedded due to the absence of the "controlled-frame"
policy-controlled feature).</b>

Planned mitigation:

-  Controlled Frame can only point to "https" schemes, excluding the
    "isolated-app" scheme used for [[Isolated-Web-Apps|IWAs]]

<b>Controlled Frame could gain access to the powerful &lt;controlledframe&gt;
element.</b>

An [[Isolated-Web-Apps|IWA]] that's not expected to use Controlled Frame may
attempt to embed content.

Planned mitigation:

-  [[Isolated-Web-Apps|IWA]] APIs can never be delegated to cross-origin, so it
    will not be possible for any nested top-level navigable to access an
    [[Isolated-Web-Apps|IWA]].
-  Secondly, only embedder applications and their same-origin
    [[Isolated-Web-Apps|IWA]] child navigables that have been granted the
    "controlled-frame" policy-controlled feature will have the Controlled Frame
    element available.
-  Same-origin child navigables without the "controlled-frame"
    policy-controlled feature will not be provided a Controlled Frame element.
    Their inner same-origin nested navigables will always not have it available.

<b>An IWA may attempt to embed content from non-https schemes, such as 'http:'
or 'isolated-app:'</b>

Planned mitigation:

-  Controlled Frame will only work when the navigable's "src" [=request/URL=]
    has an 'https:' scheme.

<b>Malicious Controlled Frame could access the embedder's running process (eg.
Spectre attack)</b>

Planned mitigation:

-  Controlled Frame will be executed in a separate process from the
    embedder's process

<b>Controlled Frame for a given "https origin" could interact or interfere with
the user's own storage data for that https origin</b>

Planned mitigation:

-  We're adding a Partition concept. Every Partition is a tuple of
    StorageKey and a separate object key.
-  Let there be a default partition with key=0 that stores
    "non-[[Isolated-Web-Apps|IWA]]" window
    and tab usage.
-  Controlled Frame will always store data in a certain StorageKey which is
    apart from the default partition.
-  Data written to by a given "https origin" while the user accesses that
    origin via an [[Isolated-Web-Apps|IWA]] Controlled Frame will be isolated
    from the default partition.
-  All usage will be separated between [[Isolated-Web-Apps|IWA]] and each
    partition will be fully isolated from each other and from default
    usage outside of [[Isolated-Web-Apps|IWA]].

<b>Malicious Controlled Frame could overwrite embedder's stored data</b>

-  The embedder and embedded storage user agent could overlap, and possibly
    multiple same-site [[Isolated-Web-Apps|IWA]] child navigables could be
    affected by activity in the Controlled Frame
-  if storage user agents were shared between the embedder and embedded
    sites, clearing data for either one could negatively impact the other

Planned mitigation:

-  [[Isolated-Web-Apps|IWA]] and Controlled Frame will always have separate
    storage user agents
-  A Controlled Frame should not have read or write access to other storage
    user agents besides its own

<b>Malicious Controlled Frame may detect it is embedded and attempt to attack
the embedder application</b>

Planned mitigation:

-  The user agent will match the browser.
-  The Controlled Frame storage user agent will be separate from the
    [[Isolated-Web-Apps|IWA]] and the default storage user agents.
-  The Controlled Frame process will be separate from the
    [[Isolated-Web-Apps|IWA]] and the default renderer and browser processes.
-  The Controlled Frame environment will appear to be the top-most navigable:
    -  window should match window.parent and window.top
    -  List of policy-controlled features and their disable/enable status
        should match the default for a navigable

Ideas:

-  Investigate for potential interactions around filesystem, quota storage,
    and localStorage APIs

<b>User may not be able to verify the origin of the page being viewed in the
Controlled Frame</b>

Ideas:

-  Expose the origin to the user somehow, such as adding UI at the top of a
    Controlled Frame that displays the origin?
-  Have the [[Isolated-Web-Apps|IWA]] specify in the manifest the origins that
    they expect to access?

<b>Controlled Frame may exploit vulnerabilities in out-of-date browser
engine</b>

Already addressed with:

-  Existing browser engine auto-update mechanisms

<!-- ====================================================================== -->
## Privacy ## {#privacy}
<!-- ====================================================================== -->

Controlled Frame integrates with Permissions Policy and Permissions. You can
read more about [[Permissions-Policy#privacy]].  You can read more about
[[Permissions#security-considerations]].

For Controlled Frame specifically, we've identified the following privacy
considerations:

-  Users' browsing within Controlled Frame will be visible to the
    [[Isolated-Web-Apps|IWA]]
-  [[Isolated-Web-Apps|IWAs]] can access and exfiltrate the Controlled Frame's
    session cookies (this only applies to the Controlled Frame's session since
    they use a separate storage partition from the [[Isolated-Web-Apps|IWA]] and
    the third party origin when browsed in a tab)
-  User activity in Controlled Frame can be observed by the
    [[Isolated-Web-Apps|IWA]] (e.g. keyboard events can be monitored, password
    entry can be sniffed)
-  User file upload to Controlled Frame can be hijacked
-  User data held in the Controlled Frame's remote server could be accessed by
    code implanted by the [[Isolated-Web-Apps|IWA]]
-  Users that wish to clear their session history must also do so via the
    [[Isolated-Web-Apps|IWA]], which will then need to clear the associated
    storage user agents
    -  This would be necessary since embedded storage user agents are separate
        from the non-embedded storage user agents for any given https origin
-  We plan to investigate browser UX to allow users to clear the Controlled
    Frame storage user agents, the following cases will be considered:
    -  If a user wants to clear site data for an [[Isolated-Web-Apps|IWA]], the
        associated embedded storage user agents will also be cleared
        -  This is because if the [[Isolated-Web-Apps|IWA]]'s data is cleared,
            the app will no longer have any context for the associated embedded
            storage user agents and therefore will no longer be used or useful
            to the user or organization
        -  As a result, we expect that clearing an [[Isolated-Web-Apps|IWA]]'s
            site data will require clearing all of the associated embedded
            storage user agents
    -  A user may want to clear all site data for a given "https origin", even
        if that origin is stored within an [[Isolated-Web-Apps|IWA]]'s embedded
        storage user agent
        -  We may choose to provide the ability to clear all
            [[Isolated-Web-Apps|IWA]] site data for that "https origin" even if
            that site data is held within an embedded storage user agent
        -  If we chose to clear the "https origin" data,
            [[Isolated-Web-Apps|IWAs]] would need to prepare for the possibility
            that embedded storage user agents may be removed outside of their
            control, and this may be disruptive to the [[Isolated-Web-Apps|IWA]]
            and introduce complexity of implementation
        -  Supporting this in the browser user agent exposes browser vendors,
            developers, and users to additional complexity, so we may choose not
            to support this approach and instead leave this up to
            [[Isolated-Web-Apps|IWA]] developers to implement
        -  As a counter example to supporting clearing a single given "https
            origin"'s embedded storage user agent, consider that to our
            knowledge no operating system behaves that way
            -  i.e. there's no central "clear browsing data" option which clears
                storage for all installed browser engines, each application's
                storage is treated as its own to manage
    -  User wants to clear the site data for a given [[Isolated-Web-Apps|IWA]]'s
        Controlled Frame-embedded storage user agent for a given "https origin"
    -  User wants to clear the site data for a given [[Isolated-Web-Apps|IWA]]'s
        Controlled Frame-embedded storage user agents for all "https origins"
-  An [[Isolated-Web-Apps|IWA]] will need the ability to clear the storage user
    agent's Controlled Frame-embedded storage user agent for a given "https
    origin"

<!-- ====================================================================== -->
## Accessibility ## {#accessibility}
<!-- ====================================================================== -->

For Controlled Frame, we've identified the following accessibility
considerations:

-  Browser user agents' accessibility tools and APIs should have visibility into
    Controlled Frame
-  [[Isolated-Web-Apps|IWAs]] should expect to provide their own accessibility
    tools for Controlled Frame content in order to properly integrate
    accessibility features for some use cases (such as "browser content
    redirection")

# Acknowledgements # {#acknowledgements}

The following people contributed to the development of this document.

* <a href="https://github.com/odejesush">Ovidio Ruiz-Henríquez</a>
