<pre class="metadata">
Title: Controlled Frame API
Abstract: This document defines an API for embedding arbitrary web content only
    within the context of an Isolated Web Application (IWA). The embedded
    content is a new top-level browsing context within and controlled by the
    embedder.
Repository: WICG/controlled-frame
URL: https://wicg.github.io/controlled-frame/
Status: w3c/CG-DRAFT
Shortname: controlled-frame
Level: 1
Editor: Chase Phillips 115880, Google LLC https://google.com, cmp@chromium.org
Editor: Robbie McElrath 139758, Google LLC https://google.com, rmcelrath@chromium.org
Editor: Zelin Liu 164998, Google LLC https://google.com, zelin@chromium.org

Group: WICG
Markup Shorthands: markdown yes
</pre>

<style>
.domintro::before {
    content: 'For web developers (non-normative)';
    text-transform: initial;
}
.domintro dt {
    font-family: Menlo, Consolas, "DejaVu Sans Mono", Monaco, monospace;

    padding-top: 0.5em;
    padding-bottom: 1em;
}
.domintro dt a {
    color: inherit; border-bottom-style: none;
}
.domintro dt code {
    font-size: inherit;
}

/* Put nice boxes around each algorithm. */
[data-algorithm]:not(.heading) {
  padding: .5em;
  border: thin solid #ddd; border-radius: .5em;
  margin: .5em calc(-0.5em - 1px);
}
[data-algorithm]:not(.heading) > :first-child {
  margin-top: 0;
}
[data-algorithm]:not(.heading) > :last-child {
  margin-bottom: 0;
}
[data-algorithm] [data-algorithm] {
  margin: 1em 0;
}

table {
  border-collapse: collapse;
  width: 100%;
}

th, td {
  border: 1px solid black;
  padding: 2px 8px;
  text-align: center;
  vertical-align: middle;
}

/* .XXX from https://resources.whatwg.org/standard.css */
.XXX {
  color: #D50606;
  background: white;
  border: solid #D50606;
}
</style>

<pre class="biblio">
{
  "HTTP-CACHING": {
    "aliasOf": "RFC9111"
  },
  "isolated-web-apps": {
    "authors": [
      "Reilly Grant"
    ],
    "href": "https://github.com/WICG/isolated-web-apps/blob/main/README.md",
    "title": "Isolated Web Apps Explainer"
  },
  "high-watermark-permissions": {
    "authors": [
        "Robbie McElrath"
    ],
    "href": "https://github.com/WICG/isolated-web-apps/blob/main/Permissions.md",
    "title": "Isolated Web Apps High Watermark Permissions Explainer"
  }
}
</pre>

<pre class="anchors">

spec: console; urlPrefix: https://console.spec.whatwg.org/
    type: dfn
        urlPrefix: /
            text: logger; for: /; url: logger
            text: formatter; for: /; url: formatter

spec: dom; urlPrefix: https://dom.spec.whatwg.org/
    type: dfn
        urlPrefix: /
            text: origin; for: document; url: concept-document-origin

spec: html; urlPrefix: https://html.spec.whatwg.org/multipage/
    type: dfn
        urlPrefix: /
            text: simple-dialogs; for: /; url: simple-dialogs
            text: window open steps; for: /; url: window-open-steps
        urlPrefix: browsing-the-web.html
            text: append the following session history traversal steps; url: tn-append-session-history-traversal-steps
            text: apply the traverse history step; url: apply-the-traverse-history-step
            text: document state; url: she-document-state
            text: get all used history steps; url: getting-all-used-history-steps
            text: reload; url: reload
            text: navigable; for:navigation params; url: navigation-params-navigable
            for: session history entry
                text: step; url: she-step
                text: URL; url: she-url
        urlPrefix: document-lifecycle.html
            text: completely finish loading; url: completely-finish-loading
            text: completely loaded; url: completely-loaded
            text: page showing; url: page-showing
            text: salvageable; url: concept-document-salvageable
            text: stop loading; url: nav-stop
            text: unload counter; url: unload-counter
        urlPrefix: document-sequences.html
            text: browsing context group; url: browsing-context-group
            text: browsing context group set; url: browsing-context-group-set
            text: create a new browsing context and document; url: creating-a-new-browsing-context
            text: creating a new auxiliary browsing context; url: creating-a-new-auxiliary-browsing-context
            text: current session history entry; url: nav-current-history-entry
            text: close a top-level traversable; url: close-a-top-level-traversable
            text: destroy a top-level traversable; url: destroy-a-top-level-traversable
            text: is popup; url: is-popup
            text: navigable; for: /; url: navigable
            text: active WindowProxy; for: navigable; url: nav-wp
            text: initialize the navigable; url: initialize-the-navigable
            for: navigable
                text: active session history entry; url: nav-active-history-entry
            for: traversable navigable
                text: session history entries; url: tn-session-history-entries
        urlPrefix: dom.html
            text: contexts in which this element can be used; url: concept-element-contexts
            text: content model; url: concept-element-content-model
            text: event; url: events
            text: nothing; url: concept-content-nothing
            text: content attributes; url: concept-element-attributes
            text: global attributes; url: global-attributes
            text: dom interface; url: concept-element-dom
            text: represents; url: represents
            text: accessibility considerations; url: concept-element-accessibility-considerations
            text: update the current document readiness; url: update-the-current-document-readiness
        urlPrefix: embedded-content.html
            text: src; url: attr-source-src
        urlPrefix: embedded-content-other.html
            text: width; url: attr-dim-width
            text: height; url: attr-dim-height
        urlPrefix: indices.html
            text: load; url: event-load
        urlPrefix: links.html
            text: href; url: attr-hyperlink-href
        urlPrefix: nav-history-apis.html
            text: browsing context; for: window; url: window-bc
            text: navigable; for: window; url: window-navigable
        urlPrefix: system-state.html
            text: associated Navigator; url: associated-navigator
        urlPrefix: timers-and-user-prompts.html
            text: alert; url:dom-alert
            text: confirm; url:dom-confirm
            text: prompt; url:dom-prompt
        urlPrefix: urls-and-fetching.html
            text: matches about:blank; url:matches-about:blank
        urlPrefix: webappapis.html
            text: create a classic script; url: creating-a-classic-script
            text: default script fetch options; url: default-script-fetch-options
            text: environment; url: environment
            text: navigation and traversal task source; url: navigation-and-traversal-task-source

spec: fetch; urlPrefix: https://fetch.spec.whatwg.org/
    type: dfn
        urlPrefix: /
            text: HTTP-network fetch; url: concept-http-network-fetch
            text: HTTP-network-or-cache fetch; url: concept-http-network-or-cache-fetch
            text: append; for: Headers; url: concept-headers-append
            text: fetch response handover; url: fetch-finale
            text: main fetch; url: main-fetch
            text: request; for: fetch params; url: fetch-params-request
            text: window; for: request; url: concept-request-window

spec: infra; urlPrefix: https://infra.spec.whatwg.org
    type: dfn
        text: empty; for: map; url: map-is-empty

spec: storage; urlPrefix: https://storage.spec.whatwg.org
    type: dfn
        text: map; for: storage bottle; url: storage-bottle-map
        text: proxy map reference set; for: storage bottle; url: storage-bottle-proxy-map-reference-set
        text: storage bottle; url: storage-bottle
        text: storage bucket; url: storage-bucket
        text: storage identifier; url: storage-identifier
        text: storage shed; url: storage-shed
        text: storage shelf; url: storage-shelf

spec: url; urlPrefix: https://url.spec.whatwg.org/
    type: dfn
        urlPrefix: /
            text: serialize an URL; url: concept-url-serializer

spec: webidl; urlPrefix: https://webidl.spec.whatwg.org
    type: dfn
        text: Web IDL Standard; url: introduction
        text: async iterator; url: idl-async-iterable
        text: promise; url: idl-promise
        text: promise rejected; url: a-promise-rejected-with
        text: promise resolved; url: a-promise-resolved-with
        text: getting a promise for waiting for all promises; url: waiting-for-all-promise

spec: uievents; urlPrefix: https://www.w3.org/TR/uievents/
    type: dfn
        text: contextmenu; url: event-type-contextmenu
        text: click; url: event-type-click

spec: geolocation; urlPrefix: https://www.w3.org/TR/geolocation/
    type: dfn
        text: request a position; url: dfn-request-a-position

spec: nav-speculation; urlPrefix: https://wicg.github.io/nav-speculation/
    type: dfn
        urlPrefix: prerendering.html
            text: prerendering navigable; url: prerendering-navigable
</pre>

<pre class=link-defaults>
spec:fetch; type:dfn; for:/; text:header list
spec:fetch; type:dfn; for:/; text:request
spec:fetch; type:dfn; for:/; text:response
spec:html; type:dfn; for:/; text:browsing context
spec:html; type:dfn; for:/; text:global object
spec:html; type:dfn; for:/; text:top-level traversable
spec:html; type:dfn; for:/; text:traversable navigable
spec:html; type:dfn; for:environment settings object; text:cross-origin isolated capability
spec:html; type:element; text:audio
spec:html; type:event; text:readystatechange
spec:infra; type:dfn; for:/; text:set
spec:infra; type:dfn; text:list
spec:infra; type:dfn; text:byte sequence
spec:infra; type:dfn; text:user agent
spec:webidl; type:dfn; text:attribute
spec:webidl; type:interface; text:long
</pre>

<!-- ====================================================================== -->
# Introduction # {#introduction}
<!-- ====================================================================== -->

This specification describes a content embedding API that satisfies some
critical use cases for IWAs that <{iframe}> does not support. This embedding
environment should allow embedding all content without express permission from
the embedded site, including content which <{iframe}> cannot embed, and provide
embedding sites more control over that embedded content.

Since this is a particularly powerful API, its use and availability makes an app
a target of various types of hacking. As a result, this API is limited to use in
[[Isolated-Web-Apps|Isolated Web Applications]] (IWAs) which have addtional
safeguards in place to protect users and developers.  IWAs are not a normal web
application and can exist only at a special 'isolated-app:' scheme. This means
by design that this API will not be available to normal web pages.

Note: This API is not intended to be a replacement or substitute for <{iframe}>.
All <{iframe}> use cases are still valid and should continue to use <{iframe}>,
including IWAs where possible.

<!-- ====================================================================== -->
<h2 id=based-on-fencedframe-spec>The Fenced Frame specification</h2>
<!-- ====================================================================== -->

For convenience, the Controlled Frame specification assumes that the Fenced
Frame specification is in place. There are concepts introduced in the Fenced
Frame specification, such as nested top-level traversables, that are broadly
useful to refer to in the context of Controlled Frame.

The Fenced Frame specification achieves defining these concepts via monkey
patching some specifications, such as HTML. We will also require monkey
patching specifications for some parts of this Controlled Frame specification.

<!-- ====================================================================== -->
<h2 id=the-controlledframe-element>The <dfn element export>controlledframe</dfn> element</h2>
<!-- ====================================================================== -->

<dl class="element">
 <dt>[=Categories=]:</dt>
 <dd>[=Flow content=].</dd>
 <dd>[=Phrasing content=].</dd>
 <dd>[=Embedded content=].</dd>
 <dd>[=Interactive content=].</dd>
 <dd>[=Palpable content=].</dd>
 <dt>[=Contexts in which this element can be used=]:</dt>
 <dd>Where [=embedded content=] is expected.</dd>
 <dt>[=Content model=]:</dt>
 <dd>[=Nothing=].</dd>
 <dt>[=Content attributes=]:</dt>
 <dd>[=Global attributes=]</dd>
 <dd><{HTMLControlledFrameElement/src}> — Content source URL to embed</dd>
 <dd><{HTMLControlledFrameElement/partition}> — Partition name to hold data related to this content</dd>
 <dt>[=Accessibility considerations=]:</dt>
 <dd><a href="https://w3c.github.io/html-aria/#el-iframe">For authors</a>.</dd>
 <dd><a href="https://w3c.github.io/html-aam/#el-iframe">For implementers</a>.</dd>
 <dd>

    Note: These link to the accessibility definitions of the <{iframe}> element.
    From an accessibility perspective, a <{controlledframe}> should behave the
    same as an <{iframe}>.
 </dd>
 <dt>[=DOM interface=]:</dt>
 <dd>
<xmp class=idl>
[Exposed=Window, IsolatedContext]
interface HTMLControlledFrameElement : HTMLElement {
    [HTMLConstructor] constructor();

    [CEReactions] attribute USVString src;
    attribute DOMString partition;

    readonly attribute WindowProxy? contentWindow;
    readonly attribute ContextMenus contextMenus;
    readonly attribute WebRequest request;

    // Navigation methods.
    Promise<boolean> back();
    Promise<boolean> canGoBack();
    Promise<boolean> forward();
    Promise<boolean> canGoForward();
    Promise<boolean> go(long relativeIndex);
    undefined reload();
    undefined stop();

    // Scripting methods.
    Promise<undefined> addContentScripts(sequence<ContentScriptDetails> contentScriptList);
    Promise<any> executeScript(optional InjectDetails details = {});
    Promise<undefined> insertCSS(optional InjectDetails details = {});
    Promise<undefined> removeContentScripts(optional sequence<DOMString> scriptNameList);

    // Configuration methods.
    Promise<undefined> clearData(
      optional ClearDataOptions options = {},
      optional ClearDataTypeSet types = {});
    Promise<boolean> getAudioState();
    Promise<long> getZoom();
    Promise<DOMString> getZoomMode();
    Promise<boolean> isAudioMuted();
    undefined setAudioMuted(boolean mute);
    Promise<undefined> setZoom(long zoomFactor);
    Promise<undefined> setZoomMode(DOMString zoomMode);

    // Capture methods.
    Promise<undefined> captureVisibleRegion(optional ImageDetails options = {});
    undefined print();

    // Events.
    attribute EventHandler onconsolemessage;
    attribute EventHandler oncontentload;
    attribute EventHandler ondialog;
    attribute EventHandler onloadabort;
    attribute EventHandler onloadcommit;
    attribute EventHandler onloadstart;
    attribute EventHandler onloadstop;
    attribute EventHandler onnewwindow;
    attribute EventHandler onpermissionrequest;
    attribute EventHandler onsizechanged;
    attribute EventHandler onzoomchange;
};
</xmp>
</dd>
</dl>

The <{controlledframe}> element [=represents=] its [=embedded navigable=].

Descendents of <{controlledframe}> elements represent nothing.

The Controlled Frame element is exposed to any {{Document}} with the
"`controlled-frame`" [=policy-controlled feature=] whose
[=environment settings object=] is an [=isolated context=].

The IDL attributes <dfn attribute for=HTMLControlledFrameElement>`src`</dfn> and
<dfn attribute for=HTMLControlledFrameElement>partition</dfn> must [=reflect=]
the respective content attributes of the same name.

Each <{controlledframe}> has an associated:
 * <dfn for=controlledframe>embedded navigable</dfn>, a
    [=traversable navigable=] with a non-null [=controlledFrameEmbedderParent=], or null.
    It is initially null.

    Note: The [=embedded navigable=] appears as a top-level traversable with a
    null [=navigable/parent=]. Content within the [=embedded navigable=] cannot
    detect that it is embedded.

 * <dfn for=controlledframe>content script map</dfn>, a [=/map=] whose
    [=map/keys=] are {{DOMString}}s and whose [=map/values=] are
    [=content script config=]s.

 * <dfn for=controlledframe>contentWindow</dfn>, a {{WindowProxy}} or null.

 * <dfn for=controlledframe>request</dfn>, a {{WebRequest}}.

 * <dfn for=controlledframe>contextMenus</dfn>, a {{ContextMenus}}.

The <dfn attribute for=HTMLControlledFrameElement>contentWindow</dfn> getter
steps are to return [=this=]'s [=controlledframe/contentWindow=].

The <dfn attribute for=HTMLControlledFrameElement>request</dfn> getter steps
are to return [=this=]'s [=controlledframe/request=].

The <dfn attribute for=HTMLControlledFrameElement>contextMenus</dfn> getter
steps are to return [=this=]'s [=controlledframe/contextMenus=].

<div algorithm=insertion>
  When a <{controlledframe}> element |element| is [=inserted into a document=]
  whose [=browsing context=] is non-null, run the following steps:

  1. If |element|'s {{HTMLControlledFrameElement/src}} is not empty, then:

      1. [=Initialize a controlledframe=] given |element|.

</div>

<div algorithm=destroy>
  When a <{controlledframe}> element |element| is [=removed from a document=],
  run the following steps:

  1. [=Destroy a top-level traversable=] given |element|'s
      [=embedded navigable=].

  1. Set |element|'s [=embedded navigable=] to null.

</div>

<div algorithm>
  To <dfn>initialize a <{controlledframe}></dfn> element |element|, run the
  following steps:

  1. [=Assert=] that |element|'s [=embedded navigable=] is null.

  1. Let |group| be a new [=browsing context group=].

  1. Let |document| be the second return value of [=creating a new browsing
      context and document=] given |element|'s [=node document=], |element|,
      and |group|.

  1. Let |documentState| be a new [=document state=], whose [=/document=]
      is |document|.

  1. Let |traversable| be a new [=traversable navigable=].

  1. [=Initialize the navigable=] |traversable| given |documentState|.

  1. Set |traversable|'s [=controlledFrameEmbedderParent=] to |element|.

  1. Set |element|'s [=embedded navigable=] to |traversable|.

  1. Let |initialHistoryEntry| be |traversable|'s [=navigable/active
      session history entry=].

  1. Set |initialHistoryEntry|'s [=session history entry/step=] to 0.

  1. [=list/Append=] |initialHistoryEntry| to |traversable|'s [=traversable
      navigable/session history entries=].

      Issue: These steps are needed to initialize {{History}}.{{History/length}}
          in the new navigable. This is an existing
          <a href="https://github.com/whatwg/html/issues/9030">issue</a>
          in the HTML Standard.

  1. Set |element|'s [=controlledframe/contentWindow=] to |document|'s
      {{WindowProxy}}.

  1. [=Navigate a controlledframe=] given |element| and |element|'s
      {{HTMLControlledFrameElement/src}}.

</div>

<div algorithm>
  To <dfn>navigate a <{controlledframe}></dfn> element |element| given a
  {{USVString}} |urlString|, run the following steps:

  1. If |urlString| is not an [=absolute-URL string=], return.

  1. Let |url| be the result of [=parsing a URL=] given |urlString| and |element|'s [=node document=].

  1. Let |historyHandling| be "{{NavigationHistoryBehavior/auto}}".

  1. If |element|'s [=embedded navigable=]'s [=active document=] is not
      [=completely loaded=], then set |historyHandling| to
      "{{NavigationHistoryBehavior/replace}}".

  1. [=Navigate=] |element|'s [=embedded navigable=] to |url| using |element|'s
      [=node document=], with a {{NavigationHistoryBehavior}} of |historyHandling|.

</div>

<div algorithm>
  The <dfn constructor for=HTMLControlledFrameElement>HTMLControlledFrameElement()</dfn>
  constructor steps are:

  1. Set [=this=]'s [=controlledframe/request=] to a [=new=] {{WebRequest}}.

  1. Set [=this=]'s [=controlledframe/contextMenus=] to a [=new=]
      {{ContextMenus}}.

</div>

<!-- ====================================================================== -->
## Common infrastructure ## {#common-infrastructure}
<!-- ====================================================================== -->

<div algorithm>
  To <dfn>resolve an embedder promise</dfn> given a <{controlledframe}>
  |controlledframe|, a [=promise=] |promise|, and an optional |value|,
  run the following steps:

  1. [=Queue a global task=] on the [=DOM manipulation task source=] of
      |controlledframe|'s [=relevant global object=] to [=resolve=] |promise|
      with |value|.

      Note: The [=relevant global object=] of |controlledframe| is the
          **embedder's** {{Window}} object.

</div>

<div algorithm>
  To <dfn>reject an embedder promise</dfn> given a <{controlledframe}>
  |controlledframe|, a [=promise=] |promise|, and an optional |value|,
  run the following steps:

  1. [=Queue a global task=] on the [=DOM manipulation task source=] of
      |controlledframe|'s [=relevant global object=] to [=reject=] |promise|
      with |value|.

      Note: The [=relevant global object=] of |controlledframe| is the
          **embedder's** {{Window}} object.

</div>

<div algorithm>
  A [=/URL=] |url| <dfn>matches a {{URLPattern}}</dfn> |pattern| if the
  following steps return `true`:

  1. Let |result| be the result of [=URL pattern/match=] given |pattern|,
      and |url|.

  1. If |result| is null, then return `false`.

  1. Return `true`.

</div>

<!-- ====================================================================== -->
## Attributes ## {#attributes}
<!-- ====================================================================== -->

The <dfn element-attr for=HTMLControlledFrameElement>partition</dfn> attribute
takes an identifier specifying where data related to the Controlled Frame's
instance should be stored. The identifier is composed of a string of
alphanumeric characters. All data for the [=embedded navigable=] must be stored
in a [=storage shelf=] keyed by this partition string along with the origin
that created the data.

By default, all data stored must be held in an in-memory storage partition so
that when the last Controlled Frame element with a given
{{HTMLControlledFrameElement/partition}} value is destroyed, the data is also
destroyed. While the data is held in this partition, no data from the
Controlled Frame's [=embedded navigable=] shall persist.

If the partition attribute identifier contains the prefix "persist:", the user
agent must use a disk-based storage environment rather than an in-memory
storage partition. Embedded content should not be able to detect whether its
storage is in-memory or persistent.

If multiple Controlled Frames share the same partition identifier, all of their
[=embedded navigable=] instances must share the same storage partition.

Note: The [[STORAGE]] specification is monkey patched below to partition
storage based on the value of the {{HTMLControlledFrameElement/partition}}
attribute.

<div algorithm=partition-setter>
  The {{HTMLControlledFrameElement/partition}} IDL attribute setter steps are:

  1. If [=this=]'s [=embedded navigable=] is not null, then:

      1. [=Throw=] a "{{NotSupportedError}}" {{DOMException}}.

  1. Set [=this=]'s <{HTMLControlledFrameElement/partition}> to the given value.

</div>

The <dfn element-attr for=HTMLControlledFrameElement>src</dfn> attribute reflects the Controlled
Frame's [=embedded navigable=]'s [=current session history entry=]'s
[=session history entry/URL=].

<div algorithm=src-setter>
  The {{HTMLControlledFrameElement/src}} IDL attribute setter steps are:

  1. If [=this=] is not [=in a document tree=], then return.

  1. If [=this=]'s [=embedded navigable=] is null, then:

      1. [=Initialize a controlledframe=] given [=this=].

  1. Otherwise:

      1. [=Navigate a controlledframe=] given [=this=] and the given value.

</div>

<!-- ====================================================================== -->
## Navigation methods ## {#api-nav}
<!-- ====================================================================== -->

<div class="domintro note">

  : {{HTMLControlledFrameElement/back()|back}}()

  :: Goes back one step in the overall
    <a href="https://html.spec.whatwg.org/multipage/document-sequences.html#tn-session-history-entries">
    session history entries </a> list for the
    <a href="https://html.spec.whatwg.org/multipage/document-sequences.html#traversable-navigable">
    traversable navigable</a> in the Controlled Frame.

    Returns a promise that resolves to `true` if the page was successfully
    navigated back, or `false` if the navigation failed or there was no previous
    step.

  : {{HTMLControlledFrameElement/canGoBack()|canGoBack}}()

  :: Returns a promise that resolves to `true` if the [=current session
      history entry=] is not the first one in the [=embedded navigable=]'s
      [=session history entries=]. This means that there is a previous
      [=session history entry=] for the [=/navigable=].

  : {{HTMLControlledFrameElement/forward()|forward}}()

  :: Goes forward one step in the overall
    <a href="https://html.spec.whatwg.org/multipage/document-sequences.html#tn-session-history-entries">
    session history entries </a> list for the
    <a href="https://html.spec.whatwg.org/multipage/document-sequences.html#traversable-navigable">
    traversable navigable</a> in the Controlled Frame.

    Returns a promise that resolves to `true` if the page was successfully
    navigated forward, or `false` if the navigation failed or there was no next
    step.

  : {{HTMLControlledFrameElement/canGoForward()|canGoForward}}()

  :: Returns a promise that resolves to `true` if the [=current session history
      entry=] is not the last one in the [=embedded navigable=]'s
      [=session history entries=]. This means that there is a next
      [=session history entry=] for the [=/navigable=].

  : {{HTMLControlledFrameElement/go()|go}}()

  :: Reloads the current page.

  : {{HTMLControlledFrameElement/go()|go}}(<var>relativeIndex</var>)

  :: Goes back or forward <var>relativeIndex</var> number of steps in the overall
    <a href="https://html.spec.whatwg.org/multipage/document-sequences.html#tn-session-history-entries">
    session history entries </a> list for the current
    <a href="https://html.spec.whatwg.org/multipage/document-sequences.html#traversable-navigable">
    traversable navigable</a>.

    A zero relative index will reload the current page.

    Returns a promise that resolves to `true` if the page was successfully
    navigated, or `false` if the navigation failed or the provided relative
    index was out of range.

  : {{HTMLControlledFrameElement/reload()|reload}}()

  :: Reloads the current page.

  : {{HTMLControlledFrameElement/stop()|stop}}()

  :: Cancels the document load.

</div>

<div algorithm>
  To <dfn>delta traverse an embedded navigable's history</dfn>, given a
  <{controlledframe}> |controlledframe| and an integer |delta|, run the
  following steps:

  1. Let |resultPromise| be [=a new promise=].

  1. Return |resultPromise| and run the remaining steps [=in parallel=].

  1. Let |embeddedNavigable| be |controlledframe|'s [=embedded navigable=].

  1. If |embeddedNavigable| is null, then [=resolve an embedder promise=] given
      |controlledframe|, |resultPromise|, and `false`, and abort these steps.

  1. If |embeddedNavigable|'s [=active document=] is not [=fully active=],
      then [=resolve an embedder promise=] given |controlledframe|, |resultPromise|,
      and `false`, and abort these steps.

  1. [=Append the following session history traversal steps=] to
      |embeddedNavigable|:

      1. Let |allSteps| be the result of [=getting all used history steps=]
          for |embeddedNavigable|.

      1. Let |currentStepIndex| be the index of |embeddedNavigable|'s
          [=current session history step=] within |allSteps|.

      1. Let |targetStepIndex| be |currentStepIndex| + |delta|.

      1. If |allSteps|[|targetStepIndex|] does not [=list/exist=], then
          [=resolve an embedder promise=] given |controlledframe|, |resultPromise|,
          and `false`, and abort these steps.

      1. Let |result| be the result of [=applying the traverse history step=]
          |allSteps|[|targetStepIndex|] to |embeddedNavigable| given a
          [=user navigation involvement=] of "[=none=]".

      1. If |result| is not equal to "`applied`", then [=resolve an
          embedder promise=] given |controlledframe|, |resultPromise|, and `false`.

      1. Otherwise, [=resolve an embedder promise=] given |controlledframe|,
          |resultPromise|, and `true`.

</div>

<div algorithm>
  The <dfn method for=HTMLControlledFrameElement>canGoBack()</dfn>
  method steps are:

  1. Let |result| be [=a new promise=].

  1. Let |controlledframe| be [=this=].

  1. Let |embeddedNavigable| be |controlledframe|'s [=embedded navigable=].

  1. If |embeddedNavigable| is null, then [=resolve=] |result| with `false`
      and return |result|.

  1. [=Queue a global task=] on the [=navigation and traversal task source=] of
      |embeddedNavigable|'s [=node document=]'s [=relevant global object=] that
      will run the following steps:

      1. Let |canGoBack| be `true` if |embeddedNavigable|'s
          [=current session history step=] is &gt; 0, `false` otherwise.

      1. [=Resolve an embedder promise=] given |controlledframe|, |result|,
          and |canGoBack|.

  1. Return |result|.

</div>

<div algorithm>
  The <dfn method for=HTMLControlledFrameElement>canGoForward()</dfn>
  method steps are:

  1. Let |result| be [=a new promise=].

  1. Let |controlledframe| be [=this=].

  1. Let |embeddedNavigable| be |controlledframe|'s [=embedded navigable=].

  1. If |embeddedNavigable| is null, then [=resolve=] |result| with `false`
      and return |result|.

  1. [=Queue a global task=] on the [=navigation and traversal task source=] of
      |embeddedNavigable|'s [=node document=]'s [=relevant global object=] that
      will run the following steps:

      1. Let |step| be |embeddedNavigable|'s [=current session history step=].

      1. Let |steps| be the result of [=getting all used history steps=]
          given |embeddedNavigable|.

      1. Let |canGoForward| be `true` if |step| + 1 &lt; the [=list/size=] of
          |steps|, `false` otherwise.

      1. [=Resolve an embedder promise=] given |controlledframe|, |result|,
          and |canGoForward|.

  1. Return |result|.

</div>

<div algorithm>
  The <dfn method for=HTMLControlledFrameElement>back()</dfn> method steps are:

  1. Return the result of [=delta traverse an embedded navigable's history=]
      given [=this=] and -1.

</div>

<div algorithm>
  The <dfn method for=HTMLControlledFrameElement>forward()</dfn> method steps
  are:

  1. Return the result of [=delta traverse an embedded navigable's history=]
      given [=this=] and 1.

</div>

<div algorithm>
  The <dfn method for=HTMLControlledFrameElement>go(|relativeIndex|)</dfn>
  method steps  are:

  1. Return the result of [=delta traverse an embedded navigable's history=]
      given [=this=] and |relativeIndex|.

</div>

<div algorithm>
  The <dfn method for=HTMLControlledFrameElement>reload()</dfn> steps are:

  1. Let |embeddedNavigable| be [=this=]'s [=embedded navigable=].

  1. If |embeddedNavigable| is null, return.

  1. [=Queue a global task=] on the [=navigation and traversal task source=] of
      |embeddedNavigable|'s [=node document=]'s [=relevant global object=] that
      will [=reload=] |embeddedNavigable| given a
      [=user navigation involvement=] of "[=none=]".

</div>

<div algorithm>
  The <dfn method for=HTMLControlledFrameElement>stop()</dfn> steps are:

  1. Let |embeddedNavigable| be [=this=]'s [=embedded navigable=].

  1. If |embeddedNavigable| is null, return.

  1. [=Queue a global task=] on the [=navigation and traversal task source=] of
      |embeddedNavigable|'s [=node document=]'s [=relevant global object=] that
      will [=stop loading=] |embeddedNavigable|.

</div>

<!-- ====================================================================== -->
## Scripting methods ## {#api-scripting}
<!-- ====================================================================== -->

<xmp class="idl">
// One of |code| or |file| must be specified but not both.
dictionary InjectDetails {
  DOMString code;
  USVString file;
};

dictionary InjectionItems {
  DOMString code;
  sequence<USVString> files;
};

enum RunAt {
  "document-start",
  "document-end",
  "document-idle",
};

dictionary ContentScriptDetails {
  required DOMString name;
  InjectionItems js;
  InjectionItems css;
  required sequence<(URLPattern or URLPatternInput)> urlPatterns;
  sequence<(URLPattern or URLPatternInput)> excludeURLPatterns;
  boolean allFrames;
  boolean matchAboutBlank;
  RunAt runAt;
};
</xmp>

A <dfn>content script config</dfn> is a [=struct=] with the following
[=struct/items=]:

<dl export dfn-for="content script config">
  : <dfn>pendingFetchCount</dfn>
  :: a {{long}} representing the number of pending script/style fetches.

  : <dfn>js</dfn>
  :: a [=list=] of {{DOMString}}s containing JavaScript that will be injected
      into a document.

  : <dfn>css</dfn>
  :: a [=list=] of {{DOMString}}s containing CSS that will be injected into a
      document.

  : <dfn>urlPatterns</dfn>
  :: a [=list=] of {{URLPattern}}s.

      Note: Content may be injected into a document if its [=Document/URL=]
      <a href="#matches-a-urlpattern">matches</a> any of these patterns.

  : <dfn>excludeURLPatterns</dfn>
  :: a [=list=] of {{URLPattern}}s.

      Note: Content will not be injected into a document if its [=Document/URL=]
      <a href="#matches-a-urlpattern">matches</a> any of these patterns. This
      overrides [=content script config/urlPattern=]; if both lists have entries
      that a document's [=Document/URL=] matches, the content will not be
      injected into the document.

  : <dfn>allFrames</dfn>
  :: a [=boolean=] indicating whether content should be injected into all
      frames in a page, or just the top-level frame.

  : <dfn>matchAboutBlank</dfn>
  :: a [=boolean=] indicating whether content should be injected into
      about:blank pages.

  : <dfn>runAt</dfn>
  :: a {{RunAt}} indicating when JavaScript content should be executed in a
      document's lifecycle.

</dl>

<div algorithm>
  To <dfn>fetch an injection item</dfn> given a <{controlledframe}>
  |controlledframe|, a {{USVString}} |urlString|, a [=boolean=] |isCss|, a
  {{long}} |index|, and an algorithm |completionSteps| that takes a {{long}},
  a {{boolean}}, and a {{DOMString}}, run the following steps:

  Note: [=Fetch a classic script=] cannot be used here because the fetch needs
  to use |controlledframe|'s [=relevant settings object=], but the
  [=classic script=] is executed using the [=embedded navigable=]'s
  [=active document=]'s [=relevant settings object=].

  1. If |urlString| is not an [=valid URL string=], then:

      1. Run |completionSteps| given 0, `false`, and "".

      1. Return.

  1. Let |request| be a new [=/request=] with the following fields:
      : [=request/URL=]
      :: The result of [=parsing a URL=] given |urlString| and
          |controlledframe|'s [=node document=].
      : [=request/method=]
      :: "`GET`"
      : [=request/destination=]
      :: "`style`" if |isCss| is `true`, "`script`" otherwise
      : [=request/client=]
      :: |controlledframe|'s [=relevant settings object=]
      : [=request/mode=]
      :: "`cors`"

  1. [=Fetch=] |request|, with [=processResponseConsumeBody=] set to the
      following steps given a [=/response=] |response| and a null, failure, or
      [=byte sequence=] |contents|:

      1. If |response|'s [=response/status=] is not 200, or |contents| is null
          or failure, then run |completionSteps| given 0, `false`, and ""

      1. Otherwise, run |completionSteps| given |index|, `true`, and |contents|.

</div>

<div algorithm>
  To <dfn>validate and resolve {{ContentScriptDetails}}</dfn> given a
  <{controlledframe}> |controlledframe| and a {{ContentScriptDetails}}
  |details|, run the following steps:

  1. Let |result| be [=a new promise=].

  1. If |details|["{{ContentScriptDetails/js}}"] and
      |details|["{{ContentScriptDetails/css}}"] are both defined, or both
      undefined, then [=reject=] |result| with a {{TypeError}} and return it.

  1. If |details|["{{ContentScriptDetails/urlPatterns}}"] is [=list/empty=],
      then [=reject=] |result| with a {{TypeError}} and return it.

  1. Let |isCss| be a [=boolean=] equal to `true` if
      |details|["{{ContentScriptDetails/css}}"] is defined, `false` otherwise.

  1. If |isCss| is `true` and |details|["{{ContentScriptDetails/runAt}}"] does
      not equal "{{RunAt/document-start}}", then [=reject=] |result| with a
      {{TypeError}} and return it.

  1. Let |injectionItems| be |details|["{{ContentScriptDetails/css}}"] if
      |isCss| is `true`, |details|["{{ContentScriptDetails/js}}"] otherwise.

  1. If |injectionItems|["{{InjectionItems/code}}"] and
      |injectionItems|["{{InjectionItems/files}}"] are both defined, or both
      undefined, [=reject=] |result| with a {{TypeError}} and return it.

  1. Return |result| and run the remaining steps [=in parallel=].

  1. Let |config| be a new [=content script config=] with the following values:

      : [=content script config/pendingFetchCount=]
      :: 0
      : [=content script config/urlPatterns=]
      :: «»
      : [=content script config/excludeURLPatterns=]
      :: «»
      : [=content script config/allFrames=]
      :: |details|["{{ContentScriptDetails/allFrames}}"] if defined, otherwise
          `false`
      : [=content script config/matchAboutBlank=]
      :: |details|["{{ContentScriptDetails/matchAboutBlank}}"] if defined,
          otherwise `false`
      : [=content script config/runAt=]
      :: |details|["{{ContentScriptDetails/runAt}}"] if defined, otherwise
          {{RunAt/document-idle}}

  1. [=list/For each=] |urlPattern| in |details|["{{
      ContentScriptDetails/urlPatterns}}"]:

      1. If |urlPattern| is a {{URLPattern}}, then [=list/append=] |urlPattern|
          to |config|'s [=content script config/urlPatterns=].

      1. Otherwise, [=list/append=] a [=new=] {{URLPattern}} given |urlPattern|
          to |config|'s [=content script config/urlPatterns=].

  1. If |details|["{{ContentScriptDetails/excludeURLPatterns}}"] is defined,
      then:

      1. [=list/For each=] |urlPattern| in |details|["{{
          ContentScriptDetails/excludeURLPatterns}}"]:

          1. If |urlPattern| is a {{URLPattern}}, then [=list/append=]
              |urlPattern| to |config|'s
              [=content script config/excludeURLPatterns=].

          1. Otherwise, [=list/append=] a [=new=] {{URLPattern}} given
              |urlPattern| to |config|'s
              [=content script config/excludeURLPatterns=].

  1. Let |completionSteps| be the following algorithm, which takes a {{long}}
      |index|, a [=boolean=] |success|, and a {{DOMString}} |source|:

      1. If |success| is `false`, then [=reject an embedder promise=]
          given |controlledframe|, |result|, and {{TypeError}}, and abort
          these steps.

      1. If |isCss|, then:

          1. Set |config|'s [=content script config/css=][|index|] to |source|.

      1. Otherwise:

          1. Set |config|'s [=content script config/js=][|index|] to |source|.

      1. Decrement |config|'s [=content script config/pendingFetchCount=].

      1. If |config|'s [=content script config/pendingFetchCount=] is greater
          than 0, then return.

      1. Set |controlledframe|'s [=controlledframe/content script map
          =][|details|[{{ContentScriptDetails/name}}]] to |config|.

      1. [=Resolve an embedder promise=] given |controlledframe| and |result|.

  1. If |injectionItems|["{{InjectionItems/code}}"] is defined, then:

      1. Run |completionSteps| given 0, `true`, and |injectionItems|
          ["{{InjectionItems/code}}"].

  1. Otherwise:

      1. If |injectionItems|["{{InjectionItems/files}}"] is [=list/empty=], then
          [=reject an embedder promise=] given |controlledframe|, |result|,
          and {{TypeError}}, and abort these steps.

      1. [=list/For each=] |urlString| of |injectionItems|
          ["{{InjectionItems/files}}"]:

          1. Run [=fetch an injection item=] given |controlledframe|,
              |urlString|, |isCss|, |config|'s
              [=content script config/pendingFetchCount=], and
              |completionSteps|.

          1. Increment |config|'s [=content script config/pendingFetchCount=].

</div>

<div algorithm>
  To determine if a <dfn>[=content script config=] applies to a document</dfn>
  given a [=content script config=] |config|, a [=/URL=] |url|, and a
  [=boolean=] |isTopLevel|, run the following steps:

  1. If |isTopLevel| is `false`, and |config|'s
      [=content script config/allFrames=] is `false`, then return `false`.

  1. If |url| [=matches about:blank=] and |config|'s
      [=content script config/matchAboutBlank=] is `false`, then return `false`.

  1. Let |urlString| be the result of <a lt="urlencoded serializer">
      serializing</a> |url|.

  1. Let |match| be `false`.

  1. [=list/For each=] |pattern| of |config|'s
      [=content script config/urlPatterns=]:

      1. If |urlString| [=matches a URLPattern=] |pattern|, then set
          |match| to `true`.

  1. [=list/For each=] |pattern| of |config|'s
      [=content script config/excludeURLPatterns=]:

      1. If |urlString| [=matches a URLPattern=] |pattern|, then set
          |match| to `false`.

  1. Return |match|.

</div>

<div algorithm>
  To <dfn>inject content scripts into a document</dfn> given a {{Document}}
  |document|, and a {{RunAt}} |currentPhase|, run the following steps:

  1. Let |embeddedNavigable| be |document|'s [=node navigable=]'s
      [=traversable navigable=].

  1. If |embeddedNavigable| is null or its [=controlledFrameEmbedderParent=] is null, then
      return.

  1. Let |controlledframe| be |embeddedNavigable|'s [=controlledFrameEmbedderParent=].

  1. Let |url| be |document|'s [=Document/URL=].

  1. Let |isTopLevel| be `true` if |document|'s [=node navigable=]'s
      [=navigable/parent=] is null, `false` otherwise.

  1. [=list/For each=] |config| of |controlledframe|'s [=content script map=]:

      1. If the result of determining whether a [=content script config applies
          to a document=] given |config|, |url|, and |isTopLevel| equals
          `false`, then [=continue=].

      1. If |currentPhase| is equal to {{RunAt/document-start}} and |config|'s
          [=content script config/css=] is not [=list/empty=], then:

          1. [=list/For each=] |styleSource| of |config|'s
              [=content script config/css=], run [=inject a stylesheet into a
              document=] given |document| and |styleSource|.

      1. Otherwise, if |currentPhase| equals |config|'s
          [=content script config/runAt=], then:

          1. [=list/For each=] |scriptSource| of |config|'s
              [=content script config/js=], run [=inject a script into a
              document=] given |document|, |scriptSource|, and an empty
              algorithm.

</div>

<div algorithm>
  To <dfn>inject a stylesheet into a document</dfn> given a {{Document}}
  |document| and a {{DOMString}} |styleSource|, run the following steps:

  1. Let |styleSheet| be a new [=CSS style sheet=] object.

  1. [=Synchronously replace the rules of a CSSStyleSheet=] given |styleSheet|
      and |styleSource|.

  1. [=Queue a global task=] on the [=DOM manipulation task source=] of
      |document|'s [=global object=] to [=add a CSS style sheet=] given
      |document| and |styleSheet|.

</div>

Advisement: The following algorithm executes script in a Document's
[=environment=], but that isn't the desired behavior. The goal, which cannot be
specced with the current HTML specification infrastructure, is for this
algorithm to execute script in an environment that is isolated from the
Document's environment with a different global object, but with shared access
to the DOM. This execution environment is called an
<a href="https://developer.chrome.com/docs/extensions/develop/concepts/content-scripts#isolated_world">
Isolated World</a> in Blink, which uses it to execute
<a href="https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Content_scripts">
content scripts</a> in extensions. See this
<a href="https://drive.google.com/file/d/0B1obCOyvTnPKQmJEWkVtOEN2TmM/view?resourcekey=0-m_AA1o8fpD-1GKVgkKQQ4g">
diagram</a> for additional details about their execution model. Gecko uses
a similar approach called
<a href="https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/Sharing_objects_with_page_scripts#xray_vision_in_firefox">
Xray vision</a>. This algorithm should eventually describe a speccable
implementation of this isolation that can be implemented by all browsers.

<div algorithm>
  To <dfn>inject a script into a document</dfn> given a {{Document}} |document|,
  a {{DOMString}} |scriptSource|, and an algorithm |completionSteps| that takes
  a [=completion record=], run the following steps:

  Note: `document.currentScript` is intentionally not set while executing
  |scriptSource|.

  1. Let |script| be the result of [=creating a classic script=] given
      |scriptSource|, |document|'s [=relevant settings object=], |document|'s
      [=Document/URL=], and the [=default script fetch options=].

  1. [=Queue a global task=] on the [=DOM manipulation task source=] of
      |document|'s [=global object=] that will run the following steps:

      1. Let |completionRecord| be the result of [=running a classic script=]
          given |script|.

      1. Let |controlledframe| be |document|'s [=node navigable=]'s
          [=traversable navigable=]'s [=controlledFrameEmbedderParent=].

      1. [=Queue a global task=] on the [=DOM manipulation task source=] of
          |controlledframe|'s [=relevant global object=] that will run
          |completionSteps| with |completionRecord|.

</div>

<div algorithm>
  The <dfn method for=HTMLControlledFrameElement>addContentScripts(|contentScriptList|)</dfn>
  method steps are:

  1. If |contentScriptList| is [=list/empty=], return [=a new promise=] that is
      [=rejected=] with a {{TypeError}}.

  1. Let |promises| be an empty [=list=].

  1. [=list/For each=] |contentScript| in |contentScriptList|:

      1. Let |promise| be the result of calling [=validate and resolve
          ContentScriptDetails=] given |contentScript|.

      1. [=list/Append=] |promise| to |promises|.

  1. Return the result of [=getting a promise for waiting for all promises=] given |promises|.

</div>

<div algorithm>
  The <dfn method for=HTMLControlledFrameElement>removeContentScripts(|scriptNameList|)</dfn>
  method steps are:

  1. Let |result| be [=a new promise=].

  1. Let |controlledframe| be [=this=].

  1. Return |result| and run the remaining steps [=in parallel=].

  1. If |scriptNameList| is undefined, then:

      1. [=map/Clear=] |controlledframe|'s [=content script map=].

  1. Otherwise, [=list/for each=] |name| of |scriptNameList|:

      1. [=map/Remove=] |controlledframe|'s [=content script map=][|name|].

  1. [=Resolve an embedder promise=] given |controlledframe| and |result|.

</div>

<div algorithm>
  The <dfn method for=HTMLControlledFrameElement>executeScript(|details|)</dfn>
  method steps are:

  1. Let |result| be [=a new promise=].

  1. Let |controlledframe| be [=this=].

  1. Return |result| and run the remaining steps [=in parallel=].

  1. If |controlledframe|'s [=embedded navigable=] is null, then [=reject an
      embedder promise=] given |controlledframe|, |result|, and a {{TypeError}},
      and abort these steps.

  1. If |details|["{{InjectDetails/code}}"] and
      |details|"[{{InjectDetails/file}}"] are either both defined or both
      undefined, then [=reject an embedder promise=] given |controlledframe|,
      |result|, and a {{TypeError}}, and abort these steps.

  1. Let |executionSteps| be the following algorithm that takes a {{long}} and
      a {{DOMString}} or [=boolean=] |scriptString|:

      1. If |scriptString| is not a {{DOMString}}, then [=reject an embedder
          promise=] given |controlledframe|, |result|, and a {{TypeError}},
          and abort these steps.

      1. Let |document| be |controlledframe|'s [=embedded navigable=]'s
          [=active document=].

      1. [=Inject a script into a document=] given |document|, |scriptString|,
          and the following algorithm that accepts a [=completion record=]
          |completionRecord|:

          1. If |completionRecord| is a [=normal completion=], then:

              1. [=Resolve an embedder promise=] given |controlledframe|,
                  |result|, and |completionRecord|.`[[Value]]`.

          1. Otherwise:

              1. [=Reject an embedder promise=] given |controlledframe|,
                  |result|, and |completionRecord|.`[[Value]]`.

  1. If |details|["{{InjectDetails/code}}"] is defined, then run
      |executionSteps| given 0 and |details|["{{InjectDetails/code}}"].

  1. Otherwise, [=fetch an injection item=] given |controlledframe|,
      |details|["{{InjectDetails/file}}"], `false`, 0, and |executionSteps|.

</div>

<div algorithm>
  The <dfn method for=HTMLControlledFrameElement>insertCSS(|details|)</dfn>
  method steps are:

  1. Let |result| be [=a new promise=].

  1. Let |controlledframe| be [=this=].

  1. Return |result| and run the remaining steps [=in parallel=].

  1. If |controlledframe|'s [=embedded navigable=] is null, then
      [=reject an embedder promise=] given |controlledframe|, |result|, and a
      {{TypeError}}, and abort these steps.

  1. If |details|["{{InjectDetails/code}}"] and
      |details|["{{InjectDetails/file}}"] are either both defined or both
      undefined, then [=reject an embedder promise=] given |controlledframe|,
      |result|, and a {{TypeError}}, and abort these steps.

  1. Let |executionSteps| be the following algorithm that takes a {{long}}, a
      [=boolean=] |success|, and a {{DOMString}} |styleString|:

      1. If |success| is `false`, then [=reject an embedder promise=] given
          |controlledframe|, |result|, and a {{TypeError}}, and abort these
          steps.

      1. Let |document| be |controlledframe|'s [=embedded navigable=]'s
          [=active document=].

      1. [=Inject a stylesheet into a document=] given |document| and
          |styleString|.

      1. [=Resolve an embedder promise=] given |controlledframe| and |result|.

  1. If |details|["{{InjectDetails/code}}"] is defined, then run
      |executionSteps| given 0, `true`, and |details|["{{InjectDetails/code}}"].

  1. Otherwise, [=fetch an injection item=] given |controlledframe|,
      |details|["{{InjectDetails/file}}"], `false`, 0, and |executionSteps|.

</div>

<!-- ====================================================================== -->
## Configuration methods ## {#api-config}
<!-- ====================================================================== -->

<xmp class="idl">
dictionary ClearDataOptions {
  long since;
};

dictionary ClearDataTypeSet {
  boolean cache;
  boolean cookies;
  boolean fileSystems;
  boolean indexedDB;
  boolean localStorage;
  boolean persistentCookies;
  boolean sessionCookies;
};
</xmp>

<div algorithm>
  To <dfn>empty a [=storage bottle=]</dfn> given a [=storage bucket=] |bucket|,
  a [=storage identifier=] |identifier|, and a {{long}} |since|, run the
  following steps:

  Note: If possible, the [=user agent=] should only remove data that has been
  last used after |since|, which represents a timestamp in milliseconds since
  [=epoch=]. Not all [=user agents=] track write or access time for all
  browsing data. Implementations should respect |since| to the best of their
  ability, but the API does not guarantee its availability.

  1. Let |bottle| be |bucket|[|identifier|].

  1. [=map/Clear=] |bottle|'s [=storage bottle/map=].

  1. Set |bottle|'s [=storage bottle/proxy map reference set=] to a new [=set=].

</div>

<div algorithm>
  The <dfn method for=HTMLControlledFrameElement>clearData(|options|, |types|)</dfn>
  method steps are:

  1. Let |resultPromise| be [=a new promise=].

  1. Let |controlledframe| be [=this=].

  1. Return |resultPromise| and run the remaining steps [=in parallel=].

  1. Let |clearSince| be 0.

  1. If |options|["{{ClearDataOptions/since}}"] is defined, set |clearSince| to
      options|["{{ClearDataOptions/since}}"].

  1. Let |embeddingOrigin| be the [=environment/top-level origin=] of
      |controlledframe|'s [=relevant settings object=].

  1. Let |partition| be |controlledframe|'s
      {{HTMLControlledFrameElement/partition}}.

  1. [=map/For each=] |storageKey| &rightarrow; |shelf| of the [=user agent=]'s
      [=storage shed=]:

      1. If |storageKey|'s [=storage key/embedding origin=] is not equal to
          |embeddingOrigin| or |storageKey|'s [=storage key/partition=] is not
          equal to |partition|, then [=continue=].

      1. Let |bucket| be |shelf|["`default`"].

      1. If |types|["{{ClearDataTypeSet/fileSystems}}"] is `true`:

          1. [=Empty a storage bottle=] given |bucket|, "`fileSystem`", and
              |clearSince|.

      1. If |types|["{{ClearDataTypeSet/indexedDB}}"] is `true`:

          1. [=Empty a storage bottle=] given |bucket|, "`indexedDB`", and
              |clearSince|.

      1. If |types|["{{ClearDataTypeSet/localStorage}}"] is `true`:

          1. [=Empty a storage bottle=] given |bucket|, "`localStorage`", and
              |clearSince|.

  1. If |types|["{{ClearDataTypeSet/cookies}}"],
      |types|["{{ClearDataTypeSet/persistentCookies}}"], or
      |types|["{{ClearDataTypeSet/sessionCookies}}"] are `true`, then:

      Advisement: The [[COOKIES]] specification does not support partitioning
      cookies through a mechanism like [=storage key=]s. The following steps
      will clear all cookies, but the intention is to only delete cookies
      created by content within a Controlled Frame with this Controlled Frame's
      current {{HTMLControlledFrameElement/partition}}.

      1. [=list/For each=] |cookie| in the [=user agent=]'s cookie store:

          1. If |cookie|'s persistent-flag is set, then:

              1. If |types|["{{ClearDataTypeSet/cookies}}"] and
                  |types|["{{ClearDataTypeSet/persistentCookies}}"] are `false`,
                  then [=continue=].

          1. Otherwise:

              1. If |types|["{{ClearDataTypeSet/cookies}}"] and
                  |types|["{{ClearDataTypeSet/sessionCookies}}"] are `false`,
                  then [=continue=].

          1. If |cookie|'s last-access-time represented as milliseconds since
              the [=epoch=] is less than |clearSince|, then [=continue=].

          1. Remove |cookie| from the [=user agent=]'s  cookie store.

  1. If |types|["{{ClearDataTypeSet/cache}}"] is `true`, then:

      1. [=list/For each=] |storageKey| &rightarrow; |cache| that the
          [=user agent=] manages: [[HTTP-CACHING]]

          1. If |storageKey|'s [=storage key/embedding origin=] is not equal to
              |embeddingOrigin| or |storageKey|'s [=storage key/partition=] is
              not equal to |partition|, then [=continue=].

          1. Clear |cache|.

  1. [=Resolve an embedder promise=] given |controlledframe| and
      |resultPromise|.

</div>

Each [=embedded navigable=] holds a
<dfn for="embedded navigable">muted</dfn> [=boolean=], which defaults to
`false`. When [=embedded navigable/muted=] is `true`, the user agent must
mute all audio streams originating from within the [=embedded navigable=].
The [=embedded navigable/muted=] state should not be exposed to content
within the [=embedded navigable=]; when [=embedded navigable/muted=] is
`true`, volume state should not be changed in any script-visible way, but the
underlying audio streams should not be audible to users.

<div algorithm>
  The <dfn method for=HTMLControlledFrameElement>getAudioState()</dfn>
  method steps are:

  1. Let |resultPromise| be [=a new promise=].

  1. Let |controlledframe| be [=this=].

  1. Return |resultPromise| and run the remaining steps [=in parallel=].

  1. If |controlledframe|'s [=embedded navigable=] is null, then [=reject an
      embedder promise=] given |controlledframe|, |resultPromise|, and a
      {{TypeError}}, and abort these steps.

  1. Let |playingAudio| be `true` if any content, including in nested frames,
      within |controlledframe|'s [=embedded navigable=] is currently playing
      audio, `false` otherwise.

  1. [=Resolve an embedder promise=] given |controlledframe|, |resultPromise|,
      and |playingAudio|.

</div>

<div algorithm>
  The <dfn method for=HTMLControlledFrameElement>isAudioMuted()</dfn>
  method steps are:

  1. Let |resultPromise| be [=a new promise=].

  1. Let |controlledframe| be [=this=].

  1. Return |resultPromise| and run the remaining steps [=in parallel=].

  1. If |controlledframe|'s [=embedded navigable=] is null, then [=reject an
      embedder promise=] given |controlledframe|, |resultPromise|, and a
      {{TypeError}}, and abort these steps.

  1. [=Resolve an embedder promise=] given |controlledframe|, |resultPromise|,
      and |controlledframe|'s [=embedded navigable=]'s
      [=embedded navigable/muted=] flag.

</div>

<div algorithm>
  The <dfn method for=HTMLControlledFrameElement>setAudioMuted(|mute|)</dfn>
  method steps are:

  1. If [=this=]'s [=embedded navigable=] is null, then [=throw=] a
      {{TypeError}}.

  1. Set [=this=]'s [=embedded navigable=]'s [=embedded navigable/muted=]
      flag to |mute|.

</div>

<!-- ====================================================================== -->
### Zoom ### {#api-config-zoom}
<!-- ====================================================================== -->

<xmp class="idl">

enum ZoomMode {
  "per-origin",
  "per-view",
  "disabled"
};

</xmp>

The user agent holds a <dfn>Controlled Frame zoom map</dfn> which is a [=/map=] whose [=map/keys=] are [=tuples=], and [=map/values=] are [=floats=].

Each {{HTMLControlledFrameElement}} holds a {{ZoomMode}} <dfn for=HTMLControlledFrameElement>zoomMode</dfn>, which is defaulted to {{ZoomMode/per-origin}}.

Each {{HTMLControlledFrameElement}} holds a float number <dfn>currentZoom</dfn>, initially set to 1.0f.

How <dfn data-lt='apply zoom level'>zoom level is applied</dfn> to a [=/document=] given [=float=] <var ignore=''>zoomLevel</var> is specific to the implementation.

<div class='note'>

  <em>This section is non-normative.</em>

  The valid {{ZoomMode}} values behave as follows:

  : {{ZoomMode/per-origin}}
  :: Zoom changes will persist in the embedded document's [=Document/origin=], i.e. all other {{HTMLControlledFrameElement}} in the same {{HTMLControlledFrameElement/partition}} that are navigated to that same [=/origin=] will be zoomed as well.

  : {{ZoomMode/per-view}}
  :: Zoom changes only take effect in this {{HTMLControlledFrameElement}}, and zoom changes in other {{HTMLControlledFrameElement}} will not affect the zooming of this {{HTMLControlledFrameElement}}.

  : {{ZoomMode/disabled}}
  :: Disables all zooming in the {{HTMLControlledFrameElement}}. The content will revert to the default zoom level, and all attempted zoom changes will be ignored.

</div>

<div algorithm>

To <dfn>get the per-origin zoom level</dfn>, given {{HTMLControlledFrameElement}} |e|, run the following steps:

1. Let |result| be a float initially set to 1.0f.

1. Let |key| be the result of [=obtaining a Controlled Frame storage key=] given the [=environment=] associated |e|'s [=embedded navigable=]'s [=navigable/active document=]'s [=current settings object=].

1. If [=Controlled Frame zoom map=][|key|] [=map/exists=], set |result| to the result of [=map/get the value=] of [=Controlled Frame zoom map=] given key |key|.

1. Return |result|.

</div>

<div algorithm>

To <dfn>set the per-origin zoom level</dfn>, given {{HTMLControlledFrameElement}} |e|, and a [=float=] |zoomLevel|, run the following steps:

1. Let |key| be the result of [=obtaining a Controlled Frame storage key=] given the [=environment=] associated |e|'s [=embedded navigable=]'s [=navigable/active document=]'s [=current settings object=].

1. [=map/Set the value=] of [=Controlled Frame zoom map=] given key |key| and value |zoomLevel|.

</div>


<div algorithm>

To determine whether <dfn>current document has a per-origin zoom level</dfn>, given {{HTMLControlledFrameElement}} |e|, run the following steps:

1. Let |key| be the result of [=obtaining a Controlled Frame storage key=] given the [=environment=] associated |e|'s [=embedded navigable=]'s [=navigable/active document=]'s [=current settings object=].

1. If [=Controlled Frame zoom map=][|key|] [=map/exist=], return `true`.

1. Return `false`.

</div>

<div algorithm>

The <dfn method for=HTMLControlledFrameElement>getZoomMode()</dfn> method steps are:

1. Let |p| be [=a new promise=].

1. Let |controlledframe| be [=this=].

1. Return |p| and run the remaining steps [=in parallel=].

1. [=Resolve an embedder promise=] given |controlledframe|, |p|, and
    |controlledframe|'s [=HTMLControlledFrameElement/zoomMode=].

</div>

<div algorithm>

The <dfn method for=HTMLControlledFrameElement>setZoomMode(|zoomMode|)</dfn> method steps are:

1. Let |p| be [=a new promise=].

1. Let |controlledframe| be [=this=].

1. Return |p| and run the remaining steps [=in parallel=].

1. Let |currentZoomMode| be the result of {{HTMLControlledFrameElement/getZoomMode}} given |controlledframe|.

1. If |currentZoomMode| equals |zoomMode|, [=resolve an embedder promise=]
    given |controlledframe| and |p|.

1. Set |controlledframe|'s [=HTMLControlledFrameElement/zoomMode=] to |zoomMode|.

1. If |zoomMode| is {{ZoomMode/per-origin}}:

      1. If [=current document has a per-origin zoom level=] given |controlledframe| is `true`:

            1. Let |oldZoomFactor| be |controlledframe|'s [=currentZoom=].

            1. Set |controlledframe|'s [=currentZoom=] to the result of [=get the per-origin zoom level=] given |controlledframe|.

            1. If |oldZoomFactor| does not equal to |controlledframe|'s [=currentZoom=]:

                  1. [=Apply zoom level=] to |controlledframe|'s embedded document given |controlledframe|'s [=currentZoom=].

                  1. [=Fire a "zoomchange" event=] with |controlledframe|, |oldZoomFactor|, |controlledframe|'s [=currentZoom=].

1. If |zoomMode| is {{ZoomMode/disabled}}:

      1. Let |oldZoomFactor| be |controlledframe|'s [=currentZoom=].

      1. Set |controlledframe|'s [=currentZoom=] to 1.0f.

      1. If |oldZoomFactor| does not equal to |controlledframe|'s [=currentZoom=]:

            1. [=Apply zoom level=] to |controlledframe|'s embedded document given |controlledframe|'s [=currentZoom=].

            1. [=Fire a "zoomchange" event=] with |controlledframe|, |oldZoomFactor|, |controlledframe|'s [=currentZoom=].

1. [=Resolve an embedder promise=] given |controlledframe| and |p|.

</div>

<div algorithm>

The <dfn method for=HTMLControlledFrameElement>getZoom()</dfn> method steps are:

1. Let |p| be [=a new promise=].

1. Let |controlledframe| be [=this=].

1. Return |p| and run the remaining steps [=in parallel=].

1. Let |embeddedNavigable| be |controlledframe|'s [=embedded navigable=].

1. If |embeddedNavigable| is null, then [=reject an embedder promise=] given
    |controlledframe|, |p|, and a {{TypeError}}, and abort these steps.

1. [=Resolve an embedder promise=] given |controlledframe|, |p|, and
    |controlledframe|'s [=currentZoom=].

</div>

<div algorithm>

The <dfn method for=HTMLControlledFrameElement>setZoom(|zoomFactor|)</dfn> method steps are:

1. Let |p| be [=a new promise=].

1. Let |controlledframe| be [=this=].

1. Return |p| and run the remaining steps [=in parallel=].

1. Let |embeddedNavigable| be |controlledframe|'s [=embedded navigable=].

1. If |embeddedNavigable| is null, then [=reject an embedder promise=] given
    |controlledframe|, |p|, and a {{TypeError}}, and abort these steps.

1. If |controlledframe|'s [=ZoomMode=] is {{ZoomMode/disabled}}:

      1. [=Reject an embedder promise=] given |controlledframe|, |p|, and a
          {{TypeError}}, and abort these steps.

1. If |controlledframe|'s [=ZoomMode=] is {{ZoomMode/per-origin}}:

      1. Let |oldZoomFactor| be |controlledframe|'s [=currentZoom=].

      1. [=Set the per-origin zoom level=] given |controlledframe| and
          |zoomFactor|.

      1. [=set/For each=] [=browsing context group=] |group| in the user agent's
          [=browsing context group set=]:

          1. [=set/For each=] [=top-level browsing context=] |browsingContext|
              in |group|:

              1. Let |embeddedDocument| be |browsingContext|'s
                  [=active document=].

              1. Let |embedder| be |embeddedDocument|'s [=node navigable=]'s
                  [=controlledFrameEmbedderParent=].

              1. If |embedder| is null, then [=continue=].

              1. Let |match| be `true` if all of the following conditions are
                  `true`:

                  * |embedder|'s [=ZoomMode=] is {{ZoomMode/per-origin}}

                  * |embedder|'s {{HTMLControlledFrameElement/partition}} equals
                      |controlledframe|'s {{HTMLControlledFrameElement/partition}}

                  * |embeddedDocument|'s [=document/origin=] equals
                      |controlledframe|'s [=embedded navigable=]'s
                      [=active document=]'s [=document/origin=]

                  * |embedder|'s [=currentZoom=] does not equal |zoomFactor|

              1. If |match| is `true`, then:

                    1. Set |embedder|'s [=currentZoom=] to |zoomFactor|.

                    1. [=Apply zoom level=] to |embeddedDocument| given
                        |zoomFactor|.

                    1. [=Fire a "zoomchange" event=] with |embedder|,
                        |oldZoomFactor|, and |zoomFactor|.

1. If |controlledframe|'s [=ZoomMode=] is {{ZoomMode/per-view}}:

      1. Let |oldZoomFactor| be |controlledframe|'s [=currentZoom=].

      1. Set |controlledframe|'s [=currentZoom=] to |zoomFactor|.

      1. If |oldZoomFactor| does not equal to |controlledframe|'s
          [=currentZoom=]:

            1. [=Apply zoom level=] to |controlledframe|'s embedded document
                given |controlledframe|'s [=currentZoom=].

            1. [=Fire a "zoomchange" event=] with |controlledframe|,
                |oldZoomFactor|, |controlledframe|'s [=currentZoom=].

1. [=Resolve an embedder promise=] given |controlledframe| and |p|.

</div>

<!-- ====================================================================== -->
## Capture methods ## {#api-capture}
<!-- ====================================================================== -->

<xmp class="idl">
// One of |code| or |file| must be specified but not both.
dictionary ImageDetails {
  DOMString format;
  DOMString quality;
};
</xmp>

<div algorithm>
  The <dfn method for=HTMLControlledFrameElement>captureVisibleRegion(|options|)</dfn>
  method steps are:

  1. Let |resultPromise| be [=a new promise=].

  1. Let |controlledframe| be [=this=].

  1. Return |resultPromise| and run the remaining steps [=in parallel=].

  1. If |controlledframe|'s [=embedded navigable=] is null, then [=reject an
      embedder promise=] given |controlledframe|, |resultPromise|, and a
      {{TypeError}}, and abort these steps.

  1. Let |optionsFormat| be "JPEG" by default.

  1. Let |optionsQuality| be 100 by default.

  1. If |options| has field "format":

      1. Let |optionsFormat| be |options|["format"].

  1. If |optionsFormat| is an unrecognized format, then [=reject an embedder
      promise=] given |controlledframe|, |resultPromise|, and a {{TypeError}},
      and abort these steps.

  1. If |options| has field "quality":

      1. Let |optionsQuality| be |options|["quality"].

  1. If |optionsQuality| is not an integer or is not between 0 and 100
     inclusive, then [=reject an embedder promise=] given |controlledframe|,
     |resultPromise|, and a {{TypeError}}, and abort these steps.

  1. Let |imageData| be a an image showing the visible region of the embedded
      content encoded in |optionsFormat| at quality |optionsQuality|.

    Note: The set of supported image formats is implementation-defined, but it
    is recommended to support at least "JPEG" and "PNG".

  1. [=Resolve an embedder promise=] given |controlledframe|, |resultPromise|,
      and a `data:` [=/URL=] that contains |imageData|.

</div>

<div algorithm>
  The <dfn method for=HTMLControlledFrameElement>print()</dfn>
  method steps are:

  1. If [=this=]'s [=embedded navigable=] is null, then [=throw=] a
      {{TypeError}}.

  1. Initiate the browser print page feature for embedded content.

</div>

<!-- ====================================================================== -->
## Events ## {#events}
<!-- ====================================================================== -->

{{HTMLControlledFrameElement}} implements {{EventTarget}} and supports the following [=event handlers=] (and their corresponding [=event handler event types=]).

<table>
  <tr>
    <th>[=Event handlers=]</th>
    <th>[=Event handler event types=]</th>
  </tr>
  <tr>
    <td><dfn attribute for=HTMLControlledFrameElement>onconsolemessage</dfn></td>
    <td>consolemessage</td>
  </tr>
  <tr>
    <td><dfn attribute for=HTMLControlledFrameElement>oncontentload</dfn></td>
    <td>contentload</td>
  </tr>
  <tr>
    <td><dfn attribute for=HTMLControlledFrameElement>ondialog</dfn></td>
    <td>dialog</td>
  </tr>
  <tr>
    <td><dfn attribute for=HTMLControlledFrameElement>onloadabort</dfn></td>
    <td>loadabort</td>
  </tr>
  <tr>
    <td><dfn attribute for=HTMLControlledFrameElement>onloadcommit</dfn></td>
    <td>loadcommit</td>
  </tr>
  <tr>
    <td><dfn attribute for=HTMLControlledFrameElement>onloadstart</dfn></td>
    <td>loadstart</td>
  </tr>
  <tr>
    <td><dfn attribute for=HTMLControlledFrameElement>onloadstop</dfn></td>
    <td>loadstop</td>
  </tr>
  <tr>
    <td><dfn attribute for=HTMLControlledFrameElement>onnewwindow</dfn></td>
    <td>newwindow</td>
  </tr>
  <tr>
    <td><dfn attribute for=HTMLControlledFrameElement>onpermissionrequest</dfn></td>
    <td>permissionrequest</td>
  </tr>
  <tr>
    <td><dfn attribute for=HTMLControlledFrameElement>onsizechanged</dfn></td>
    <td>sizechanged</td>
  </tr>
  <tr>
    <td><dfn attribute for=HTMLControlledFrameElement>onzoomchange</dfn></td>
    <td>zoomchange</td>
  </tr>
</table>

The interactive events:

- {{onconsolemessage}}

- {{ondialog}}

- {{onnewwindow}}

- {{onpermissionrequest}}

The UI-change events:

- {{onsizechanged}} - fired when the embedded web content has been resized via autosize. Only fires if autosize is enabled.

- {{onzoomchange}}

The navigation events:

- {{oncontentload}} - fired when the {{Window}} associated with [=embedded navigable=] fires a [=load=] event.

- {{onloadabort}} - fired when navigation has exited before completion.

- {{onloadcommit}} - fired when navigation has been completed.

- {{onloadstart}} - fired when navigation (including reloads and traversals) starts, for every navigable of the embedded document, but not same document navigation.

- {{onloadstop}} - fired when all pending navigations finish(either commit or abort). If a new navigation starts after, loadstop may fire again.

Each {{HTMLControlledFrameElement}} has a <dfn>load counter</dfn> which is a number that is initially zero.

Each time a {{onloadstart}} event fires, [=load counter=] increases by 1.

Each time a {{onloadabort}} event fires, [=load counter=] decreses by 1.

Each time a {{onloadcommit}} event fires, [=load counter=] decreses by 1.

When [=load counter=] changes from a non-zero number to 0, [=fire a "loadstop" event=].

<!-- ====================================================================== -->
### consolemessage ### {#event-consolemessage}
<!-- ====================================================================== -->

<xmp class="idl">

[Exposed=Window, IsolatedContext]
interface ConsoleMessage {
  readonly attribute long level;
  readonly attribute DOMString message;
};

[Exposed=Window, IsolatedContext]
interface ConsoleMessageEvent : Event {
  constructor(DOMString type, optional ConsoleMessageEventInit eventInitDict = {});
  readonly attribute ConsoleMessage consoleMessage;
};

dictionary ConsoleMessageEventInit: EventInit {
  ConsoleMessage? consoleMessage;
};

</xmp>

<div algorithm=dispatch-consolemessage>

To <dfn data-lt='fire a "consolemessage" event'>fire a {{ConsoleMessageEvent}}</dfn> |e| given <{controlledframe}> element |target|, a long |logLevel| and a DOMString |message|, run the following steps:

1. Let |consoleMessage| be a new {{ConsoleMessage}} object.

1. Set the following fields of |consoleMessage|:

      : {{ConsoleMessage/level}}
      :: |logLevel|.

      : {{ConsoleMessage/message}}
      :: |message|.

1. Set |e|'s {{ConsoleMessageEvent/consoleMessage}} to |consoleMessage|.

1. [=Queue a global task=] on the [=DOM manipulation task source=] of
    |target|'s [=relevant global object=] to [=dispatch=] |e| at |target|.

</div>

<!-- ====================================================================== -->
### dialog ### {#event-dialog}
<!-- ====================================================================== -->

<xmp class="idl">

enum DialogType {
  "alert",
  "confirm",
  "prompt"
};

[Exposed=Window, IsolatedContext]
interface DialogController {
  undefined okay(optional DOMString response);
  undefined cancel();
};

[Exposed=Window, IsolatedContext]
interface DialogMessage {
  readonly attribute DialogType messageType;
  readonly attribute DOMString messageText;
  readonly attribute DialogController dialog;
};

[Exposed=Window, IsolatedContext]
interface DialogEvent : Event {
  constructor(DOMString type, optional DialogEventInit eventInitDict = {});
  readonly attribute DialogMessage dialogMessage;
};

dictionary DialogEventInit: EventInit {
  DialogMessage? dialogMessage;
};

</xmp>

Each {{DialogController}} has:

      - A boolean <dfn for=DialogController>accept</dfn>, initially set to `false`.

      - A DOMString <dfn for=DialogController>response</dfn>, initally an empty string.

<div>

The <dfn method for=DialogController>okay(|response|)</dfn> method steps are:

1. Set [=DialogController/accept=] to `true`.

1. Set [=DialogController/response=] to |response|.

</div>

<div>

The <dfn method for=DialogController>cancel()</dfn> method steps are:

1. Set [=DialogController/accept=] to `false`.

</div>

<div algorithm=dispatch-dialog>

To <dfn data-lt='fire a "dialog" event'>fire a {{DialogEvent}}</dfn> |e| given
<{controlledframe}> element |target|, [=simple-dialogs=] type |dialogType|, and
message |message|, run the following steps:

1. Assert that |e|["{{DialogEvent/dialogMessage}}"]["{{DialogMessage/dialog}}"]["[=DialogController/accept=]"] equals `false`.

1. Let |dialogMessage| be a [=new=] {{DialogMessage}} object.

1. Let |dialog| be a [=new=] {{DialogController}} object.

1. Set the following fields of |dialogMessage|:

      : {{DialogMessage/messageType}}
      :: |dialogType|.

      : {{DialogMessage/messageText}}
      :: |message|.

      : {{DialogMessage/dialog}}
      :: |dialog|.

1. Set |e|'s {{DialogEvent/dialogMessage}} to |dialogMessage|.

1. Let |complete| be `false`.

1. [=Queue a global task=] on the [=DOM manipulation task source=] of
    |target|'s [=relevant global object=] to run the following steps:

      1. [=Dispatch=] |e| at |target|.

      1. Set |complete| to `true`.

1. Synchronously wait for |complete| to be `true`.

    Note: Blocking here is intentional as the alert, confirm, and prompt
    dialogs represented by "dialog" events block the main thread, and the event
    handlers we're calling here can affect the return values.

1. Return |e|["{{DialogEvent/dialogMessage}}"]["{{DialogMessage/dialog}}"]["[=DialogController/accept=]"]
    and |e|["{{DialogEvent/dialogMessage}}"]["{{DialogMessage/dialog}}"]["[=DialogController/response=]"].

</div>

<!-- ====================================================================== -->
### newwindow ### {#event-newwindow}
<!-- ====================================================================== -->

<xmp class="idl">

enum WindowOpenDisposition {
  "ignore",
  "save_to_disk",
  "current_tab",
  "new_background_tab",
  "new_foreground_tab",
  "new_window",
  "new_popup"
};

[Exposed=Window, IsolatedContext]
interface NewWindowController {
  undefined attach(HTMLControlledFrameElement newControlledFrame);
  undefined discard();
};

[Exposed=Window, IsolatedContext]
interface NewWindow {
  readonly attribute NewWindowController window;
  readonly attribute USVString targetUrl;
  readonly attribute DOMString name;
  readonly attribute WindowOpenDisposition windowOpenDisposition;
};

[Exposed=Window, IsolatedContext]
interface NewWindowEvent : Event {
  constructor(DOMString type, optional NewWindowEventInit eventInitDict = {});
  readonly attribute NewWindow newWindow;
};

dictionary NewWindowEventInit: EventInit {
  NewWindow? newWindow;
};

</xmp>

Each {{NewWindowController}} has reference to a <dfn for=NewWindowController>
target [=/navigable=]</dfn>, which is initially null.

<div>

The <dfn method for=NewWindowController>attach(|newControlledFrame|)</dfn>
method steps are:

      1. Set |newControlledFrame|'s [=embedded navigable=] to [=this=]'s
          [=NewWindowController/target navigable=].

</div>

<div>

The <dfn method for=NewWindowController>discard()</dfn> method steps are:

1. If [=this=]'s [=NewWindowController/target navigable=] is not null, then
    [=close a top-level traversable=] given [=this=]'s
    [=NewWindowController/target navigable=].

</div>

<div algorithm=dispatch-newwindow>

To <dfn data-lt='fire a "newwindow" event'>fire a {{NewWindowEvent}}</dfn> |e|
given <{controlledframe}> element |controlledFrame|, {{USVString}} |url|,
{{DOMString}} |target|, [=/navigable=] |targetNavigable|, and
{{WindowOpenDisposition}} |windowOpenDisposition|, run the following steps:

1. Let |controller| be a [=new=] {{NewWindowController}} object.

1. Set |controller|'s [=NewWindowController/target navigable=] to
    |targetNavigable|.

1. Let |newWindow| be a [=new=] {{NewWindow}} object.

1. Set the following fields of |newWindow|:

      : {{NewWindow/window}}
      :: |controller|

      : {{NewWindow/targetUrl}}
      :: |url|

      : {{NewWindow/name}}
      :: |target|.

      : {{NewWindow/windowOpenDisposition}}
      :: |windowOpenDisposition|

1. Set |e|'s {{NewWindowEvent/newWindow}} to |newWindow|.

1. [=Queue a global task=] on the [=DOM manipulation task source=] of
    |controlledFrame|'s [=relevant global object=] to [=dispatch=] |e| at
    |controlledFrame|.

</div>

<!-- ====================================================================== -->
### permissionrequest ### {#event-permissionrequest}
<!-- ====================================================================== -->

<xmp class="idl">

enum PermissionType {
  "media",
  "geolocation",
  "pointerLock",
  "download",
  "filesystem",
  "fullscreen",
  "hid",
};

[Exposed=Window, IsolatedContext]
interface PermissionRequestControllerBase {
  undefined allow();
  undefined cancel();
};

[Exposed=Window, IsolatedContext]
interface MediaPermissionRequestController: PermissionRequestControllerBase {
  readonly attribute USVString url;
};

[Exposed=Window, IsolatedContext]
interface GeolocationPermissionRequestController: PermissionRequestControllerBase {
  readonly attribute USVString url;
};

[Exposed=Window, IsolatedContext]
interface PointerLockPermissionRequestController: PermissionRequestControllerBase {
  readonly attribute boolean lastUnlockedBySelf;
  readonly attribute boolean userGesture;
  readonly attribute USVString url;
};

[Exposed=Window, IsolatedContext]
interface DownloadPermissionRequestController : PermissionRequestControllerBase {
  readonly attribute DOMString requestMethod;
  readonly attribute USVString url;
};

[Exposed=Window, IsolatedContext]
interface FileSystemPermissionRequestController : PermissionRequestControllerBase {
  readonly attribute USVString url;
};

[Exposed=Window, IsolatedContext]
interface FullscreenPermissionRequestController : PermissionRequestControllerBase {
  readonly attribute USVString origin;
};

[Exposed=Window, IsolatedContext]
interface HidPermissionRequestController : PermissionRequestControllerBase {
  readonly attribute USVString url;
};

[Exposed=Window, IsolatedContext]
interface PermissionRequest {
  readonly attribute PermissionType permission;
  readonly attribute PermissionRequestControllerBase request;
};

[Exposed=Window, IsolatedContext]
interface PermissionRequestEvent : Event {
  constructor(DOMString type, optional PermissionRequestEventInit eventInitDict = {});
  readonly attribute PermissionRequest permissionRequest;
};

dictionary PermissionRequestEventInit: EventInit {
  PermissionRequest? permissionRequest;
};

</xmp>

Each {{PermissionRequestControllerBase}} has a boolean value <dfn for=PermissionRequestControllerBase>allow</dfn>, which is initially `false`.

<div>

The <dfn method for=PermissionRequestControllerBase>allow()</dfn> method steps are:

1. Set [=PermissionRequestControllerBase/allow=] to `true`.

</div>

<div>

The <dfn method for=PermissionRequestControllerBase>cancel()</dfn> method steps are:

1. Set [=PermissionRequestControllerBase/allow=] to `false`.

</div>

<div algorithm=dispatch-permissionrequest>

To <dfn data-lt='fire a "permissionrequest" event'>fire a
{{PermissionRequestEvent}}</dfn> |e| given a [=/document=] |embeddedDocument|,
<{controlledframe}> element |target|, DOMString |type|, USVString |url|, an
optional dictionary |options|, and an algorithm |completionSteps| that takes
a [=boolean=], run the following steps:

1. Let |permissionRequest| be a [=new=] {{PermissionRequest}} object.

1. If |type| is "media":

    1. Let |requestController| be a [=new=] {{MediaPermissionRequestController}}
        with the following attributes:

          : {{MediaPermissionRequestController/url}}
          :: |url|

1. If |type| is "geolocation":

    1. Let |requestController| be a [=new=]
        {{GeolocationPermissionRequestController}} with the following attributes:

          : {{GeolocationPermissionRequestController/url}}
          :: |url|

1. If |type| is "pointerLock":

    1. Let |requestController| be a [=new=]
        {{PointerLockPermissionRequestController}} with the following attributes:

          : {{PointerLockPermissionRequestController/lastUnlockedBySelf}}
          :: |options|["lastUnlockedBySelf"]

          : {{PointerLockPermissionRequestController/userGesture}}
          :: |options|["userGesture"]

          : {{PointerLockPermissionRequestController/url}}
          :: |url|

1. If |type| is "download":

    1. Let |requestController| be a [=new=]
        {{DownloadPermissionRequestController}} with the following attributes:

          : {{DownloadPermissionRequestController/requestMethod}}
          :: |options|["requestMethod"]

          : {{DownloadPermissionRequestController/url}}
          :: |url|

1. If |type| is "filesystem":

    1. Let |requestController| be a [=new=]
        {{FileSystemPermissionRequestController}} with the following attributes:

          : {{FileSystemPermissionRequestController/url}}
          :: |url|

1. If |type| is "fullscreen":

    1. Let |requestController| be a [=new=]
        {{FullscreenPermissionRequestController}} with the following attributes:

          : {{FullscreenPermissionRequestController/origin}}
          :: origin of |url|

1. If |type| is "hid":

    1. Let |requestController| be a [=new=] {{HidPermissionRequestController}}
        with the following attributes:

          : {{HidPermissionRequestController/url}}
          :: |url|

1. Set the following fields of |permissionRequest|:

      : {{PermissionRequest/request}}
      :: |requestController|

      : {{PermissionRequest/permission}}
      :: |type|.

1. Set |e|'s {{PermissionRequestEvent/permissionRequest}} to |permissionRequest|.

1. [=Queue a global task=] on the [=DOM manipulation task source=] of
    |target|'s [=relevant global object=] to run the following steps:

      1. [=Dispatch=] |e| at |target|.

      1. [=Queue a global task=] on the [=DOM manipulation task source=] of
          |embeddedDocument|'s [=relevant global object=] that runs
          |completionSteps| with |e|["{{PermissionRequestEvent/permissionRequest}}"]["{{PermissionRequest/permission}}"]["[=PermissionRequestControllerBase/allow=]"].

</div>

<!-- ====================================================================== -->
### sizechanged ### {#event-sizechanged}
<!-- ====================================================================== -->

<xmp class="idl">

[Exposed=Window, IsolatedContext]
interface SizeChange {
  readonly attribute unsigned long oldWidth;
  readonly attribute unsigned long oldHeight;
  readonly attribute unsigned long newWidth;
  readonly attribute unsigned long newHeight;
};

[Exposed=Window, IsolatedContext]
interface SizeChangedEvent : Event {
  constructor(DOMString type, optional SizeChangedEventInit eventInitDict = {});
  readonly attribute SizeChange sizeChange;
};

dictionary SizeChangedEventInit: EventInit {
  SizeChange? sizeChange;
};

</xmp>

<div algorithm=dispatch-sizechanged>

To fire a {{SizeChangedEvent}} |e| given <{controlledframe}> element |target|, 4 non-negative numbers |oldWidth|, |oldHeight|, |newWidth|, |newHeight|:

1. Let |sizeChange| be a [=new=] {{SizeChange}} object.

1. Set the following fields of |sizeChange|:

      : {{SizeChange/oldWidth}}
      :: |oldWidth|.

      : {{SizeChange/oldHeight}}
      :: |oldHeight|.

      : {{SizeChange/newWidth}}
      :: |newWidth|.

      : {{SizeChange/newHeight}}
      :: |newHeight|.

1. Set |e|'s {{SizeChangedEvent/sizeChange}} to |sizeChange|.

1. [=Queue a global task=] on the [=DOM manipulation task source=] of
    |target|'s [=relevant global object=] to [=dispatch=] |e| at |target|.

</div>

<!-- ====================================================================== -->
### zoomchange ### {#event-zoomchange}
<!-- ====================================================================== -->

<xmp class="idl">

[Exposed=Window, IsolatedContext]
interface ZoomChange {
  readonly attribute float oldZoomFactor;
  readonly attribute float newZoomFactor;
};

[Exposed=Window, IsolatedContext]
interface ZoomChangeEvent : Event {
  constructor(DOMString type, optional ZoomChangeEventInit eventInitDict = {});
  readonly attribute ZoomChange zoomChange;
};

dictionary ZoomChangeEventInit: EventInit {
  ZoomChange? zoomChange;
};

</xmp>

<div algorithm=dispatch-zoomchange>

To <dfn data-lt='Fire a "zoomchange" event'>fire a {{ZoomChangeEvent}}</dfn> |e| given <{controlledframe}> element |target|, 2 [=float=] numbers |oldZoomFactor|, |newZoomFactor|:

1. Let |zoomChange| be a [=new=] {{ZoomChange}} object.

1. Set the following fields of |zoomChange|:

      : {{ZoomChange/oldZoomFactor}}
      :: |oldZoomFactor|.

      : {{ZoomChange/newZoomFactor}}
      :: |newZoomFactor|.

1. Set |e|'s {{ZoomChangeEvent/zoomChange}} to |zoomChange|.

1. [=Queue a global task=] on the [=DOM manipulation task source=] of
    |target|'s [=relevant global object=] to [=dispatch=] |e| at |target|.

</div>

<!-- ====================================================================== -->
### contentload ### {#event-contentload}
<!-- ====================================================================== -->

<xmp class="idl">

[Exposed=Window, IsolatedContext]
interface ContentLoadEvent : Event {
  constructor(DOMString type, optional EventInit eventInitDict = {});
};

</xmp>

<div algorithm=dispatch-contentload>

To <dfn data-lt='fire a "contentload" event'>fire a {{ContentLoadEvent}}</dfn>
|e| given <{controlledframe}> element |target|, run the following steps:

1. [=Queue a global task=] on the [=DOM manipulation task source=] of
    |target|'s [=relevant global object=] to [=dispatch=] |e| at |target|.

</div>

<!-- ====================================================================== -->
### loadabort ### {#event-loadabort}
<!-- ====================================================================== -->

<xmp class="idl">

[Exposed=Window, IsolatedContext]
interface LoadInfo {
  readonly attribute USVString url;
  readonly attribute boolean isTopLevel;
};

[Exposed=Window, IsolatedContext]
interface LoadAbortInfo : LoadInfo{
  readonly attribute long code;
  readonly attribute DOMString reason;
};

[Exposed=Window, IsolatedContext]
interface LoadRedirectInfo{
  readonly attribute USVString oldUrl;
  readonly attribute USVString newUrl;
  readonly attribute boolean isTopLevel;
};

[Exposed=Window, IsolatedContext]
interface LoadAbortEvent : Event {
  constructor(DOMString type, optional LoadAbortEventInit eventInitDict = {});
  readonly attribute LoadAbortInfo loadAbortInfo;
};

dictionary LoadAbortEventInit: EventInit {
  LoadAbortInfo? loadAbortInfo;
};

</xmp>

<div algorithm=dispatch-loadabort>

To fire a {{LoadAbortEvent}} |e| given <{controlledframe}> element |target|,
a USVString |url|, a boolean |isTopLevel|, a long |code|, and a DOMString
|reason|, run the following steps:

1. Let |info| be a [=new=] {{LoadAbortInfo}} with the following attributes:

      : {{LoadInfo/url}}
      :: |url|

      : {{LoadInfo/isTopLevel}}
      :: |isTopLevel|

      : {{LoadAbortInfo/code}}
      :: |code|

      : {{LoadAbortInfo/reason}}
      :: |reason|

1. Set |e|'s {{LoadAbortEvent/loadAbortInfo}} to |info|.

1. [=Queue a global task=] on the [=DOM manipulation task source=] of
    |target|'s [=relevant global object=] to [=dispatch=] |e| at |target|.

</div>

<!-- ====================================================================== -->
### loadcommit ### {#event-loadcommit}
<!-- ====================================================================== -->

<xmp class="idl">

[Exposed=Window, IsolatedContext]
interface LoadCommitEvent : Event {
  constructor(DOMString type, optional LoadCommitEventInit eventInitDict = {});
  readonly attribute LoadInfo loadInfo;
};

dictionary LoadCommitEventInit: EventInit {
  LoadInfo? loadInfo;
};

</xmp>

<div algorithm=dispatch-loadcommit>

To fire a {{LoadCommitEvent}} |e| given <{controlledframe}> element |target|,
a USVString |url|, and a boolean |isTopLevel|, run the following steps:

1. Let |info| be a [=new=] {{LoadInfo}} with the following attributes:

      : {{LoadInfo/url}}
      :: |url|

      : {{LoadInfo/isTopLevel}}
      :: |isTopLevel|

1. Set |e|'s {{LoadCommitEvent/loadInfo}} to |info|.

1. [=Queue a global task=] on the [=DOM manipulation task source=] of
    |target|'s [=relevant global object=] to [=dispatch=] |e| at |target|.

</div>

<!-- ====================================================================== -->
### loadstart ### {#event-loadstart}
<!-- ====================================================================== -->

<xmp class="idl">

[Exposed=Window, IsolatedContext]
interface LoadStartEvent : Event {
  constructor(DOMString type, optional LoadStartEventInit eventInitDict = {});
  readonly attribute LoadInfo loadInfo;
};

dictionary LoadStartEventInit: EventInit {
  LoadInfo? loadInfo;
};

</xmp>

<div algorithm=dispatch-loadstart>

To fire a {{LoadStartEvent}} |e| given <{controlledframe}> element |target|,
a USVString |url|, and a boolean |isTopLevel|, run the following steps:

1. Let |info| be a [=new=] {{LoadInfo}} with the following attributes:

      : {{LoadInfo/url}}
      :: |url|

      : {{LoadInfo/isTopLevel}}
      :: |isTopLevel|

1. Set |e|'s {{LoadStartEvent/loadInfo}} to |info|.

1. [=Queue a global task=] on the [=DOM manipulation task source=] of
    |target|'s [=relevant global object=] to [=dispatch=] |e| at |target|.

</div>

<!-- ====================================================================== -->
### loadstop ### {#event-loadstop}
<!-- ====================================================================== -->

<xmp class="idl">

[Exposed=Window, IsolatedContext]
interface LoadStopEvent : Event {
  constructor(DOMString type, optional LoadStopEventInit eventInitDict = {});
};

dictionary LoadStopEventInit: EventInit {
};

</xmp>

<div algorithm=dispatch-loadstop>

To <dfn data-lt='fire a "loadstop" event'>fire a {{LoadStopEvent}}</dfn> |e|
given <{controlledframe}> element |target|, run the following steps:

1. [=Queue a global task=] on the [=DOM manipulation task source=] of
    |target|'s [=relevant global object=] to [=dispatch=] |e| at |target|.

</div>

<!-- ====================================================================== -->
### loadredirect ### {#event-loadredirect}
<!-- ====================================================================== -->

<xmp class="idl">

[Exposed=Window, IsolatedContext]
interface LoadRedirectEvent : Event {
  constructor(DOMString type, optional LoadRedirectEventInit eventInitDict = {});
  readonly attribute LoadRedirectInfo loadRedirectInfo;
};

dictionary LoadRedirectEventInit: EventInit {
  LoadRedirectInfo? loadRedirectInfo;
};

</xmp>

<div algorithm=dispatch-loadredirect>

To <dfn data-lt='fire a "loadredirect" event'>fire a {{LoadRedirectEvent}}</dfn>
|e| given <{controlledframe}> element |target|, an [=/URL=] |oldUrl|, an
[=/URL=] |newUrl|, and a boolean |isTopLevel|, run the following steps:

1. Let |info| be a [=new=] {{LoadInfo}} with the following attributes:

      : {{LoadRedirectInfo/oldUrl}}
      :: The result of [=serializing an URL=] given |oldUrl|

      : {{LoadRedirectInfo/newUrl}}
      :: The result of [=serializing an URL=] given |newUrl|

      : {{LoadRedirectInfo/isTopLevel}}
      :: |isTopLevel|

1. Set |e|'s {{LoadRedirectEvent/loadRedirectInfo}} to |info|.

1. [=Queue a global task=] on the [=DOM manipulation task source=] of
    |target|'s [=relevant global object=] to [=dispatch=] |e| at |target|.

</div>

<!-- ====================================================================== -->
### Monkey Patches ### {#events-monkey-patches}
<!-- ====================================================================== -->

#### [[HTML]] #### {#events-monkey-patches-html}

For [=alert=]:

4. Set |message| to the result of optionally truncating message.

5. <ins>Let |controlledFrameEmbedderParent| be <var ignore=''>window</var>'s
    [=Window/navigable=]'s [=controlledFrameEmbedderParent=].</ins>.

6. <ins>If |controlledFrameEmbedderParent| is a {{HTMLControlledFrameElement}}, then
    [=fire a "dialog" event=] with |controlledFrameEmbedderParent|, "alert" and |message|,
    and return.</ins>

For [=confirm=]:

3. Set |message| to the result of optionally truncating message.

4. <ins>Let |controlledFrameEmbedderParent| be <var ignore=''>window</var>'s
    [=Window/navigable=]'s [=controlledFrameEmbedderParent=].</ins>.

5. <ins>If |controlledFrameEmbedderParent| is a {{HTMLControlledFrameElement}}, then return
    the result of [=firing a "dialog" event=] with |controlledFrameEmbedderParent|, "confirm",
    and |message|.</ins>

For [=prompt=]:

4. Set <var ignore=''>default</var> to the result of optionally truncating default.

5. <ins>Let |controlledFrameEmbedderParent| be <var ignore=''>window</var>'s [=Window/navigable=]'s [=controlledFrameEmbedderParent=].</ins>.

6. <ins>If |controlledFrameEmbedderParent| is a {{HTMLControlledFrameElement}}, then:</ins>

      1. <ins>Let |accept| and |response| be the results of [=firing a "dialog"
          event=] with |controlledFrameEmbedderParent|, "prompt" and |message|.</ins>

      1. <ins>If |accept| equals `false`, return null.</ins>

      1. <ins>Return |response|.</ins>

For [=window open steps=]:

1. <ins>Let |windowOpenDisposition| be "{{WindowOpenDisposition/ignore}}".</ins>

2. <ins>Let |controlledFrameEmbedderParent| be <var ignore=''>sourceDocument</var>'s [=node
    navigable=]'s [=controlledFrameEmbedderParent=].</ins>

...

<del>14. If |targetNavigable| is null, then return null.</del>

14. <ins>If |targetNavigable| is null:</ins>

      1. <ins>If |controlledFrameEmbedderParent| is not null:</ins>

            1. <ins>[=Fire a "newwindow" event=] with |controlledFrameEmbedderParent|, |url|,
                |target|, |targetNavigable|, and |windowOpenDisposition|.</ins>

      1. <ins>Return null.<ins>

15. If windowType is either "new and unrestricted" or "new with no opener",
    then:

      1. <ins>Set |windowOpenDisposition| to one of
          "{{WindowOpenDisposition/new_background_tab}}",
          "{{WindowOpenDisposition/new_foreground_tab}}",
          or "{{WindowOpenDisposition/new_window}}".</ins>

      Note: The value depends on the behavior support of the user agent and user
          settings.

      1. Set |targetNavigable|'s active browsing context's is popup to the
          result of checking if a popup window is requested, given
          tokenizedFeatures.

      1. <ins>If |targetNavigable|'s [=active browsing context=]'s [=is popup=]
          is `true`, set |windowOpenDisposition| to
          "{{WindowOpenDisposition/new_popup}}".</ins>

      ...

16. Otherwise:

      1. <ins>Set |windowOpenDisposition| to
          "{{WindowOpenDisposition/current_tab}}".</ins>

      ...

Note: Step 15 and 16 also [=/navigate=] |targetNavigable|; during navigation,
    |windowOpenDisposition| may also be updated. For example, if navigation is
    prevented, |windowOpenDisposition| may be set to
    "{{WindowOpenDisposition/ignore}}". If the navigation response resulted in
    download, then |windowOpenDisposition| may be set to
    "{{WindowOpenDisposition/save_to_disk}}".

1. <ins>If |controlledFrameEmbedderParent| is not null:</ins>

       1. <ins>[=Fire a "newwindow" event=] with |controlledFrameEmbedderParent|, |url|,
           |target|, |targetNavigable|, and |windowOpenDisposition|.</ins>


For [=completely finish loading=]:

5. Otherwise, if container is non-null, then queue an element task on the DOM manipulation task source given container to fire an event named load at container.

6. <ins>Let |controlledFrameEmbedderParent| be <var ignore=''>document</var>'s [=node navigable=]'s [=controlledFrameEmbedderParent=].

7. <ins> If |controlledFrameEmbedderParent| is {{HTMLControlledFrameElement}}, then [=Fire a "contentload" event=] with |controlledFrameEmbedderParent|.</ins>

<div style="border: 2px solid red;">

Monkey-patch for loadstart, loadabort, and loadcommit which looks like the following:

1. loadstart -> at the navigation entry points: normal navigation, reloads, traversal.

1. loadcommit -> at the common navigation completion point.

1. loadabort -> at each early exist points of the algorithm between loadstart and loadcommit.

For each of these, check whether the [=top-level traversable=] of the [=/navigable=] has an [=controlledFrameEmbedderParent=] of {{HTMLControlledFrameElement}}, if so, then fire the corresponding event with input arguments.

</div>

#### [[FETCH]] #### {#events-monkey-patches-redirect}

For [=HTTP fetch=](loadredirect):

6. If internalResponse’s status is a redirect status:

      1. <ins>If |request|'s [=request/window=] |window| is a [=environment settings object=] whose [=global object=] is a {{Window}} object:</ins>

            1. <ins>Let |currentNavigable| be |window|'s associated [=Window/navigable=].

            1. <ins>Let |controlledFrameEmbedderParent| be |currentNavigable|'s [=top-level traversable=]'s [=controlledFrameEmbedderParent=].</ins>

            1. <ins>If |controlledFrameEmbedderParent| is a {{HTMLControlledFrameElement}}:</ins>

                  1.<ins>Let |oldUrl| be |request|'s associated [=request/URL=].</ins>

                  1.<ins>Let |newUrl| be |response|'s [=response/location url=].</ins>

                  1.<ins>Let |isTopLevel| be `false`, if |currentNavigable| has a null [=navigable/parent=] set |isTopLevel| to `true`.

                  1.<ins>[=Fire a "loadredirect" event=] with |controlledFrameEmbedderParent|, |oldUrl|, |newUrl|, and |isTopLevel|.</ins>

#### [[Permissions]] #### {#events-monkey-patches-permissions}

Define new algorithm:

<div algorithm>

To determine if a [=/Document=] |document| is
<dfn data-lt='allowed by embedder to use'>allowed by embedder to use a
permission</dfn> given DOMString |permission|, an optional dictionary
|options|, and an algorithm |completionSteps| that takes a [=boolean=],
run the following steps:

1. Let |controlledFrameEmbedderParent| be |document|'s [=node navigable=]'s [=controlledFrameEmbedderParent=].

1. If |controlledFrameEmbedderParent| is not {{HTMLControlledFrameElement}}, return `true`.

1. [=Fire a "permissionrequest" event=] with |document|,
    |controlledFrameEmbedderParent|, |permission|, |document|'s [=Document/URL=], |options|, and
    |completionSteps|.

</div>

For [=request a position=] (geolocation):

3. If |document| is not allowed to use the "geolocation" feature:

      1. If watchId was passed, remove watchId from watchIDs.

      2. Call back with error passing errorCallback and PERMISSION_DENIED.

      3. Terminate this algorithm.

4. <ins>Let |blockedByEmbedder| be `false`.</ins>

5. <ins>Check if |document| is [=allowed by embedder to use=] the "geolocation"
    feature given an algorithm that assigns its [=boolean=] argument to
    |blockedByEmbedder| and continues with the remainder of these steps.</ins>

6. <ins>If |blockedByEmbedder| is `true`, then:</ins>

      1. <ins>If watchId was passed, remove watchId from watchIDs.</ins>

      1. <ins>Call back with error passing errorCallback and PERMISSION_DENIED.</ins>

      1. <ins>Terminate this algorithm.</ins>

7. <ins>Let |controlledFrameEmbedderParent| be |document|'s [=node navigable=]'s [=controlledFrameEmbedderParent=].</ins>

8. <ins>If |controlledFrameEmbedderParent| is {{HTMLControlledFrameElement}}:</ins>

      1. Let |nodeDocument| be |controlledFrameEmbedderParent|'s [=node document=].

      1. <ins>If |nodeDocument| is null:</ins>

            1. <ins>If watchId was passed, remove watchId from watchIDs.</ins>

            1. <ins>Call back with error passing errorCallback and PERMISSION_DENIED.</ins>

            1. <ins>Terminate this algorithm.</ins>

      1. <ins>Let |embedderNavigator| be the [=associated Navigator=] of |nodeDocument|'s [=global object=].

      1. <ins>Let |embedderGeolocation| be the {{Navigator/geolocation}} of |embedderNavigator|.

      1. <ins>Return the result of [=request a position=] with |embedderGeolocation|, <var ignore=''>successCallback</var>, <var ignore=''>errorCallback</var>, <var ignore=''>options</var>, and <var ignore=''>whatchId</var>.</ins>

Note: Other permissions will be monkey-patched similarly to geolocation. But the
    details are elided in this document for brevity.

#### [[Console]] #### {#events-monkey-patches-console}

For [=Logger=]:

1. Otherwise, perform Printer(|logLevel|, [=Formatter=](|args|)).

1. <ins>[=Fire a "consolemessage" event=] with |logLevel|, [=Formatter=](|args|).</ins>

Note: Console by default does not have association with document so we cannot track the associated {{HTMLControlledFrameElement}}.

<!-- ====================================================================== -->
## Integration with other specifications ## {#api-integration-with-other-specifications}
<!-- ====================================================================== -->

This specification will make some modifications to specifications to accommodate
the needs of Controlled Frame.

<!-- ====================================================================== -->
### Monkey Patches ### {#api-monkey-patches}
<!-- ====================================================================== -->

#### [[HTML]] #### {#api-monkey-patches-html}

Each [=/navigable=] has:
 * A <dfn for=navigable>frameId</dfn> integer, initially 0.
 * A <dfn for=navigable>next frameId</dfn> integer, initially 1.
 * An <dfn for=navigable>controlledFrameEmbedderParent</dfn>, an
    {{HTMLControlledFrameElement}} or null.

The [=initialize the navigable=] algorithm given a [=/navigable=] |navigable|
and an optional [=/navigable=]-or-null |parent| (default null) is
monkey patched as follows:

 5. Set |navigable|'s [=navigable/parent=] to |parent|.

 6. <ins>If |parent| is not null (|navigable| is not a
    [=top-level traversable=]), then:</ins>

    1. <ins>Let |topLevelTraversable| be the [=top-level traversable=] that
        |navigable| is a descendant of.</ins>

    1. <ins>Set |navigable|'s [=navigable/frameId=] to |topLevelTraversable|'s
        [=navigable/next frameId=].</ins>

    1. <ins>Increment |topLevelTraversable|'s [=navigable/next frameId=].</ins>

The [=update the current document readiness=] for {{Document}} |document| to
|readinessValue| algorithm is monkey patched as follows:

  4. <ins>Let |runAt| be the result of applying the following mapping to
      |readinessValue|:

      : "`loading`"
      :: "{{RunAt/document-start}}"
      : "`interactive`"
      :: "{{RunAt/document-end}}"
      : "`complete`"
      :: "{{RunAt/document-idle}}"</ins>

  5. <ins>[=Inject content scripts into a document=] given |document| and
      |runAt|.</ins>

  6. [=Fire an event=] named {{readystatechange}} at |document|.

#### [[FETCH]] #### {#api-monkey-patches-fetch}

The [=determine the network partition key=] algorithm is monkey extended to
require double-keying on network requests originating from a Controlled Frame's
[=embedded navigable=].

<div algorithm="determine the network partition key controlled frame">
To determine the network partition key, given an [=environment=] |environment|:

  4. Let |topLevelSite| be the result of [=obtaining a site=], given
      topLevelOrigin.

  5. Let |secondKey| be null <del>or an [=implementation-defined=] value</del>.

  6. <ins>Let |controlledFrameEmbedderParent| be the result of [=getting an environment's
      controlledFrameEmbedderParent=] given |environment|.</ins>

  7. <ins>If |controlledFrameEmbedderParent| is not null, then set |secondKey| to a [=tuple=]
      consisting of the [=environment/top-level origin=] of |controlledFrameEmbedderParent|'s
      [=relevant settings object=], and |controlledFrameEmbedderParent|'s
      {{HTMLControlledFrameElement/partition}}.</ins>

  8. Return (|topLevelSite|, |secondKey|).

</div>

#### [[STORAGE]] #### {#api-monkey-patches-storage}

Storage keys are re-defined as follows:

A <dfn>storage key</dfn> is a [=tuple=] consisting of an
<dfn for="storage key">embedding origin</dfn> (an [=/origin=] or null), a
<dfn for="storage key">partition</dfn> (a {{DOMString}} or null), and an
<dfn for="storage key">origin</dfn> (an [=/origin=]).

Note: This definition will need to be expanded to include the embedded content's
top-level origin in addition to [=storage key/origin=] in the future once
storage partitioning is fully specified.

Note: Controlled Frame data is triple keyed with the origin of the document that
owns the Controlled Frame element, not the top-level document that owns it.

The [=obtain a storage key for non-storage purposes=] algorithm is extended to
require double-keying on all storage belonging to a <{controlledframe}>'s
[=embedded navigable=].

<div algorithm="obtain a storage key for non-storage purposes controlled frame">
To <dfn data-lt='obtain a Controlled Frame storage key'>obtain a storage key for non-storage purposes</dfn>, given an [=environment=]
|environment|, run these steps:

  1. Let |origin| be |environment|'s [=environment settings object/origin=] if
      |environment| is an [=environment settings object=]; otherwise
      |environment|'s [=creation URL=]'s [=/origin=].

  1. <del>Return a [=tuple=] consisting of |origin|.</del>

  1. <ins>Let |topLevelOrigin| and |partition| be null.</ins>

  1. <ins>Let |controlledFrameEmbedderParent| be the result of [=getting an environment's
      controlledFrameEmbedderParent=] given |environment|.</ins>

  1. <ins>If |controlledFrameEmbedderParent| is not null, then:</ins>

      1. <ins>Set |topLevelOrigin| to the [=environment/top-level origin=] of
          |controlledFrameEmbedderParent|'s [=relevant settings object=].</ins>

      1. <ins>Set |partition| to |controlledFrameEmbedderParent|'s
          {{HTMLControlledFrameElement/partition}}.</ins>

  1. <ins>Return a [=tuple=] consisting of |topLevelOrigin|, |partition|,
       and |origin|.</ins>

</div>

<div algorithm>
To <dfn>get an [=environment=]'s [=controlledFrameEmbedderParent=]</dfn> given
an [=environment=] |environment|, run the following steps:

  1. If |environment| is an [=environment settings object=] whose
      [=global object=] is a {{Window}} object, then:

      Issue: This algorithm doesn't work for Shared or Service Workers because
      [=controlledFrameEmbedderParent=] is only defined on a [=/navigable=], and
      it's not always possible to go from a non-{{Window}} [=environment=] to a
      [=/navigable=].

      1. Let |navigable| be |environment|'s [=global object=]'s
          [=Window/navigable=].

      1. Let |top| be the [=top-level traversable=] of |navigable|.

      1. If |top|'s [=controlledFrameEmbedderParent=] is not null, then return |top|'s
          [=controlledFrameEmbedderParent=].

  1. Return null.

</div>


<!-- ====================================================================== -->
# Web Request API # {#api-web-request}
<!-- ====================================================================== -->

<xmp class="idl">
enum ResourceType {
  "main-frame",
  "sub-frame",
  "stylesheet",
  "script",
  "image",
  "font",
  "object",
  "xmlhttprequest",
  "ping",
  "csp-report",
  "media",
  "websocket",
  "other",
};

enum RequestedHeaders {
  "none",
  "cors",
  "all",
};

dictionary WebRequestInterceptorOptions {
  required sequence<(URLPattern or URLPatternInput)> urlPatterns;
  sequence<ResourceType> resourceTypes = [];
  boolean blocking = false;
  boolean includeRequestBody = false;
  RequestedHeaders includeHeaders = "none";
};

[Exposed=Window, IsolatedContext]
interface WebRequest {
  WebRequestInterceptor createWebRequestInterceptor(
      WebRequestInterceptorOptions options);

  Promise<undefined> interceptorBehaviorChanged();
};

[Exposed=Window, IsolatedContext]
interface WebRequestInterceptor : EventTarget {
  attribute EventHandler onauthrequired;
  attribute EventHandler onbeforeredirect;
  attribute EventHandler onbeforerequest;
  attribute EventHandler onbeforesendheaders;
  attribute EventHandler oncompleted;
  attribute EventHandler onerroroccurred;
  attribute EventHandler onheadersreceived;
  attribute EventHandler onsendheaders;
  attribute EventHandler onresponsestarted;
};

enum DocumentLifecycle {
  "prerender",
  "active",
  "cached",
  "pending-deletion",
};

enum FrameType {
  "outermost-frame",
  "fenced-frame",
  "sub-frame",
};

[Exposed=Window, IsolatedContext]
interface UploadData {
  readonly attribute ArrayBuffer? bytes;
  readonly attribute DOMString? file;
};

[Exposed=Window, IsolatedContext]
interface RequestBody {
  readonly attribute DOMString? error;
  readonly attribute any formData;
  readonly attribute FrozenArray<UploadData>? raw;
};

[Exposed=Window, IsolatedContext]
interface WebRequestRequest {
  readonly attribute DOMString method;
  readonly attribute DOMString id;
  readonly attribute ResourceType type;
  readonly attribute USVString url;
  readonly attribute USVString? initiator;
  readonly attribute Headers? headers;
  readonly attribute RequestBody? body;
};

[Exposed=Window, IsolatedContext]
interface AuthChallenger {
  readonly attribute DOMString host;
  readonly attribute long port;
};

[Exposed=Window, IsolatedContext]
interface WebRequestAuthDetails {
  readonly attribute AuthChallenger challenger;
  readonly attribute boolean isProxy;
  readonly attribute DOMString scheme;
  readonly attribute DOMString? realm;
};

[Exposed=Window, IsolatedContext]
interface WebRequestResponse {
  readonly attribute long statusCode;
  readonly attribute DOMString statusLine;
  readonly attribute boolean fromCache;
  readonly attribute Headers? headers;
  readonly attribute DOMString? ip;
  readonly attribute USVString? redirectURL;
  readonly attribute WebRequestAuthDetails? auth;
};

[Exposed=Window, IsolatedContext]
interface WebRequestEvent : Event {
  readonly attribute WebRequestRequest request;
  readonly attribute long frameId;
  readonly attribute FrameType? frameType;
  readonly attribute DOMString? documentId;
  readonly attribute DocumentLifecycle? documentLifecycle;
  readonly attribute DOMString? parentDocumentId;
  readonly attribute long? parentFrameId;
};

dictionary WebRequestAuthCredentials {
  required DOMString username;
  required DOMString password;
};

dictionary WebRequestAuthOptions {
  AbortSignal signal;
};

[Exposed=Window, IsolatedContext]
interface WebRequestAuthRequiredEvent : WebRequestEvent {
  readonly attribute WebRequestResponse response;

  undefined setCredentials(
    Promise<WebRequestAuthCredentials> credentials,
    optional WebRequestAuthOptions options = {});
};

[Exposed=Window, IsolatedContext]
interface WebRequestBeforeRedirectEvent : WebRequestEvent {
  readonly attribute WebRequestResponse response;
};

[Exposed=Window, IsolatedContext]
interface WebRequestBeforeRequestEvent : WebRequestEvent {
  undefined redirect(USVString redirectURL);
};

[Exposed=Window, IsolatedContext]
interface WebRequestBeforeSendHeadersEvent : WebRequestEvent {
  undefined setRequestHeaders((Headers or HeadersInit) requestHeaders);
};

[Exposed=Window, IsolatedContext]
interface WebRequestCompletedEvent : WebRequestEvent {
  readonly attribute WebRequestResponse response;
};

[Exposed=Window, IsolatedContext]
interface WebRequestErrorOccurredEvent : WebRequestEvent {
  readonly attribute DOMString error;
};

[Exposed=Window, IsolatedContext]
interface WebRequestHeadersReceivedEvent : WebRequestEvent {
  readonly attribute WebRequestResponse response;

  undefined redirect(USVString redirectURL);
  undefined setResponseHeaders((Headers or HeadersInit) responseHeaders);
};

[Exposed=Window, IsolatedContext]
interface WebRequestResponseStartedEvent : WebRequestEvent {
  readonly attribute WebRequestResponse response;
};

[Exposed=Window, IsolatedContext]
interface WebRequestSendHeadersEvent : WebRequestEvent {};
</xmp>

Each {{WebRequest}} has an associated:
 * <dfn for=WebRequest>interceptors</dfn>, which is a [=list=] of
    {{WebRequestInterceptor}}s, intially «».

Note: [=WebRequest/Interceptors=] will be written to from tasks
    on the <{controlledframe}> element's event loop, but read [=in parallel=]
    during [=fetch=].
    <br><br>
    A snapshot of [=applicable WebRequestInterceptors=] will be created prior
    to dispatching <a href="#api-web-request-events">WebRequest events</a>.
    Event listeners registered on a {{WebRequestInterceptor}} while processing
    an event will not be fired for that event.

Each {{WebRequestInterceptor}} has an associated:
  <div dfn-for=WebRequestInterceptor>
    * <dfn>urlPatterns</dfn>, which is a [=list=] of {{URLPattern}}s.
    * <dfn>resourceTypes</dfn>, which is a [=list=] of {{ResourceType}}s.
    * <dfn>blocking</dfn>, which is a [=boolean=].
    * <dfn>includeRequestBody</dfn>, which is a [=boolean=].
    * <dfn>includeHeaders</dfn>, which is a {{RequestedHeaders}}.
  </div>

Each {{UploadData}} has an associated:
  <div dfn-for=UploadData>
    * <dfn>bytes</dfn>, which is an {{ArrayBuffer}} or null, initially null.

        The <dfn attribute>bytes</dfn> getter steps are
        to return [=this=]'s [=UploadData/bytes=].

    * <dfn>file</dfn>, which is a {{DOMString}} or null, initially null.

        The <dfn attribute>file</dfn> getter steps are
        to return [=this=]'s [=UploadData/file=].
  </div>

Each {{RequestBody}} has an associated:
  <div dfn-for=RequestBody>
    * <dfn>error</dfn>, which is a {{DOMString}} or null, initially null.

        The <dfn attribute>error</dfn> getter steps are
        to return [=this=]'s [=RequestBody/error=].

    * <dfn>formData</dfn>, which is an {{Object}} or null, initially null.

        The <dfn attribute>formData</dfn> getter steps are
        to return [=this=]'s [=RequestBody/formData=].

    * <dfn>raw</dfn>, which is a [=list=] of {{UploadData}}s or null, initially
        null.

        The <dfn attribute>raw</dfn> getter steps are
        to return [=this=]'s [=RequestBody/raw=].
  </div>

Each {{WebRequestRequest}} has an associated:
  <div dfn-for=WebRequestRequest>
    * <dfn>method</dfn>, which is a {{DOMString}}.

        The <dfn attribute>method</dfn> getter steps are
        to return [=this=]'s [=WebRequestRequest/method=].

    * <dfn>id</dfn>, which is a {{DOMString}}.

        The <dfn attribute>id</dfn> getter steps are
        to return [=this=]'s [=WebRequestRequest/id=].

    * <dfn>type</dfn>, which is a {{ResourceType}}.

        The <dfn attribute>type</dfn> getter steps are
        to return [=this=]'s [=WebRequestRequest/type=].

    * <dfn>url</dfn>, which is a {{USVString}}.

        The <dfn attribute>url</dfn> getter steps are
        to return [=this=]'s [=WebRequestRequest/url=].

    * <dfn>initiator</dfn>, which is a {{USVString}} or null.

        The <dfn attribute>initiator</dfn> getter steps are
        to return [=this=]'s [=WebRequestRequest/initiator=].

    * <dfn>headers</dfn>, which is a {{Headers}} or null, initially null.

        The <dfn attribute>headers</dfn> getter steps are
        to return [=this=]'s [=WebRequestRequest/headers=].

    * <dfn>body</dfn>, which is a {{RequestBody}} or null, initially null.

        The <dfn attribute>body</dfn> getter steps are
        to return [=this=]'s [=WebRequestRequest/body=].
  </div>

Each {{AuthChallenger}} has an associated:
  <div dfn-for=AuthChallenger>
    * <dfn>host</dfn>, which is a {{DOMString}}.

        The <dfn attribute>host</dfn> getter steps are
        to return [=this=]'s [=AuthChallenger/host=].

    * <dfn>port</dfn>, which is a {{long}}.

        The <dfn attribute>port</dfn> getter steps are
        to return [=this=]'s [=AuthChallenger/port=].
  </div>

Each {{WebRequestAuthDetails}} has an associated:
  <div dfn-for=WebRequestAuthDetails>
    * <dfn>challenger</dfn>, which is an {{AuthChallenger}}.

        The <dfn attribute>challenger</dfn> getter steps are
        to return [=this=]'s [=WebRequestAuthDetails/challenger=].

    * <dfn>isProxy</dfn>, which is a [=boolean=].

        The <dfn attribute>isProxy</dfn> getter steps are
        to return [=this=]'s [=WebRequestAuthDetails/isProxy=].

    * <dfn>scheme</dfn>, which is a {{DOMString}}.

        The <dfn attribute>scheme</dfn> getter steps are
        to return [=this=]'s [=WebRequestAuthDetails/scheme=].

    * <dfn>realm</dfn>, which is a {{DOMString}} or null.

        The <dfn attribute>realm</dfn> getter steps are
        to return [=this=]'s [=WebRequestAuthDetails/realm=].
  </div>

Each {{WebRequestResponse}} has an associated:
  <div dfn-for=WebRequestResponse>
    * <dfn>statusCode</dfn>, which is a {{long}}.

        The <dfn attribute>statusCode</dfn> getter steps are
        to return [=this=]'s [=WebRequestResponse/statusCode=].

    * <dfn>statusLine</dfn>, which is a {{DOMString}}.

        The <dfn attribute>statusLine</dfn> getter steps are
        to return [=this=]'s [=WebRequestResponse/statusLine=].

    * <dfn>fromCache</dfn>, which is a [=boolean=].

        The <dfn attribute>fromCache</dfn> getter steps are
        to return [=this=]'s [=WebRequestResponse/fromCache=].

    * <dfn>headers</dfn>, which is a {{Headers}} or null, initially null.

        The <dfn attribute>headers</dfn> getter steps are
        to return [=this=]'s [=WebRequestResponse/headers=].

    * <dfn>ip</dfn>, which is a {{DOMString}} or null.

        The <dfn attribute>ip</dfn> getter steps are
        to return [=this=]'s [=WebRequestResponse/ip=].

    * <dfn>redirectURL</dfn>, which is a {{USVString}} or null, initially null.

        The <dfn attribute>redirectURL</dfn> getter steps are
        to return [=this=]'s [=WebRequestResponse/redirectURL=].

    * <dfn>auth</dfn>, which is a {{WebRequestAuthDetails}} or null, initially
        null.

        The <dfn attribute>auth</dfn> getter steps are
        to return [=this=]'s [=WebRequestResponse/auth=].
  </div>

Each {{WebRequestEvent}} has an associated:
  <div dfn-for=WebRequestEvent>
    * <dfn>request</dfn>, which is a {{WebRequestRequest}}.

        The <dfn attribute>request</dfn> getter steps are
        to return [=this=]'s [=WebRequestEvent/request=].

    * <dfn>frameId</dfn>, which is a {{long}}.

        The <dfn attribute>frameId</dfn> getter steps are
        to return [=this=]'s [=WebRequestEvent/frameId=].

    * <dfn>frameType</dfn>, which is a {{FrameType}} or null, initially null.

        The <dfn attribute>frameType</dfn> getter steps are
        to return [=this=]'s [=WebRequestEvent/frameType=].

    * <dfn>documentId</dfn>, which is a {{DOMString}} or null, initially null.

        The <dfn attribute>documentId</dfn> getter steps are
        to return [=this=]'s [=WebRequestEvent/documentId=].

    * <dfn>documentLifecycle</dfn>, which is a {{DocumentLifecycle}} or null,
        initially null.

        The <dfn attribute>documentLifecycle</dfn> getter steps are
        to return [=this=]'s [=WebRequestEvent/documentLifecycle=].

    * <dfn>parentDocumentId</dfn>, which is a {{DOMString}} or null, initially
        null.

        The <dfn attribute>parentDocumentId</dfn> getter steps are
        to return [=this=]'s [=WebRequestEvent/parentDocumentId=].

    * <dfn>parentFrameId</dfn>, which is a {{long}} or null, initially null.

        The <dfn attribute>parentFrameId</dfn> getter steps are
        to return [=this=]'s [=WebRequestEvent/parentFrameId=].
  </div>

Each {{WebRequestAuthRequiredEvent}} has an associated:
  <div dfn-for=WebRequestAuthRequiredEvent>
    * <dfn>response</dfn>, which is a {{WebRequestResponse}}.

        The <dfn attribute>response</dfn> getter steps are
        to return [=this=]'s [=WebRequestAuthRequiredEvent/response=].
  </div>

Each {{WebRequestBeforeRedirectEvent}} has an associated:
  <div dfn-for=WebRequestBeforeRedirectEvent>
    * <dfn>response</dfn>, which is a {{WebRequestResponse}}.

        The <dfn attribute>response</dfn> getter steps are
        to return [=this=]'s [=WebRequestBeforeRedirectEvent/response=].
  </div>

Each {{WebRequestCompletedEvent}} has an associated:
  <div dfn-for=WebRequestCompletedEvent>
    * <dfn>response</dfn>, which is a {{WebRequestResponse}}.

        The <dfn attribute>response</dfn> getter steps are
        to return [=this=]'s [=WebRequestCompletedEvent/response=].
  </div>

Each {{WebRequestErrorOccurredEvent}} has an associated:
  <div dfn-for=WebRequestErrorOccurredEvent>
    * <dfn>error</dfn>, which is a {{DOMString}}.

        The <dfn attribute>error</dfn> getter steps are
        to return [=this=]'s [=WebRequestErrorOccurredEvent/error=].
  </div>

Each {{WebRequestHeadersReceivedEvent}} has an associated:
  <div dfn-for=WebRequestHeadersReceivedEvent>
    * <dfn>response</dfn>, which is a {{WebRequestResponse}}.

        The <dfn attribute>response</dfn> getter steps are
        to return [=this=]'s [=WebRequestHeadersReceivedEvent/response=].
  </div>

Each {{WebRequestResponseStartedEvent}} has an associated:
  <div dfn-for=WebRequestResponseStartedEvent>
    * <dfn>response</dfn>, which is a {{WebRequestResponse}}.

        The <dfn attribute>response</dfn> getter steps are
        to return [=this=]'s [=WebRequestResponseStartedEvent/response=].
  </div>

<div algorithm>
  The <dfn method for=WebRequest>createWebRequestInterceptor(|options|)</dfn>
  method steps are:

  1. Let |interceptor| be a [=new=] {{WebRequestInterceptor}} object.

  1. Set the following fields on |interceptor|:

    :  [=WebRequestInterceptor/resourceTypes=]
    :: |options|["{{WebRequestInterceptorOptions/resourceTypes}}"]

    :  [=WebRequestInterceptor/blocking=]
    :: |options|["{{WebRequestInterceptorOptions/blocking}}"]

    :  [=WebRequestInterceptor/includeRequestBody=]
    :: |options|["{{WebRequestInterceptorOptions/includeRequestBody}}"]

    :  [=WebRequestInterceptor/includeHeaders=]
    :: |options|["{{WebRequestInterceptorOptions/includeHeaders}}"]

  1. [=list/For each=] |urlPattern| in |options|["{{
      WebRequestInterceptorOptions/urlPatterns}}"]:

      1. If |urlPattern| is a {{URLPattern}}, then [=list/append=] |urlPattern|
          to |interceptor|'s [=WebRequestInterceptor/urlPatterns=].

      1. Otherwise, [=list/append=] a [=new=] {{URLPattern}} given |urlPattern|
          to |interceptor|'s [=WebRequestInterceptor/urlPatterns=].

  1. [=list/Append=] |interceptor| to [=this=]'s [=WebRequest/interceptors=].

  1. Return |interceptor|.

</div>

<div algorithm>
  The <dfn method for=WebRequest>interceptorBehaviorChanged()</dfn>
  method steps are:

  Note: The behavior of event handlers registered through the WebRequest
  API will be reflected in the HTTP cache, which will no longer be valid if
  the behavior of the event handlers changed. The purpose of this method is
  to invalidate any cache entries that were affected by WebRequest event
  handlers.

  1. Let |promise| be [=a new promise=].

  1. Let |controlledframe| be [=this=].

  1. Return |promise| and run the following steps [=in parallel=].

  1. Remove all entries in the
      <a href="https://datatracker.ietf.org/doc/html/rfc7234#section-2">network
      cache</a> that originated from content in |controlledframe|'s
      <{HTMLControlledFrameElement/partition}>.

      Issue: The <a href="https://datatracker.ietf.org/doc/html/rfc7234#section-2">
          network cache</a> specification isn't aware of [=storage keys=]. The
          intended behavior is to remove cache entries whose [=storage key/
          embedding origin=] is |controlledframe|'s [=relevant settings object=]'s
          [=environment/top-level origin=], and [=storage key/partition=]
          is |controlledframe|'s <{HTMLControlledFrameElement/partition}>.

  1. If a user agent implements caches beyond a pure network cache, it MUST
      remove all entries from those caches that originate from content in
      |controlledframe|'s <{HTMLControlledFrameElement/partition}>.

  1. [=Resolve an embedder promise=] given |controlledframe| and |promise| when
      the HTTP cache has been cleared.

</div>

<div algorithm>
  To get the <dfn>applicable {{WebRequestInterceptor}}s</dfn> for a [=/request=]
  |request|, run the following steps:

  1. Let |client| be |request|'s [=request/client=].

  1. If |client| is null, return an empty [=list=] and `false`.

  1. Let |window| be the [=owning Window of an environment settings object=]
      given |client|.

  1. If |window| is null then return an empty [=list=] and `false`.

  1. Let |navigable| be |window|'s [=Window/navigable=].

  1. If |navigable| or its [=controlledFrameEmbedderParent=] is null, return an empty [=list=]
      and `false`.

  1. Let |controlledFrame| be |navigable|'s [=controlledFrameEmbedderParent=].

  1. Let |applicableInterceptors| be an empty [=list=].

  1. For each |interceptor| in |controlledFrame|'s [=controlledframe/request=]'s
      [=WebRequest/interceptors=]:

      1. If |request| should not be [=WebRequestInterceptor/intercepted=]
          by |interceptor|, then [=iteration/continue=].

      1. [=list/Append=] |interceptor| to |applicableInterceptors|.

  1. Return |applicableInterceptors|.

</div>

<div algorithm>
  To determine if a [=/request=] |request| should be
  <dfn for=WebRequestInterceptor>intercepted</dfn> by a
  {{WebRequestInterceptor}}, run the following steps:

    1. Let |types| be |interceptor|'s [=WebRequestInterceptor/resourceTypes=].

    1. If |types| is not [=list/empty=] and |types| does not
        [=list/contain=] the result of calling [=get a request's
        ResourceType=] given |request|, then return `false`.

    1. Let |urlPatterns| be |interceptor|'s
        [=WebRequestInterceptor/urlPatterns=].

    1. For each |urlPattern| in |urlPatterns|:

        1. If |request|'s [=request/URL=] [=matches a URLPattern=] given
            |urlPattern|, then return `true`.

    1. Return `false`.

</div>

<div algorithm>
  To get the <dfn>owning {{Window}} of an [=environment settings object=]</dfn>
  given an [=environment settings object=] |environment|, run the
  following steps:

  1. Let |global| be |environment|'s [=environment settings object/
      global object=].

  1. If |global| is a {{Window}} object, then return |global|.

  1. If |global| is a {{DedicatedWorkerGlobalScope}} object, then:

      1. Let |owner| be |global|.

      1. While |owner| is a {{DedicatedWorkerGlobalScope}} object:

          1. Let |owner| be |owner|'s [=WorkerGlobalScope/owner set=][0].

      1. If |owner| is a {{Document}} object, then return |owner|'s
          [=relevant global object=].

  1. Return null.

</div>

## Events ## {#api-web-request-events}

{{WebRequestInterceptor}} fires the following events:

<table>
  <tr>
    <th>Event name</th>
    <th>Interface</th>
    <th>Fired when...</th>
  </tr>
  <tr>
    <td><dfn for=WebRequestInterceptor>authrequired</dfn></td>
    <td>{{WebRequestAuthRequiredEvent}}</td>
    <td>
      an [=WebRequestInterceptor/intercepted=] [=/request=] receives a
      [=/response=] with an HTTP 401 (Unauthorized) 407 (Proxy Authentication
      Required) [=response/status=].
    </td>
  </tr>
  <tr>
    <td><dfn for=WebRequestInterceptor>beforeredirect</dfn></td>
    <td>{{WebRequestBeforeRedirectEvent}}</td>
    <td>
      an [=WebRequestInterceptor/intercepted=] [=/request=] receives a redirect
      [=/response=].
    </td>
  </tr>
  <tr>
    <td><dfn for=WebRequestInterceptor>beforerequest</dfn></td>
    <td>{{WebRequestBeforeRequestEvent}}</td>
    <td>
      an [=WebRequestInterceptor/intercepted=] [=/request=] is about to start
      being processed.
    </td>
  </tr>
  <tr>
    <td><dfn for=WebRequestInterceptor>beforesendheaders</dfn></td>
    <td>{{WebRequestBeforeSendHeadersEvent}}</td>
    <td>
      the request headers of an [=WebRequestInterceptor/intercepted=]
      [=/request=] are about to be sent.
    </td>
  </tr>
  <tr>
    <td><dfn for=WebRequestInterceptor>completed</dfn></td>
    <td>{{WebRequestCompletedEvent}}</td>
    <td>
      an [=WebRequestInterceptor/intercepted=] [=/request=] completed.
    </td>
  </tr>
  <tr>
    <td><dfn for=WebRequestInterceptor>erroroccurred</dfn></td>
    <td>{{WebRequestErrorOccurredEvent}}</td>
    <td>
      an error occurred when processing an [=WebRequestInterceptor/intercepted=]
      [=/request=].
    </td>
  </tr>
  <tr>
    <td><dfn for=WebRequestInterceptor>headersreceived</dfn></td>
    <td>{{WebRequestHeadersReceivedEvent}}</td>
    <td>
      an [=WebRequestInterceptor/intercepted=] [=/request=] receives
      response headers.
    </td>
  </tr>
  <tr>
    <td><dfn for=WebRequestInterceptor>sendheaders</dfn></td>
    <td>{{WebRequestSendHeadersEvent}}</td>
    <td>
      an [=WebRequestInterceptor/intercepted=] [=/request=] sends its request
      headers.
    </td>
  </tr>
  <tr>
    <td><dfn for=WebRequestInterceptor>responsestarted</dfn></td>
    <td>{{WebRequestResponseStartedEvent}}</td>
    <td>
      an [=WebRequestInterceptor/intercepted=] [=/request=] has begun
      receiving its [=/response=].
    </td>
  </tr>
</table>

{{WebRequestInterceptor}} supports the following [=event handlers=] (and their
corresponding [=event handler event types=]) as [=event handler IDL attributes=]:

<table>
  <tr>
    <th>[=Event handlers=]</th>
    <th>[=Event handler event types=]</th>
  </tr>
  <tr>
    <td><dfn attribute for=WebRequestInterceptor>onauthrequired</dfn></td>
    <td>[=WebRequestInterceptor/authrequired=]</td>
  </tr>
  <tr>
    <td><dfn attribute for=WebRequestInterceptor>onbeforeredirect</dfn></td>
    <td>[=WebRequestInterceptor/beforeredirect=]</td>
  </tr>
  <tr>
    <td><dfn attribute for=WebRequestInterceptor>onbeforerequest</dfn></td>
    <td>[=WebRequestInterceptor/beforerequest=]</td>
  </tr>
  <tr>
    <td><dfn attribute for=WebRequestInterceptor>onbeforesendheaders</dfn></td>
    <td>[=WebRequestInterceptor/beforesendheaders=]</td>
  </tr>
  <tr>
    <td><dfn attribute for=WebRequestInterceptor>oncompleted</dfn></td>
    <td>[=WebRequestInterceptor/completed=]</td>
  </tr>
  <tr>
    <td><dfn attribute for=WebRequestInterceptor>onerroroccurred</dfn></td>
    <td>[=WebRequestInterceptor/erroroccurred=]</td>
  </tr>
  <tr>
    <td><dfn attribute for=WebRequestInterceptor>onheadersreceived</dfn></td>
    <td>[=WebRequestInterceptor/headersreceived=]</td>
  </tr>
  <tr>
    <td><dfn attribute for=WebRequestInterceptor>onsendheaders</dfn></td>
    <td>[=WebRequestInterceptor/sendheaders=]</td>
  </tr>
  <tr>
    <td><dfn attribute for=WebRequestInterceptor>onresponsestarted</dfn></td>
    <td>[=WebRequestInterceptor/responsestarted=]</td>
  </tr>
</table>

Each {{WebRequestAuthRequiredEvent}} has an associated:
  <div dfn-for=WebRequestAuthRequiredEvent>
    * <dfn>cancel</dfn>, a [=boolean=], initially `false`.
    * <dfn>authCredentials</dfn>, a {{Promise}}<{{WebRequestAuthCredentials}}>
        or null, initially null.
    * <dfn>options</dfn>, a {{WebRequestAuthOptions}}, initially «».
  </div>

<div algorithm>
  {{WebRequestAuthRequiredEvent}}'s
  <dfn method for=WebRequestAuthRequiredEvent>setCredentials(|credentials|, |options|)</dfn>
  method steps are:
    1. Set [=this=]'s [=WebRequestAuthRequiredEvent/authCredentials=] to
        |credentials|.
    1. Set [=this=]'s [=WebRequestAuthRequiredEvent/options=] to
        |options|.

</div>

<div algorithm>
  {{WebRequestAuthRequiredEvent}}'s
  <dfn method for=WebRequestAuthRequiredEvent>preventDefault()</dfn>
  method steps are to set [=this=]'s [=WebRequestAuthRequiredEvent/cancel=]
  to `true`.
</div>

Each {{WebRequestBeforeRequestEvent}} has an associated:
  <div dfn-for=WebRequestBeforeRequestEvent>
    * <dfn>cancel</dfn>, a [=boolean=], initially `false`.
    * <dfn>redirectURL</dfn>, a {{USVString}}, initially "".
  </div>

<div algorithm>
  {{WebRequestBeforeRequestEvent}}'s
  <dfn method for=WebRequestBeforeRequestEvent>redirect(|redirectURL|)</dfn>
  method steps are to set [=this=]'s [=WebRequestBeforeRequestEvent/redirectURL=]
  to |redirectURL|.
</div>

<div algorithm>
  {{WebRequestBeforeRequestEvent}}'s
  <dfn method for=WebRequestBeforeRequestEvent>preventDefault()</dfn>
  method steps are to set [=this=]'s [=WebRequestBeforeRequestEvent/cancel=]
  to `true`.
</div>

Each {{WebRequestBeforeSendHeadersEvent}} has an associated:
  <div dfn-for=WebRequestBeforeSendHeadersEvent>
    * <dfn>cancel</dfn>, a [=boolean=], initially `false`.
    * <dfn>requestHeaders</dfn>, a {{Headers}} or null, initially null.
  </div>

<div algorithm>
  {{WebRequestBeforeSendHeadersEvent}}'s
  <dfn method for=WebRequestBeforeSendHeadersEvent>setRequestHeaders(|requestHeaders|)</dfn>
  method steps are to set [=this=]'s
  [=WebRequestBeforeSendHeadersEvent/requestHeaders=] to |requestHeaders|.
</div>

<div algorithm>
  {{WebRequestBeforeSendHeadersEvent}}'s
  <dfn method for=WebRequestBeforeSendHeadersEvent>preventDefault()</dfn>
  method steps are to set [=this=]'s [=WebRequestBeforeSendHeadersEvent/cancel=]
  to `true`.
</div>

Each {{WebRequestHeadersReceivedEvent}} has an associated:
  <div dfn-for=WebRequestHeadersReceivedEvent>
    * <dfn>cancel</dfn>, a [=boolean=], initially `false`.
    * <dfn>redirectURL</dfn>, a {{USVString}}, initially "".
    * <dfn>responseHeaders</dfn>, a {{Headers}} or null, initially null.
  </div>

<div algorithm>
  {{WebRequestHeadersReceivedEvent}}'s
  <dfn method for=WebRequestHeadersReceivedEvent>redirect(|redirectURL|)</dfn>
  method steps are to set [=this=]'s
  [=WebRequestHeadersReceivedEvent/redirectURL=] to |redirectURL|.
</div>

<div algorithm>
  {{WebRequestHeadersReceivedEvent}}'s
  <dfn method for=WebRequestHeadersReceivedEvent>setResponseHeaders(|responseHeaders|)</dfn>
  method steps are to set [=this=]'s
  [=WebRequestHeadersReceivedEvent/responseHeaders=] to |responseHeaders|.
</div>

<div algorithm>
  {{WebRequestHeadersReceivedEvent}}'s
  <dfn method for=WebRequestHeadersReceivedEvent>preventDefault()</dfn>
  method steps are to set [=this=]'s [=WebRequestHeadersReceivedEvent/cancel=]
  to `true`.
</div>

A <dfn>WebRequestEvent result</dfn> is a [=struct=] with the following
[=struct/items=]:
<dl dfn-for="WebRequestEvent result">
  : <dfn>cancel</dfn>
  :: a [=boolean=], initially `false`

  : <dfn>redirectURL</dfn>
  :: a {{USVString}}, initially ""

  : <dfn>authCredentials</dfn>
  :: a {{WebRequestAuthCredentials}} or null, initially null

  : <dfn>requestHeaders</dfn>
  :: a [=header list=], initially «»

  : <dfn>responseHeaders</dfn>
  :: a [=header list=], initially «»

</dl>

<div algorithm>
  To <dfn>process beforeRequest events</dfn> given a [=/request=] |request|,
  run the following steps:

  1. Let |interceptors| be the result of getting the
      [=applicable WebRequestInterceptors=] of |request|.

  1. Let |result| be a [=WebRequestEvent result=].

  1. Let |pendingHandlerCount| be 0.

  1. Let |controlledFrameEmbedderGlobal| be the [=relevant global object=] of
      the result of [=getting an environment's controlledFrameEmbedderParent=] given
      |request|'s [=request/client=].

  1. If |controlledFrameEmbedderGlobal| is null, then return.

  1. For each |interceptor| in |interceptors|:

      1. If |interceptor|'s [=WebRequestInterceptor/blocking=] is `true`,
          then increment |pendingHandlerCount|.

      1. [=Queue a global task=] on the [=DOM manipulation task source=] of
          |controlledFrameEmbedderGlobal| that will run the following steps:

          1. Let |event| be a [=new=] {{WebRequestBeforeRequestEvent}} named
              [=WebRequestInterceptor/beforerequest=].

          1. [=Populate a WebRequestEvent=] given |event|, |request|, and
              "{{RequestedHeaders/none}}".

          1. If |interceptor|'s [=WebRequestInterceptor/includeRequestBody=] is
              `true` and |request|'s [=request/body=] is not null, then:

              1. Let |requestBody| be a [=new=] {{RequestBody}}.

              1. Let |body| be |request|'s [=request/body=].

                  <span class=XXX>TODO: serialize |body|'s [=body/stream=] if present.</span>

              1. Switch on |body|'s [=body/source=]:

                  : [=byte sequence=]
                  :: [=list/Append=] a [=new=] {{UploadData}} with [=UploadData/
                      bytes=] equal to the serialized |body|'s [=body/source=] to
                      |requestBody|'s [=RequestBody/raw=].

                  : {{Blob}}
                  :: [=list/Append=] a [=new=] {{UploadData}} with [=UploadData/
                      bytes=] equal to the serialized |body|'s [=body/source=] to
                      |requestBody|'s [=RequestBody/raw=].

                  : {{FormData}}
                  ::  1. Let |formData| be «[]».

                      1. [=list/For each=] |entry| in |body|'s [=body/source=]'s
                          [=FormData/entry list=]:

                          1. Switch on |entry|[1]:

                          : {{File}}
                          :: [=list/Append=] a [=new=] {{UploadData}} with
                              [=UploadData/file=] equal to |entry|[1]'s
                              {{File/name}} to |requestBody|'s [=RequestBody/raw=].

                          : {{USVString}}
                          ::  1. If |formData|[|entry|[0]] does not exist, then
                                  set |formData|[|entry|[0]] equal to an empty
                                  [=list=].

                              1. [=list/Append=] |entry|[1] to
                                  |formData|[|entry|[0]].

                      1. Set |requestBody|'s [=RequestBody/formData=] to |formData|.

              1. Set |event|'s [=WebRequestEvent/request=]'s [=WebRequestRequest/
                  body=] to |requestBody|.

          1. [=Dispatch=] |event| to |interceptor|.

          1. If |event|'s [=WebRequestBeforeRequestEvent/cancel=] is `true`,
              then set |result|'s [=WebRequestEvent result/cancel=] to `true`.

          1. If |event|'s [=WebRequestBeforeRequestEvent/redirectURL=] is not
              null and |result|'s [=WebRequestEvent result/redirectURL=] is "",
              then set |result|'s [=WebRequestEvent result/redirectURL=] to
              [=event=]'s [=WebRequestBeforeRequestEvent/redirectURL=].

          1. If |interceptor|'s [=WebRequestInterceptor/blocking=] is `true`,
              then decrement |pendingHandlerCount|.

  1. If |pendingHandlerCount| &gt; 0, then wait [=in parallel=] for
      |pendingHandlerCount| to equal 0, then [=queue a global task=] that will
      continue the remaining steps of this algorithm on either the [=networking
      task source=] of |request|'s [=request/client=]'s [=environment settings
      object/global object=] or the [=in parallel=] context that these steps
      were first invoked on, depending on how these steps were run before going
      in parallel.

  1. Return |result|.

</div>

<div algorithm>
  To <dfn>process beforeSendHeaders events</dfn> given a [=/request=] |request|,
  run the following steps:

  1. Let |interceptors| be the result of getting the
      [=applicable WebRequestInterceptors=] of |request|.

  1. Let |result| be a [=WebRequestEvent result=].

  1. Let |pendingHandlerCount| be 0.

  1. Let |controlledFrameEmbedderGlobal| be the [=relevant global object=] of
      the result of [=getting an environment's controlledFrameEmbedderParent=] given
      |request|'s [=request/client=].

  1. If |controlledFrameEmbedderGlobal| is null, then return.

  1. For each |interceptor| in |interceptors|:

      1. If |interceptor|'s [=WebRequestInterceptor/blocking=] is `true`,
          then increment |pendingHandlerCount|.

      1. [=Queue a global task=] on the [=DOM manipulation task source=] of
          |controlledFrameEmbedderGlobal| that will run the following steps:

          1. Let |event| be a [=new=] {{WebRequestBeforeSendHeadersEvent}} named
              [=WebRequestInterceptor/beforesendheaders=].

          1. [=Populate a WebRequestEvent=] given |event|, |request|, and
              |interceptor|'s [=WebRequestInterceptor/includeHeaders=].

          1. [=Dispatch=] |event| to |interceptor|.

          1. If |event|'s [=WebRequestBeforeSendHeadersEvent/cancel=] is `true`,
              then set |result|'s [=WebRequestEvent result/cancel=] to `true`.

          1. If |event|'s [=WebRequestBeforeSendHeadersEvent/requestHeaders=]
              is not null, then:

              1. If |result|'s [=WebRequestEvent result/requestHeaders=] is
                  null, then set it to a [=new=] {{Headers}}.

              1. For each |header| in |event|'s
                  [=WebRequestBeforeSendHeadersEvent/requestHeaders=]:

                  1. [=Headers/Append=] |header| to |result|'s [=WebRequestEvent
                      result/requestHeaders=].

          1. If |interceptor|'s [=WebRequestInterceptor/blocking=] is `true`,
              then decrement |pendingHandlerCount|.

  1. If |pendingHandlerCount| &gt; 0, then wait [=in parallel=] for
      |pendingHandlerCount| to equal 0, then [=queue a global task=] that will
      continue the remaining steps of this algorithm on either the [=networking
      task source=] of |request|'s [=request/client=]'s [=environment settings
      object/global object=] or the [=in parallel=] context that these steps
      were first invoked on, depending on how these steps were run before going
      in parallel.

  1. Return |result|.

</div>

<div algorithm>
  To <dfn>process sendHeaders events</dfn> given a [=/request=] |request|,
  run the following steps:

  1. Let |interceptors| be the result of getting the
      [=applicable WebRequestInterceptors=] of |request|.

  1. Let |controlledFrameEmbedderGlobal| be the [=relevant global object=] of
      the result of [=getting an environment's controlledFrameEmbedderParent=] given
      |request|'s [=request/client=].

  1. If |controlledFrameEmbedderGlobal| is null, then return.

  1. For each |interceptor| in |interceptors|:

      1. [=Queue a global task=] on the [=DOM manipulation task source=] of
          |controlledFrameEmbedderGlobal| that will run the following steps:

          1. Let |event| be a [=new=] {{WebRequestSendHeadersEvent}} named
              [=WebRequestInterceptor/sendheaders=].

          1. [=Populate a WebRequestEvent=] given |event|, |request|, and
              |interceptor|'s [=WebRequestInterceptor/includeHeaders=].

          1. [=Dispatch=] |event| to |interceptor|.

</div>

<div algorithm>
  To <dfn>process headersReceived events</dfn> given a [=/request=] |request|
  and a [=/response=] |response|, run the following steps:

  1. Let |interceptors| be the result of getting the
      [=applicable WebRequestInterceptors=] of |request|.

  1. Let |result| be a [=WebRequestEvent result=].

  1. Let |pendingHandlerCount| be |interceptor|'s [=list/size=].

  1. Let |controlledFrameEmbedderGlobal| be the [=relevant global object=] of
      the result of [=getting an environment's controlledFrameEmbedderParent=] given
      |request|'s [=request/client=].

  1. If |controlledFrameEmbedderGlobal| is null, then return.

  1. For each |interceptor| in |interceptors|:

      1. If |interceptor|'s [=WebRequestInterceptor/blocking=] is `true`,
          then increment |pendingHandlerCount|.

      1. [=Queue a global task=] on the [=DOM manipulation task source=] of
          |controlledFrameEmbedderGlobal| that will run the following steps:

          1. Let |event| be a [=new=] {{WebRequestHeadersReceivedEvent}} named
              [=WebRequestInterceptor/headersreceived=].

          1. [=Populate a WebRequestEvent=] given |event|, |request|, and
              "{{RequestedHeaders/none}}".

          1. Set |event|'s [=WebRequestHeadersReceivedEvent/response=] to the
              result of [=creating a WebRequestResponse object=] given |request|,
              |response|, and |interceptor|'s
              [=WebRequestInterceptor/includeHeaders=].

          1. [=Dispatch=] |event| to |interceptor|.

          1. If |event|'s [=WebRequestHeadersReceivedEvent/cancel=] is `true`,
              then set |result|'s [=WebRequestEvent result/cancel=] to `true`.

          1. If |event|'s [=WebRequestHeadersReceivedEvent/redirectURL=] is not
              null and |result|'s [=WebRequestEvent result/redirectURL=] is "",
              then set |result|'s [=WebRequestEvent result/redirectURL=] to
              [=event=]'s [=WebRequestHeadersReceivedEvent/redirectURL=].

          1. If |event|'s [=WebRequestHeadersReceivedEvent/responseHeaders=]
              is not null, then:

              1. If |result|'s [=WebRequestEvent result/responseHeaders=] is
                  null, then set it to a [=new=] {{Headers}}.

              1. For each |header| in |event|'s
                  [=WebRequestHeadersReceivedEvent/responseHeaders=]:

                  1. [=Headers/Append=] |header| to |result|'s [=WebRequestEvent
                      result/responseHeaders=].

          1. If |interceptor|'s [=WebRequestInterceptor/blocking=] is `true`,
              then decrement |pendingHandlerCount|.

  1. If |pendingHandlerCount| &gt; 0, then wait [=in parallel=] for
      |pendingHandlerCount| to equal 0, then [=queue a global task=] that will
      continue the remaining steps of this algorithm on either the [=networking
      task source=] of |request|'s [=request/client=]'s [=environment settings
      object/global object=] or the [=in parallel=] context that these steps
      were first invoked on, depending on how these steps were run before going
      in parallel.

  1. Return |result|.

</div>

<div algorithm>
  To <dfn>process authRequired events</dfn> given a [=/request=] |request|
  and a [=/response=] |response|, run the following steps:

  1. Let |challenger| be a [=new=] {{AuthChallenger}} with [=AuthChallenger/
      host=] and [=AuthChallenger/port=] equal to the [=url/host=] and
      [=url/port=] of |response|'s [=response/URL=].

  1. If |response|'s [=response/status=] is 401, then:

      1. Let |isProxy| be `false`.

      1. Let |scheme| be the scheme from |response|'s `WWW-Authenticate` header,
          parsed as defined by the [[HTML]] specification, or null if the header
          is missing or invalid.

      1. Let |realm| be the realm from |response|'s `WWW-Authenticate` header,
          parsed as defined by the [[HTML]] specification.

  1. Otherwise:

      1. Let |isProxy| be `true`.

      1. Let |scheme| be the scheme from |response|'s `Proxy-Authenticate`
          header, parsed as defined by the [[HTML]] specification, or null if
          the header is missing or invalid.

      1. Let |realm| be the realm from |response|'s `Proxy-Authenticate` header,
          parsed as defined by the [[HTML]] specification.

  1. If |scheme| is null, then return null.

  1. Let |interceptors| be the result of getting the
      [=applicable WebRequestInterceptors=] of |request|.

  1. Let |result| be a [=WebRequestEvent result=].

  1. Let |pendingHandlerCount| be 0.

  1. Let |controlledFrameEmbedderGlobal| be the [=relevant global object=] of
      the result of [=getting an environment's controlledFrameEmbedderParent=] given
      |request|'s [=request/client=].

  1. If |controlledFrameEmbedderGlobal| is null, then return.

  1. For each |interceptor| in |interceptors|:

      1. If |interceptor|'s [=WebRequestInterceptor/blocking=] is `true`,
          then increment |pendingHandlerCount|.

      1. [=Queue a global task=] on the [=DOM manipulation task source=] of
          |controlledFrameEmbedderGlobal| that will run the following steps:

          1. Let |event| be a [=new=] {{WebRequestAuthRequiredEvent}} named
              [=WebRequestInterceptor/authrequired=].

          1. [=Populate a WebRequestEvent=] given |event|, |request|, and
              "{{RequestedHeaders/none}}".

          1. Set |event|'s [=WebRequestAuthRequiredEvent/response=] to the
              result of [=creating a WebRequestResponse object=] given |request|,
              |response|, and |interceptor|'s
              [=WebRequestInterceptor/includeHeaders=].

          1. Set |event|'s [=WebRequestAuthRequiredEvent/response=]'s [=
              WebRequestResponse/auth=] to a [=new=] {{WebRequestAuthDetails}}
              whose [=WebRequestAuthDetails/challenger=],
              [=WebRequestAuthDetails/isProxy=],
              [=WebRequestAuthDetails/scheme=], and
              [=WebRequestAuthDetails/realm=] fields have the values
              |challenger|, |isProxy|, |scheme|, and |realm| respectively.

          1. [=Dispatch=] |event| to |interceptor|.

          1. Let |credentials| be |event|'s
              [=WebRequestAuthRequiredEvent/authCredentials=].

          1. If |event|'s [=WebRequestAuthRequiredEvent/cancel=] is `true`,
              then set |result|'s [=WebRequestEvent result/cancel=] to `true`.

          1. Otherwise, if |credentials| is a {{Promise}}, then:

              1. Let |signal| be |event|'s [=WebRequestAuthRequiredEvent/
                  options=]["{{WebRequestAuthOptions/signal}}"].

              1. Let |done| be `false`.

              1. If |signal| is an {{AbortSignal}}, then [=AbortSignal/add=] the
                  following abort algorithm to |signal|:

                  1. Set |result|'s [=WebRequestEvent result/cancel=] to `true`.

                  1. Set |done| to `true`.

              1. [=Upon fulfillment=] of |credentials|, run the following steps
                  that take a |resolvedValue|:

                  1. If |resolvedValue| is a [=dictionary=] [=map/containing=]
                      two [=map/keys=] equal to "username" and "password", and
                      |result|'s [=WebRequestEvent result/authCredentials=]
                      is undefined, then set |result|'s [=WebRequestEvent
                      result/authCredentials=] to |resolvedValue|.

                  1. Set |done| to `true`.

              1. [=Upon rejection=] of |credentials|, run the following steps:

                  1. Set |done| to `true`.

                  Note: A rejected promise will not cancel the request, but no
                  credentials will be provided to the server.

              1. Wait [=in parallel=] for |done| to equal `true`, then [=queue a
                  global task=] on the [=DOM manipulation task source=] of
                  |controlledFrameEmbedderGlobal| that will run continue the remaining steps
                  of this algorithm.

          1. If |interceptor|'s [=WebRequestInterceptor/blocking=] is `true`,
              then decrement |pendingHandlerCount|.

  1. If |pendingHandlerCount| &gt; 0, then wait [=in parallel=] for
      |pendingHandlerCount| to equal 0, then [=queue a global task=] that will
      continue the remaining steps of this algorithm on either the [=networking
      task source=] of |request|'s [=request/client=]'s [=environment settings
      object/global object=] or the [=in parallel=] context that these steps
      were first invoked on, depending on how these steps were run before going
      in parallel.

  1. Return |result|.

</div>

<div algorithm>
  To <dfn>process beforeRedirect events</dfn> given a [=/request=] |request|
  and a [=/response=] |response|, run the following steps:

  1. Let |interceptors| be the result of getting the
      [=applicable WebRequestInterceptors=] of |request|.

  1. Let |controlledFrameEmbedderGlobal| be the [=relevant global object=] of
      the result of [=getting an environment's controlledFrameEmbedderParent=] given
      |request|'s [=request/client=].

  1. If |controlledFrameEmbedderGlobal| is null, then return.

  1. For each |interceptor| in |interceptors|:

      1. [=Queue a global task=] on the [=DOM manipulation task source=] of
          |controlledFrameEmbedderGlobal| that will run the following steps:

          1. Let |event| be a [=new=] {{WebRequestBeforeRedirectEvent}} named
              [=WebRequestInterceptor/beforeredirect=].

          1. [=Populate a WebRequestEvent=] given |event|, |request|, and
              "{{RequestedHeaders/none}}".

          1. Set |event|'s [=WebRequestBeforeRedirectEvent/response=] to the
              result of [=creating a WebRequestResponse object=] given |request|,
              |response|, and |interceptor|'s
              [=WebRequestInterceptor/includeHeaders=].

          1. Let |internalResponse| be |response|, if |response| is not a
              [=filtered response=]; otherwise |response|'s [=internal response=].

          1. Set |event|'s [=WebRequestBeforeRedirectEvent/response=]'s [=
              WebRequestResponse/redirectURL=] to |internalResponse|'s
              [=location URL=] given |request|'s [=request/current URL=]'s
              [=url/fragment=].

          1. [=Dispatch=] |event| to |interceptor|.

</div>

<div algorithm>
  To <dfn>process responseStarted events</dfn> given a [=/request=] |request|
  and a [=/response=] |response|, run the following steps:

  1. Let |interceptors| be the result of getting the
      [=applicable WebRequestInterceptors=] of |request|.

  1. Let |controlledFrameEmbedderGlobal| be the [=relevant global object=] of
      the result of [=getting an environment's controlledFrameEmbedderParent=] given
      |request|'s [=request/client=].

  1. If |controlledFrameEmbedderGlobal| is null, then return.

  1. For each |interceptor| in |interceptors|:

      1. [=Queue a global task=] on the [=DOM manipulation task source=] of
          |controlledFrameEmbedderGlobal| that will run the following steps:

          1. Let |event| be a [=new=] {{WebRequestResponseStartedEvent}} named
              [=WebRequestInterceptor/responsestarted=].

          1. [=Populate a WebRequestEvent=] given |event|, |request|, and
              "{{RequestedHeaders/none}}".

          1. Set |event|'s [=WebRequestResponseStartedEvent/response=] to the
              result of [=creating a WebRequestResponse object=] given |request|,
              |response|, and |interceptor|'s
              [=WebRequestInterceptor/includeHeaders=].

          1. [=Dispatch=] |event| to |interceptor|.

</div>

<div algorithm>
  To <dfn>process completed events</dfn> given a [=/request=] |request|
  and a [=/response=] |response|, run the following steps:

  1. Let |interceptors| be the result of getting the
      [=applicable WebRequestInterceptors=] of |request|.

  1. Let |controlledFrameEmbedderGlobal| be the [=relevant global object=] of
      the result of [=getting an environment's controlledFrameEmbedderParent=] given
      |request|'s [=request/client=].

  1. If |controlledFrameEmbedderGlobal| is null, then return.

  1. For each |interceptor| in |interceptors|:

      1. [=Queue a global task=] on the [=DOM manipulation task source=] of
          |controlledFrameEmbedderGlobal| that will run the following steps:

          1. Let |event| be a [=new=] {{WebRequestCompletedEvent}} named
              [=WebRequestInterceptor/completed=].

          1. [=Populate a WebRequestEvent=] given |event|, |request|, and
              "{{RequestedHeaders/none}}".

          1. Set |event|'s [=WebRequestCompletedEvent/response=] to the
              result of [=creating a WebRequestResponse object=] given |request|,
              |response|, and |interceptor|'s
              [=WebRequestInterceptor/includeHeaders=].

          1. [=Dispatch=] |event| to |interceptor|.

</div>

<div algorithm>
  To <dfn>process errorOccurred events</dfn> given a [=/request=] |request|
  and a [=/response=] |response|, run the following steps:

  1. Let |interceptors| be the result of getting the
      [=applicable WebRequestInterceptors=] of |request|.

  1. Let |controlledFrameEmbedderGlobal| be the [=relevant global object=] of
      the result of [=getting an environment's controlledFrameEmbedderParent=] given
      |request|'s [=request/client=].

  1. If |controlledFrameEmbedderGlobal| is null, then return.

  1. For each |interceptor| in |interceptors|:

      1. [=Queue a global task=] on the [=DOM manipulation task source=] of
          |controlledFrameEmbedderGlobal| that will run the following steps:

          1. Let |event| be a [=new=] {{WebRequestErrorOccurredEvent}} named
              [=WebRequestInterceptor/erroroccurred=].

          1. [=Populate a WebRequestEvent=] given |event|, |request|, and
              "{{RequestedHeaders/none}}".

          1. Set |event|'s [=WebRequestErrorOccurredEvent/error=] to an
              [=implementation-defined=] error message describing the error in
              |response|.

          1. [=Dispatch=] |event| to |interceptor|.

</div>

<div algorithm>
  To <dfn>populate a {{WebRequestEvent}}</dfn> given a {{WebRequestEvent}}
  |event|, a [=/request=] |request|, and a {{RequestedHeaders}}
  |requestedHeaders|, run the following steps:

  1. Let |environmentSettingsObject| be |request|'s [=request/client=].

  1. Set the following fields on |event|:

      : [=WebRequestEvent/frameId=]
      :: -1

  1. Let |window| be the [=owning Window of an environment settings object=]
      given |environmentSettingsObject|.

  1. If |window| is not null, then:

      1. Let |parentNavigable| be |window|'s [=Window/navigable=]'s
          [=navigable/parent=].

      1. Update the following fields of |event|:

          : [=WebRequestEvent/documentId=]
          :: |environmentSettingsObject|'s [=environment/id=].

          : [=WebRequestEvent/documentLifecycle=]
          :: The result of [=getting the DocumentLifecycle of a Document=] given
              |window|'s [=associated document=].

          : [=WebRequestEvent/frameId=]
          :: The [=navigable/frameId=] of |window|'s [=Window/navigable=].

          : [=WebRequestEvent/frameType=]
          :: {{FrameType/"fenced-frame"}} if |window|'s
              [=window/browsing context=]'s [=fenced frame config instance=] is
              non-null, {{FrameType/"outermost-frame"}} if |parentNavigable| is
              null, {{FrameType/"sub-frame"}} otherwise.

      1. If |parentNavigable| is not null, then update the following
          values of |event|:

          : [=WebRequestEvent/parentDocumentId=]
          :: The [=environment/id=] of |parentNavigable|'s
              [=active document=]'s [=relevant global object=].

          : [=WebRequestEvent/parentFrameId=]
          :: The [=navigable/frameId=] of |parentNavigable|.

  1. Set |event|'s [=WebRequestEvent/request=] to a [=new=]
      {{WebRequestRequest}} with the following fields:

      : [=WebRequestRequest/url=]
      :: The last element of |request|'s [=request/URL list=].

      : [=WebRequestRequest/method=]
      :: |request|'s [=request/method=].

      : [=WebRequestRequest/initiator=]
      :: The [=serialization of an origin=] given |request|'s [=request/origin=].

          Note: An opaque origin will result in [=WebRequestRequest/
          initiator=] being set to the {{DOMString}} "null".

      : [=WebRequestRequest/type=]
      :: The result of calling [=get a request's ResourceType=] given |request|.

      : [=WebRequestRequest/id=]
      :: |request|'s [=request/requestId=].

  1. If |requestedHeaders| is not "{{RequestedHeaders/none}}", then set
      |event|'s [=WebRequestEvent/request=]'s [=WebRequestRequest/headers=]
      to the result of calling [=convert a header list to a Headers object=]
      given |request|'s [=request/header list=], |requestedHeaders|, and
      isRequest equal to `true`.

</div>

<div algorithm>
  To <dfn>get the {{DocumentLifecycle}} of a {{Document}}</dfn> |document|,
  run the following steps:

  1. If |document|'s [=unload counter=] &gt; 0, then return
      "{{DocumentLifecycle/pending-deletion}}".

  1. If |document|'s [=node navigable=] is non-null and is a [=prerendering
      navigable=], then return "{{DocumentLifecycle/prerender}}".

  1. If |document| is [=salvageable=] and does not have its [=page showing=],
      return "{{DocumentLifecycle/cached}}".

  1. Return "{{DocumentLifecycle/active}}".

</div>

<div algorithm>
  To <dfn>create a {{WebRequestResponse}} object</dfn> given a [=/request=]
  |request|, a [=/response=] |response|, and a {{RequestedHeaders}}
  |requestedHeaders|, run the following steps:

  1. Let |response| be a [=new=] {{WebRequestResponse}} with the following fields:

      : [=WebRequestResponse/statusCode=]
      :: |response|'s [=response/status=].

      : [=WebRequestResponse/statusLine=]
      :: |response|'s [=response/status message=].

      : [=WebRequestResponse/fromCache=]
      :: `true` if |response|'s [=response/cache state=] is "local",
          `false` otherwise.

      : [=WebRequestResponse/ip=]
      :: The [=ip address=] from which |response| was received if the request
          involved a network request.

          <span class=XXX>The [[FETCH]] spec currently doesn't specify storing
          the remote IP address used when sending |request|.</span>

  1. If |requestedHeaders| is not "{{RequestedHeaders/none}}", then set
      |response|'s [=WebRequestResponse/headers=] to the result of
      calling [=convert a header list to a Headers object=] given
      |response|'s [=response/header list=], |requestedHeaders|, and isRequest
      equal to `false`.

  1. Return |response|.

</div>

<div algorithm>
  To <dfn>convert a [=header list=] to a {{Headers}} object</dfn> given
  a [=header list=] |fetchHeaders|, a {{RequestedHeaders}} |requestedHeaders|,
  and a [=boolean=] |isRequest|, run the following steps:

  1. [=Assert=] that |requestedHeaders| is not "{{RequestedHeaders/none}}".

  1. Let |headers| be a [=new=] {{Headers}} object.

  1. For each |fetchHeader| in |fetchHeaders|:

      1. If all of the following conditions are met, then [=continue=]:

          * |isRequest| is `true`
          * |requestedHeaders| is "{{RequestedHeaders/cors}}".
          * |fetchHeader| is not a [=CORS-safelisted request-header=]

      1. If all of the following conditions are met, then [=continue=]:

          * |isRequest| is `false`
          * |requestedHeaders| is "{{RequestedHeaders/cors}}".
          * |fetchHeader|[0] is not a [=CORS-safelisted response-header name=]

      1. [=Headers/Append=] |fetchHeader| to |headers|.

  1. Return |headers|.

</div>

<div algorithm>
  To <dfn>get a request's {{ResourceType}}</dfn> given a [=/request=]
  |request|, run the following steps:

  1. If |request|'s [=request/url=]'s [=url/scheme=] equals `"ws"` or `"wss"`,
      then return "{{ResourceType/websocket}}".

  1. If |request|'s [=request/initiator=] equals `"fetch"` or
      `"xmlhttprequest"`, then return "{{ResourceType/xmlhttprequest}}".

  1. If |request|'s [=request/destination=] equals `"document"`,
      then return "{{ResourceType/main-frame}}".

  1. If |request|'s [=request/destination=] equals `"frame"` or `"iframe"`,
      then return "{{ResourceType/sub-frame}}".

  1. If |request|'s [=request/destination=] equals `"style"` or `"xslt"`,
      then return "{{ResourceType/stylesheet}}".

  1. If |request|'s [=request/destination=] equals `"script"`, `"json"`,
      `"audioworklet"`, `"paintworklet"`, `"serviceworker"`, `"sharedworker"`,
      or `"worker"`, then return "{{ResourceType/script}}".

  1. If |request|'s [=request/destination=] equals `"image"`,
      then return "{{ResourceType/image}}".

  1. If |request|'s [=request/destination=] equals `"font"`,
      then return "{{ResourceType/font}}".

  1. If |request|'s [=request/destination=] equals `"object"` or `"embed"`,
      then return "{{ResourceType/object}}".

  1. If |request|'s [=request/destination=] equals `"audio"`, `"track"`, or
      `"video"`, then return "{{ResourceType/media}}".

  1. If |request|'s [=request/destination=] equals `"report"`,
      then return "{{ResourceType/csp-report}}".

  1. If |request|'s [=request/destination=] equals `""` and |request|'s
      [=request/keepalive=] is `true`, then return "{{ResourceType/ping}}".

  1. Return "{{ResourceType/other}}".

</div>

<div algorithm>
  To <dfn>create a redirect response</dfn> given a {{DOMString}} |redirectUrl|,
  return a [=/response=] with the following fields:

  : [=response/status=]
  :: 301

  : [=response/header list=]
  :: « ("Location", |redirectUrl|) »

</div>


## Monkey Patches ## {#api-web-request-monkey}

### Fetch ### {#api-web-request-monkey-fetch}

A [=/request=] has an associated <dfn for=request>requestId</dfn>, which is an
opaque string, randomly assigned at the request's creation.

The [=main fetch=] algorithm is monkey patched as follows:

  1. Let |request| be |fetchParams|'s request.

  2. Let |response| be null.

  3. <ins>Let |webRequestResult| be the result of calling [=process
      beforeRequest events=] given |request|.</ins>

  4. <ins>If |webRequestResult| is not null, then:</ins>

      1. <ins>If |webRequestResult|'s [=WebRequestEvent result/cancel=] is
          `true`, then set |response| to a [=network error=].</ins>

      1. <ins>Otherwise, if |webRequestResult|'s [=WebRequestEvent result/
          redirectURL=] is not an empty {{DOMString}}, then set |response| to
          the result of [=creating a redirect response=] given
          |webRequestResult|'s [=WebRequestEvent result/redirectURL=].</ins>


The [=fetch response handover=] algorithm is monkey patched as follows:

  1. <ins>If |response| is not a [=network error=], then call [=process
      responseStarted events=] given |fetchParams|'s [=fetch params/request=]
      and |response|.</ins>

  1. Let timingInfo be |fetchParams|’s timing info.

&vellip;

  9. If |fetchParams|’s process response consume body is non-null, then:

      &hellip;

  10. <ins>If |response| is not a [=network error=], then call [=process
      completed events=] given |fetchParams|'s [=fetch params/request=]
      and |response|.</ins>

  11. <ins>Otherwise, call [=process errorOccurred events=] given
      |fetchParams|'s [=fetch params/request=] and |response|.</ins>


The [=HTTP-network-or-cache fetch=] algorithm is monkey patched as follows:

  7. Let the revalidatingFlag be unset.

  8. <ins>Set |webRequestResult| to the result of calling [=process
      beforeSendHeaders events=] given |request|.</ins>

  9. <ins>If |webRequestResult| is not null, then:</ins>

      1. <ins>If |webRequestResult|'s [=WebRequestEvent result/cancel=] is
          `true`, then set |response| to a [=network error=].</ins>

      1. <ins>Otherwise, if |webRequestResult|'s [=WebRequestEvent result/
          requestHeaders=] is a non-empty [=list=], then set |request|'s
          [=request/header list=] to |webRequestResult|'s [=WebRequestEvent
          result/requestHeaders=]'s [=Headers/header list=].</ins>

  10. <ins>If |response| is not null, </ins> run these steps, but abort when
      |fetchParams| is canceled:

      &vellip;

  11. If aborted, then return the appropriate network error for |fetchParams|.

  12. If |response| is null, then:

      1. If httpRequest's cache mode is "`only-if-cached`", then return a
          network error.

      2. <ins>Call [=process sendHeaders events=] given |request|.</ins>

      3. Let |forwardResponse| be the result of running [=HTTP-network fetch=]
          given httpFetchParams, includeCredentials, and isNewConnectionFetch.

      4. <ins>Let |webRequestResult| be the result of calling [=process
          headersReceived events=] given |request| and |forwardResponse| if
          |forwardResponse| is not a [=network error=], null otherwise.</ins>

      5. <ins>If |webRequestResult| is not null, then:</ins>

          1. <ins>If |webRequestResult|'s [=WebRequestEvent result/cancel=] is
              `true`, then set |response| to a [=network error=].</ins>

          1. <ins>Otherwise, if |webRequestResult|'s
              [=WebRequestEvent result/redirectURL=] is not an empty
              {{DOMString}}, then set |forwardResponse| to the result of
              [=creating a redirect response=] given
              |webRequestResult|'s [=WebRequestEvent result/redirectURL=].</ins>

          1. <ins>Otherwise, if |webRequestResult|'s
              [=WebRequestEvent result/responseHeaders=] is a non-empty
              [=list=], then set |forwardResponse|'s [=response/header list=] to
              |webRequestResult|'s [=WebRequestEvent result/responseHeaders=]'s
              [=Headers/header list=].</ins>

&vellip;

  16. If response’s status is 401, httpRequest’s response tainting is not
      "cors", includeCredentials is `true`, and request’s window is an
      environment settings object, then:

      &vellip;

      3. If request’s use-URL-credentials flag is unset or
          isAuthenticationFetch is `true`, then:

          1. If |fetchParams| is canceled, then return the appropriate network
              error for |fetchParams|.

          1. Let |username| and |password| be null.

          1. <ins>Let |webRequestResult| be the result of calling [=process
              authRequired events=] given |request| and |response|.</ins>

          1. <ins>If |webRequestResult| is not null, then:</ins>

              1. <ins>If |webRequestResult|'s [=WebRequestEvent result/cancel=]
                  is `true`, then set |response| to a [=network error=].</ins>

              1. <ins>Otherwise, if |webRequestResult|'s [=WebRequestEvent
                  result/authCredentials=] is an {{/object}}, then:</ins>

                  1. <ins>Set |username| to |webRequestResult|'s
                      [=WebRequestEvent result/authCredentials=]["{{
                      WebRequestAuthCredentials/username}}"].</ins>

                  1. <ins>Set |password| to |webRequestResult|'s
                      [=WebRequestEvent result/authCredentials=]["{{
                      WebRequestAuthCredentials/password}}"].</ins>

          1. <ins>If |username| and |password| are null, then set them to</ins>
              the result of prompting the end user for a username and password,
              respectively, in |request|'s [=request/window=].

  17. If response’s status is 407, then:

      4. <ins>Let |webRequestResult| be the result of calling [=process
          authRequired events=] given |request| and |response|.</ins>

      5. <ins>If |webRequestResult| is not null, then:</ins>

          1. <ins>If |webRequestResult|'s [=WebRequestEvent result/cancel=] is
              `true`, then set |response| to a [=network error=].</ins>

          1. <ins>Otherwise, if |webRequestResult|'s [=WebRequestEvent result/
              authCredentials=] is an {{/object}}, then:</ins>

              1. <ins>Store |webRequestResult|'s [=WebRequestEvent result/
                  authCredentials=] as a [=proxy-authentication entry=].</ins>

      6. <ins>Otherwise,</ins> prompt the end user as appropriate ...


The [=HTTP-redirect fetch=] algorithm is monkey patched as follows:

  1. <ins>Call [=process beforeRedirect events=] given |request| and
      |response|.</ins>

  1. Let request be |fetchParams|’s request.

<!-- ====================================================================== -->
# Context Menus API # {#api-context-menus}
<!-- ====================================================================== -->

<xmp class="idl">
enum ContextType {
    "all",
    "page",
    "frame",
    "selection",
    "link",
    "editable",
    "image",
    "video",
    "audio",
};

enum ItemType {
    "normal",
    "checkbox",
    "radio",
    "separator",
};

dictionary ContextMenusProperties {
    boolean checked;
    sequence<ContextType> contexts;
    sequence<(URLPattern or URLPatternInput)> documentURLPatterns;
    boolean enabled;
    DOMString parentId;
    sequence<(URLPattern or URLPatternInput)> targetURLPatterns;
    DOMString title;
    ItemType type;
};

dictionary ContextMenusCreateProperties : ContextMenusProperties {
    required DOMString id;
};

[Exposed=Window, IsolatedContext]
interface ContextMenus : EventTarget {
    Promise<undefined> create(ContextMenusCreateProperties properties);
    Promise<undefined> remove(DOMString id);
    Promise<undefined> removeAll();
    Promise<undefined> update(DOMString id, optional ContextMenusProperties properties = {});

    attribute EventHandler onclick;
    attribute EventHandler onshow;
};

[Exposed=Window, IsolatedContext]
interface MenuItemDetails {
    readonly attribute DOMString id;
    readonly attribute DOMString? parentMenuId;
    readonly attribute boolean? checked;
    readonly attribute boolean? wasChecked;
};

[Exposed=Window, IsolatedContext]
interface ContextMenusClickEvent : Event {
  readonly attribute MenuItemDetails menuItem;

  // Details about the frame the context menu is opened within.
  readonly attribute long frameId;
  readonly attribute USVString frameURL;
  readonly attribute USVString pageURL;

  // Details about the element the context menu is opened within the context of.
  readonly attribute boolean editable;
  readonly attribute USVString? linkURL;
  readonly attribute DOMString? mediaType;
  readonly attribute DOMString? selectionText;
  readonly attribute USVString? srcURL;
};
</xmp>

Each <{controlledframe}> has a {{HTMLControlledFrameElement/contextMenus}}
member, which is a {{ContextMenus}}. Each {{ContextMenus}} manages a
<dfn for=ContextMenus>context menu [=/map=]</dfn> whose [=map/keys=] are
{{DOMString}}s representing menu item ids, and whose [=map/values=] are
{{ContextMenusProperties}}.

Each [=map/entry=] of the [=context menu map=] represents a
[=context menu item=]. A <dfn for=ContextMenus>context menu item</dfn>
represents an entry in a [=context menu=]. Each [=context menu item=] has an
associated:

  <div dfn-for="context menu item">
    * <dfn>id</dfn>, the [=map/key=] of the [=context menu map=] [=map/entry=]
        that the [=context menu item=] corresponds to.
    * <dfn>properties</dfn>, the [=map/value=] of the [=context menu map=]
        [=map/entry=] that the [=context menu item=] corresponds to.
    * <dfn>menu</dfn>, the [=context menu=] that the [=context menu item=]
        belongs to.
  </div>

A <dfn for=ContextMenus>context menu</dfn> represents an
[=implementation-defined=] interface that can display [=context menu items=]
to the user. Each [=context menu=] has an associated <dfn for="context menu">
context element</dfn>, which is the {{HTMLElement}} that the [=context menu=]
was opened within the context of.

A [=ContextMenus/context menu item=] |item| should be shown to the user as the
result of an [=implementation-defined=] action if [=determining whether the
context menu item will be shown=] given |item| returns `true`.

Note: The intention of this API is to expose context-dependent additional
      actions to users. On desktop platforms this might take the form of entries
      in a context menu that is accessed by right clicking on content within the
      Controlled Frame; on mobile devices it might be accessed by long pressing
      on an item within the Controlled Frame. In these examples the [=context
      menu=]'s [=context menu/context element=] would be the element that the
      user right clicked or long pressed on.

The [=map/values=] of the [=context menu map=], which are
{{ContextMenusProperties}} objects, control the conditions under which the
[=context menu items=] are displayed, as well as the features and behaviors
of the items.

<div class=note>
    <em>This section is non-normative.</em>

    {{ContextMenusProperties}} has the following fields:

    : {{ContextMenusProperties/contexts}}
    :: A [=list=] of different {{ContextType}}. If it is not [=list/empty=],
        then the [=context menu item=] will not be shown unless the element that
        was clicked on to open the [=ContextMenus/context menu=] equals one of
        the [=list=] [=list/items=]. If it is [=list/empty=], then this check
        is ignored.

    : {{ContextMenusProperties/documentURLPatterns}}
    :: A [=list=] of {{URLPattern}}s or {{URLPatternInput}}s. If it is not
        [=list/empty=], then the [=context menu item=] will not be shown unless
        the [=/URL=] of the embedded document [=matches a URLPattern=] with
        one of the [=list=] [=list/items=]. If it is [=list/empty=], then this
        check is ignored.

    : {{ContextMenusProperties/targetURLPatterns}}
    :: A [=list=] of {{URLPattern}}s or {{URLPatternInput}}s. If it is not
        [=list/empty=], then the [=context menu item=] will not be shown unless
        the [=/URL=] of the target of the [=ContextMenus/context menu=]
        [=matches a URLPattern=] with one of the [=list=] [=list/items=]. If
        it is [=list/empty=], then this check is ignored.

    Note: Target is the "src" attribute of img/audio/video tags and the "href"
    of anchor tags.

    : {{ContextMenusProperties/parentId}}
    :: The ID of the parent [=ContextMenus/context menu item=]. The
        [=ContextMenus/context menu item=] may appear under a sub-menu of
          the parent.

    : {{ContextMenusProperties/title}}
    :: The title of the menu item. This is mandatory unless
        {{ContextMenusProperties/type}} is "{{ItemType/separator}}".

    : {{ContextMenusProperties/type}}
    :: The type of the menu item.

    : {{ContextMenusProperties/checked}}
    :: Whether the [=ContextMenus/context menu item=] is initially checked,
        if the {{ContextMenusProperties/type}} is {{ItemType/checkbox}}.

    : {{ContextMenusProperties/enabled}}
    :: Whether the [=ContextMenus/context menu item=] is enabled.

</div>

<div algorithm>

  The <dfn method for=ContextMenus>create(|properties|)</dfn> method steps are:

  1. Let |p| be [=a new promise=].

  1. Let |controlledframe| be [=this=].

  1. Return |p| and run the following steps [=in parallel=].

  1. Let |contextMenusMap| be |controlledframe|'s [=ContextMenus/context menu
      map=].

  1. Let |id| be the |properties|["{{ContextMenusCreateProperties/id}}"].

  1. If |contextMenusMap|[|id|] [=map/exists=], [=reject an embedder promise=]
      given |controlledframe|, |p|, and {{TypeError}}, and abort these steps.

  1. [=map/Set=] |contextMenusMap|[|id|] to |properties|.

  1. [=Resolve an embedder promise=] given |controlledframe| and |p|.

</div>

<div algorithm>

  The <dfn method for=ContextMenus>remove(|id|)</dfn> method steps are:

  1. Let |p| be [=a new promise=].

  1. Let |controlledframe| be [=this=].

  1. Return |p| and run the following steps [=in parallel=].

  1. Let |contextMenusMap| be |controlledframe|'s [=ContextMenus/context menu
      map=].

  1. [=map/Remove=] |contextMenusMap|[|id|].

  1. [=Resolve an embedder promise=] given |controlledframe| and |p|.

</div>

<div algorithm>

  The <dfn method for=ContextMenus>removeAll()</dfn> method steps are:

  1. Let |p| be [=a new promise=].

  1. Let |controlledframe| be [=this=].

  1. Return |p| and run the following steps [=in parallel=].

  1. Let |contextMenusMap| be |controlledframe|'s [=ContextMenus/context menu
      map=].

  1. [=map/Clear=] |contextMenusMap|.

  1. [=Resolve an embedder promise=] given |controlledframe| and |p|.

</div>

<div algorithm>

  The <dfn method for=ContextMenus>update(|id|, |properties|)</dfn> method steps are:

  1. Let |p| be [=a new promise=].

  1. Let |controlledframe| be [=this=].

  1. Return |p| and run the following steps [=in parallel=].

  1. Let |contextMenusMap| be |controlledframe|'s [=ContextMenus/context menu
      map=].

  1. If |contextMenusMap|[|id|] does not [=map/exist=], [=reject an embedder
      promise=] given |controlledframe|, |p|, and {{TypeError}},
      and abort these steps.

  1. [=map/Set=] |contextMenusMap|[|id|] to |properties|.

  1. [=Resolve an embedder promise=] given |controlledframe| and |p|.

</div>

<div class=note>
<em>This section is non-normative.</em>

{{ContextType}}s represent the context of a context menu, can be following values:

    : {{ContextType/frame}}
    :: Applies when the user context-clicks in a nested frame, such as an <{iframe}>.

    : {{ContextType/selection}}
    :: Applies when part of the document is selected.

    : {{ContextType/link}}
    :: Applies when the user context-clicks on a link.

    : {{ContextType/editable}}
    :: Applies when the user context-clicks an editable element, like a
        <{textarea}>.

    : {{ContextType/image}}
    :: Applies when the user context-clicks an image.

    : {{ContextType/video}}
    :: Applies when the user context-clicks a <{video}> element.

    : {{ContextType/audio}}
    :: Applies when the user context-clicks an <{audio}> element.

    : {{ContextType/page}}
    :: Applies when the user context-clicks in the page, but none of the other
        page contexts apply (for example, the click is not on an image or a
        nested iframe or a link).

    : {{ContextType/all}}
    :: Specifying 'all' is equivalent to the combination of all other contexts.

</div>

<div algorithm>

  To <dfn>determine whether the [=ContextMenus/context menu item=] will be shown
  </dfn> given a [=context menu item=] |item|:

  1. Let |properties| be |item|'s [=context menu item/properties=].

  1. Let |element| be |item|'s [=context menu item/menu=]'s
      [=context menu/context element=].

  1. Let |controlledframe| be |element|'s [=node navigable=]'s
      [=controlledFrameEmbedderParent=].

  1. If |controlledframe| is null, then return `false`.

  1. Let |documentUrl| be the [=Document/URL=] of |controlledframe|'s [=embedded
      navigable=]'s [=active document=].

  1. Let |targetUrl| be an empty string.

  1. If |element| is an instance of {{HTMLImageElement}}, then set
      |targetUrl| to the {{HTMLImageElement/src}} attribute of |element|.

  1. If |element| is an instance of {{HTMLMediaElement}}, then set
      |targetUrl| to the {{HTMLMediaElement/src}} attribute of |element|.

  1. If |element| is an instance of {{HTMLAnchorElement}}, then set
      |targetUrl| to the [=href=] attribute of |element|.

  1. If |properties|["{{ContextMenusProperties/contexts}}"] is not
      [=list/empty=]:

      1. Let |matchesContext| be a boolean value that is initially `false`.

      1. For each |context| in
          |properties|["{{ContextMenusProperties/contexts}}"]:

          1. If |element| matches |context|, set |matchesContext| to `true`
              and break;

              Issue: {{ContextType}} matching behavior isn't specified, though
              the note above has some information on the desired behavior.

      1. If |matchesContext| is `false`, return `false`.

  1. If |properties|["{{ContextMenusProperties/documentURLPatterns}}"] is
      not [=list/empty=]:

      1. Let |matchesDocumentUrl| be a boolean value that is initially `false`.

      1. For each |urlPattern| in |properties|["{{
            ContextMenusProperties/documentURLPatterns}}"]:

          1. If |urlPattern| is a {{URLPatternInput}}, then set |urlPattern| to
              a [=new=] {{URLPattern}} given |urlPattern|.

          1. If |documentUrl| [=matches a URLPattern=], given |urlPattern|,
              then set |matchesDocumentUrl| to `true` and break;

      1. If |matchesDocumentUrl| is `false`, return `false`.

  1. If |properties|["{{ContextMenusProperties/targetURLPatterns}}"] is not
      [=list/empty=]:

      1. Let |matchesTargetUrl| be a boolean value that is initially `false`.

      1. For each |urlPattern| in |properties|["{{
          ContextMenusProperties/targetURLPatterns}}"]:

          1. If |urlPattern| is a {{URLPatternInput}}, then set |urlPattern| to
              a [=new=] {{URLPattern}} given |urlPattern|.

          1. If |targetUrl| [=matches a URLPattern=], given |urlPattern|, then
              set |matchesTargetUrl| to `true` and break;

      1. If |matchesTargetUrl| is `false`, return `false`.

  1. Return `true`.

</div>

## Events ## {#api-context-menus-events}

{{ContextMenus}} fires the following events:

<table>
  <tr>
    <th>Event name</th>
    <th>Interface</th>
    <th>Fired when...</th>
  </tr>
  <tr>
    <td><dfn for=ContextMenus>show</dfn></td>
    <td>{{Event}}</td>
    <td>a context menu is displayed to the user.</td>
  </tr>
  <tr>
    <td><dfn for=ContextMenus>click</dfn></td>
    <td>{{ContextMenusClickEvent}}</td>
    <td>a [=context menu item=] is selected by the user.</td>
  </tr>
</table>

{{ContextMenus}} supports the following [=event handlers=] (and their
corresponding [=event handler event types=]) as [=event handler IDL attributes=]:

<table>
  <tr>
    <th>[=Event handlers=]</th>
    <th>[=Event handler event types=]</th>
  </tr>
  <tr>
    <td><dfn attribute for=ContextMenus>onshow</dfn></td>
    <td>[=ContextMenus/show=]</td>
  </tr>
  <tr>
    <td><dfn attribute for=ContextMenus>onclick</dfn></td>
    <td>[=ContextMenus/click=]</td>
  </tr>
</table>

When one or more of a {{ContextMenus}} |contextMenus|'s [=ContextMenus/
context menu items=] are shown to the user, [=ContextMenus/dispatch a
show event=] to |contextMenus|.

When a [=ContextMenus/context menu item=] |item| is selected by a user,
[=ContextMenus/dispatch a click event=] given |item|.

<div algorithm>
To <dfn for=ContextMenus>[=dispatch=] a [=ContextMenus/show=] [=event=]</dfn>
given a {{ContextMenus}} |contextMenus|, [=dispatch=] a [=new=] {{Event}}
named [=ContextMenus/show=] to |contextMenus|.
</div>

<div algorithm>
To <dfn for=ContextMenus>[=dispatch=] a [=ContextMenus/click=] [=event=]</dfn>
given a [=context menu item=] |item|, run the following steps:

1. Let |properties| be |item|'s [=context menu item/properties=].

1. Let |menu| be |item|'s [=context menu item/menu=].

1. Let |element| be |menu|'s [=context menu/context element=].

1. Let |event| be a [=new=] {{ContextMenusClickEvent}} named
    [=ContextMenus/click=].

1. Set |event|["{{ContextMenusClickEvent/menuItem}}"] to a [=new=]
    {{MenuItemDetails}} with the following fields:

    : {{MenuItemDetails/id}}
    :: |item|'s [=context menu item/id=].

    : {{MenuItemDetails/parentMenuId}}
    :: |properties|["{{ContextMenusProperties/parentId}}"].

    : {{MenuItemDetails/checked}}
    :: Whether the [=context menu item=] is checked.

    : {{MenuItemDetails/wasChecked}}
    :: The state of a checkbox or radio item before it was clicked.

  1. Set the following fields of |event|:

      : {{ContextMenusClickEvent/frameId}}
      :: The [=navigable/frameId=] of |element|'s [=node navigable=].

      : {{ContextMenusClickEvent/frameURL}}
      :: The [=Document/URL=] of the |element|'s [=node navigable=].

      : {{ContextMenusClickEvent/pageURL}}
      :: The [=Document/URL=] of the |element|'s [=traversable navigable=].

      : {{ContextMenusClickEvent/editable}}
      :: Whether the |element| selected is editable, such as a text input.

      : {{ContextMenusClickEvent/linkURL}}
      :: If |element| is an instance of {{HTMLAnchorElement}}, |element|'s
          {{HTMLHyperlinkElementUtils/href}} [=attribute=].

      : {{ContextMenusClickEvent/mediaType}}
      :: One of "image", "video", or "audio", if any, based on |element|.

      : {{ContextMenusClickEvent/selectionText}}
      :: The text for the context selection, if any.

      : {{ContextMenusClickEvent/srcURL}}
      :: The "src" attribute of |element|, if it exists.

1. [=Dispatch=] |event| at |menu|.

</div>

<!-- ====================================================================== -->
# Usage Overview # {#usage-overview}
<!-- ====================================================================== -->

Lorem ipsum. Insert basic info and example here.

<!-- ====================================================================== -->
# Motivating Applications # {#motivating-applications}
<!-- ====================================================================== -->

*This section is non-normative.*

<!-- ====================================================================== -->
## Latency-sensitive applications in virtualized sessions ## {#browser-content-redirection}
<!-- ====================================================================== -->

In virtualized environments, users typically have a local thin client that
renders a full virtual desktop. The actual desktop execution environment will be
running on a remote virtualization server. If the user's browser navigates to a
latency-sensitive application (such as a video app), the rendered content will
have additional latency ("lag") that makes the experience difficult or
impossible for the user. This also applies for applications that record the
user, such as video conferencing applications. In these latency-sensitive
applications, the virtual desktop application can render the latency-sensitive
content locally and overlay it on top of the rendered remote content to reduce
this latency. This use case is also known as "browser content redirection."

<!-- ====================================================================== -->
## Embedding third party web content without restriction ## {#no-embedding-prohibitions}
<!-- ====================================================================== -->

In a kiosk environment, applications must load content from third parties and
display that content on screens within their applications. A teacher may trigger
the navigation event, or it may be configured by an administrator such as a
shopping mall manager. The content may prohibit embedding by <{iframe}> through
the use of X-Frame-Options and CSP. An controlled frame, however, should be able
to load all content, even content that prohibits embedding by <{iframe}>.

<!-- ====================================================================== -->
## Remote display and manipulation of web content ## {#remote-content-control}
<!-- ====================================================================== -->

In a kiosk environment, applications must ensure that content continues to
display on screens and may need to interrupt content with their own supplied
behaviors. This behavior should work without local attendance by an
administrator, and ideally can be managed remotely over the network. If content
were to crash, for example, these applications should observe and respond to the
crash by reloading the content in a fresh embedded view.

<!-- ====================================================================== -->
## Clearing user content after each session ## {#clearing-session-data}
<!-- ====================================================================== -->

In some environments, someone only uses a single device for a brief time to
complete their task, like ordering in a restaurant. When their task is complete,
the embedder application should be able to clear all of the local user data
associated with the task and then restart the embedded instance.

<!-- ====================================================================== -->
## Monitor for idle sessions ## {#monitor-idle-sessions}
<!-- ====================================================================== -->

While users interact with embedded content, the user may not explicitly end
their session. This content may assume the user is present when they have
actually finished or departed without completing the task. Embedder applications
want to detect when users idle over their case's threshold and begin a fresh
session.

<!-- ====================================================================== -->
## Arbitrarily blocking navigations ## {#blocking-navigations}
<!-- ====================================================================== -->

While displaying embedded web content that's not authored by the embedder, pages
may link to third party web content that's disallowed. Allowing the embedder to
edit elements in embedded content through arbitrary script injection into the
web content can ensure navigation cannot occur to blocked pages. The embedder
can also use the Controlled Frame API to capture navigation events and ensure
that only pages to approved sites can be loaded within that controlled frame.

<!-- ====================================================================== -->
# Security, Privacy, and Accessibility Considerations # {#considerations}
<!-- ====================================================================== -->

*This section is non-normative.*

<!-- ====================================================================== -->
## Security ## {#security}
<!-- ====================================================================== -->

<b>Controlled Frame is based upon [[Isolated-Web-Apps]] (IWA)
and integrates with core security specs</b>

Since Controlled Frame is a particularly powerful API, using it or even having
it available makes an app a target of various types of hacking. As a result,
this API is limited to use in [[Isolated-Web-Apps|IWA]] which have additional
safeguards in place to protect application developers and users. The Isolated
Web App explainer has this to say:

> <i>"A user agent may also force an application to adopt this threat model if
the developer needs access to APIs which would make the application an appealing
target for XSS or server-side attacks."</i>

Controlled Frame makes just such an appealing target, and to expose this with
caution we're opting into [[Isolated-Web-Apps|IWA]] to guard against certain
attacks. Generally, [[Isolated-Web-Apps|IWAs]] provide strong security
assurances that each of the resources in an application are secure both at rest
and in-transit. You can read more about [[Isolated-Web-Apps|IWAs]] security and
permissions in the [[Isolated-Web-Apps|IWA]] explainer and the
[[Isolated-Web-Apps|IWAs]] [[High-Watermark-Permissions]] explainer.

Controlled Frame integrates with [[!Permissions-Policy]] and [[!Permissions]].
You can read more about [[Permissions-Policy#privacy]] and
[[Permissions#security-considerations]] (note the entry is currently sparse).

<b>Attacking web sites could display content that doesn't otherwise allow itself
to be embedded and trick users on non-[[Isolated-Web-Apps|IWAs]].</b>

Planned mitigation:

-  Controlled Frame will only be available within [[Isolated-Web-Apps|IWAs]]

<b>An [[Isolated-Web-Apps|IWA]] may embed another [[Isolated-Web-Apps|IWA]] (or
itself) via Controlled Frame to manipulate our [[Isolated-Web-Apps|IWA]]
policies somehow (e.g. an Controlled Frame embedded [[Isolated-Web-Apps|IWA]]
may detect it's being embedded due to the absence of the "controlled-frame"
policy-controlled feature).</b>

Planned mitigation:

-  Controlled Frame can only point to "https" schemes, excluding the
    "isolated-app" scheme used for [[Isolated-Web-Apps|IWAs]]

<b>Controlled Frame could gain access to the powerful &lt;controlledframe&gt;
element.</b>

An [[Isolated-Web-Apps|IWA]] that's not expected to use Controlled Frame may
attempt to embed content.

Planned mitigation:

-  [[Isolated-Web-Apps|IWA]] APIs can never be delegated to cross-origin, so it
    will not be possible for any nested top-level navigable to access an
    [[Isolated-Web-Apps|IWA]].
-  Secondly, only embedder applications and their same-origin
    [[Isolated-Web-Apps|IWA]] child navigables that have been granted the
    "controlled-frame" policy-controlled feature will have the Controlled Frame
    element available.
-  Same-origin child navigables without the "controlled-frame"
    policy-controlled feature will not be provided a Controlled Frame element.
    Their inner same-origin nested navigables will always not have it available.

<b>An IWA may attempt to embed content from non-https schemes, such as 'http:'
or 'isolated-app:'</b>

Planned mitigation:

-  Controlled Frame will only work when the navigable's "src" [=request/URL=]
    has an 'https:' scheme.

<b>Malicious Controlled Frame could access the embedder's running process (eg.
Spectre attack)</b>

Planned mitigation:

-  Controlled Frame will be executed in a separate process from the
    embedder's process

<b>Controlled Frame for a given "https origin" could interact or interfere with
the user's own storage data for that https origin</b>

Planned mitigation:

-  We're adding a Partition concept. Every Partition is a tuple of
    StorageKey and a separate object key.
-  Let there be a default partition with key=0 that stores
    "non-[[Isolated-Web-Apps|IWA]]" window
    and tab usage.
-  Controlled Frame will always store data in a certain StorageKey which is
    apart from the default partition.
-  Data written to by a given "https origin" while the user accesses that
    origin via an [[Isolated-Web-Apps|IWA]] Controlled Frame will be isolated
    from the default partition.
-  All usage will be separated between [[Isolated-Web-Apps|IWA]] and each
    partition will be fully isolated from each other and from default
    usage outside of [[Isolated-Web-Apps|IWA]].

<b>Malicious Controlled Frame could overwrite embedder's stored data</b>

-  The embedder and embedded storage user agent could overlap, and possibly
    multiple same-site [[Isolated-Web-Apps|IWA]] child navigables could be
    affected by activity in the Controlled Frame
-  if storage user agents were shared between the embedder and embedded
    sites, clearing data for either one could negatively impact the other

Planned mitigation:

-  [[Isolated-Web-Apps|IWA]] and Controlled Frame will always have separate
    storage user agents
-  A Controlled Frame should not have read or write access to other storage
    user agents besides its own

<b>Malicious Controlled Frame may detect it is embedded and attempt to attack
the embedder application</b>

Planned mitigation:

-  The user agent will match the browser.
-  The Controlled Frame storage user agent will be separate from the
    [[Isolated-Web-Apps|IWA]] and the default storage user agents.
-  The Controlled Frame process will be separate from the
    [[Isolated-Web-Apps|IWA]] and the default renderer and browser processes.
-  The Controlled Frame environment will appear to be the top-most navigable:
    -  window should match window.parent and window.top
    -  List of policy-controlled features and their disable/enable status
        should match the default for a navigable

Ideas:

-  Investigate for potential interactions around filesystem, quota storage,
    and localStorage APIs

<b>User may not be able to verify the origin of the page being viewed in the
Controlled Frame</b>

Ideas:

-  Expose the origin to the user somehow, such as adding UI at the top of a
    Controlled Frame that displays the origin?
-  Have the [[Isolated-Web-Apps|IWA]] specify in the manifest the origins that
    they expect to access?

<b>Controlled Frame may exploit vulnerabilities in out-of-date browser
engine</b>

Already addressed with:

-  Existing browser engine auto-update mechanisms

<!-- ====================================================================== -->
## Privacy ## {#privacy}
<!-- ====================================================================== -->

Controlled Frame integrates with Permissions Policy and Permissions. You can
read more about [[Permissions-Policy#privacy]].  You can read more about
[[Permissions#security-considerations]].

For Controlled Frame specifically, we've identified the following privacy
considerations:

-  Users' browsing within Controlled Frame will be visible to the
    [[Isolated-Web-Apps|IWA]]
-  [[Isolated-Web-Apps|IWAs]] can access and exfiltrate the Controlled Frame's
    session cookies (this only applies to the Controlled Frame's session since
    they use a separate storage partition from the [[Isolated-Web-Apps|IWA]] and
    the third party origin when browsed in a tab)
-  User activity in Controlled Frame can be observed by the
    [[Isolated-Web-Apps|IWA]] (e.g. keyboard events can be monitored, password
    entry can be sniffed)
-  User file upload to Controlled Frame can be hijacked
-  User data held in the Controlled Frame's remote server could be accessed by
    code implanted by the [[Isolated-Web-Apps|IWA]]
-  Users that wish to clear their session history must also do so via the
    [[Isolated-Web-Apps|IWA]], which will then need to clear the associated
    storage user agents
    -  This would be necessary since embedded storage user agents are separate
        from the non-embedded storage user agents for any given https origin
-  We plan to investigate browser UX to allow users to clear the Controlled
    Frame storage user agents, the following cases will be considered:
    -  If a user wants to clear site data for an [[Isolated-Web-Apps|IWA]], the
        associated embedded storage user agents will also be cleared
        -  This is because if the [[Isolated-Web-Apps|IWA]]'s data is cleared,
            the app will no longer have any context for the associated embedded
            storage user agents and therefore will no longer be used or useful
            to the user or organization
        -  As a result, we expect that clearing an [[Isolated-Web-Apps|IWA]]'s
            site data will require clearing all of the associated embedded
            storage user agents
    -  A user may want to clear all site data for a given "https origin", even
        if that origin is stored within an [[Isolated-Web-Apps|IWA]]'s embedded
        storage user agent
        -  We may choose to provide the ability to clear all
            [[Isolated-Web-Apps|IWA]] site data for that "https origin" even if
            that site data is held within an embedded storage user agent
        -  If we chose to clear the "https origin" data,
            [[Isolated-Web-Apps|IWAs]] would need to prepare for the possibility
            that embedded storage user agents may be removed outside of their
            control, and this may be disruptive to the [[Isolated-Web-Apps|IWA]]
            and introduce complexity of implementation
        -  Supporting this in the browser user agent exposes browser vendors,
            developers, and users to additional complexity, so we may choose not
            to support this approach and instead leave this up to
            [[Isolated-Web-Apps|IWA]] developers to implement
        -  As a counter example to supporting clearing a single given "https
            origin"'s embedded storage user agent, consider that to our
            knowledge no operating system behaves that way
            -  i.e. there's no central "clear browsing data" option which clears
                storage for all installed browser engines, each application's
                storage is treated as its own to manage
    -  User wants to clear the site data for a given [[Isolated-Web-Apps|IWA]]'s
        Controlled Frame-embedded storage user agent for a given "https origin"
    -  User wants to clear the site data for a given [[Isolated-Web-Apps|IWA]]'s
        Controlled Frame-embedded storage user agents for all "https origins"
-  An [[Isolated-Web-Apps|IWA]] will need the ability to clear the storage user
    agent's Controlled Frame-embedded storage user agent for a given "https
    origin"

<!-- ====================================================================== -->
## Accessibility ## {#accessibility}
<!-- ====================================================================== -->

For Controlled Frame, we've identified the following accessibility
considerations:

-  Browser user agents' accessibility tools and APIs should have visibility into
    Controlled Frame
-  [[Isolated-Web-Apps|IWAs]] should expect to provide their own accessibility
    tools for Controlled Frame content in order to properly integrate
    accessibility features for some use cases (such as "browser content
    redirection")

# Acknowledgements # {#acknowledgements}

The following people contributed to the development of this document.

* <a href="https://github.com/odejesush">Ovidio Ruiz-Henríquez</a>
